var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var _rollup_plugin_ignore_empty_module_placeholder = {};

var _rollup_plugin_ignore_empty_module_placeholder$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': _rollup_plugin_ignore_empty_module_placeholder
});

var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_rollup_plugin_ignore_empty_module_placeholder$1);

var svgo = {};

var config$1 = {};

var plugins$1 = {};

var addAttributesToSVGElement = {};

var xast = {};

var lib$9 = {};

var lib$8 = {};

var stringify$2 = {};

var lib$7 = {};

var lib$6 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;
}(lib$6));

var node$1 = {};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
Object.defineProperty(node$1, "__esModule", { value: true });
node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
var domelementtype_1$1 = lib$6;
var nodeTypes = new Map([
    [domelementtype_1$1.ElementType.Tag, 1],
    [domelementtype_1$1.ElementType.Script, 1],
    [domelementtype_1$1.ElementType.Style, 1],
    [domelementtype_1$1.ElementType.Directive, 1],
    [domelementtype_1$1.ElementType.Text, 3],
    [domelementtype_1$1.ElementType.CDATA, 4],
    [domelementtype_1$1.ElementType.Comment, 8],
    [domelementtype_1$1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
node$1.Node = Node;
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
node$1.DataNode = DataNode;
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
node$1.Text = Text;
var Comment$2 = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1$1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
node$1.Comment = Comment$2;
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1$1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
node$1.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
node$1.NodeWithChildren = NodeWithChildren;
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1$1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
node$1.Document = Document;
var Element$1 = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1$1.ElementType.Script
            : name === "style"
                ? domelementtype_1$1.ElementType.Style
                : domelementtype_1$1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
node$1.Element = Element$1;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag$1(node) {
    return domelementtype_1$1.isTag(node);
}
node$1.isTag = isTag$1;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1$1.ElementType.CDATA;
}
node$1.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1$1.ElementType.Text;
}
node$1.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1$1.ElementType.Comment;
}
node$1.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1$1.ElementType.Directive;
}
node$1.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1$1.ElementType.Root;
}
node$1.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
node$1.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment$2(node.data);
    }
    else if (isTag$1(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element$1(node.name, __assign$1({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign$1({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign$1({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1$1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: " + node.type);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    return result;
}
node$1.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomHandler = void 0;
var domelementtype_1 = lib$6;
var node_1 = node$1;
__exportStar(node$1, exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        var _a;
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = (_a = this.parser) !== null && _a !== void 0 ? _a : null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports.default = DomHandler;
}(lib$7));

var lib$5 = {};

var lib$4 = {};

var decode = {};

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom$1 = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$3 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross$1 = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot$1 = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap$1 = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image$1 = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang$1 = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus$1 = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$2 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order$1 = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub$1 = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target$1 = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top$1 = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$2 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom$1,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$3,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross$1,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot$1,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap$1,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image$1,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang$1,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus$1,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$2,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order$1,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub$1,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target$1,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top$1,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy$2 = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not$1 = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy$2,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not$1,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$0$2 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var decode_codepoint = {};

var require$$0$1 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$4(require$$0$1);
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
decode_codepoint.default = decodeCodePoint;

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$3(require$$1$2);
var legacy_json_1 = __importDefault$3(require$$1$1);
var xml_json_1$1 = __importDefault$3(require$$0$2);
var decode_codepoint_1 = __importDefault$3(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
decode.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1$1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1$1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}

var encode = {};

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault$2(require$$0$2);
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$2(require$$1$2);
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = decode;
var encode_1 = encode;
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode$1(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode$1;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode$1(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode$1;
var encode_2 = encode;
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = decode;
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
}(lib$4));

var foreignNames = {};

Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
foreignNames.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);

var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(lib$5, "__esModule", { value: true });
/*
 * Module dependencies
 */
var ElementType = __importStar(lib$6);
var entities_1 = lib$4;
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = foreignNames;
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
lib$5.default = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(stringify$2, "__esModule", { value: true });
stringify$2.innerText = stringify$2.textContent = stringify$2.getText = stringify$2.getInnerHTML = stringify$2.getOuterHTML = void 0;
var domhandler_1$4 = lib$7;
var dom_serializer_1 = __importDefault$1(lib$5);
var domelementtype_1 = lib$6;
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return dom_serializer_1.default(node, options);
}
stringify$2.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return domhandler_1$4.hasChildren(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
stringify$2.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText$1(node) {
    if (Array.isArray(node))
        return node.map(getText$1).join("");
    if (domhandler_1$4.isTag(node))
        return node.name === "br" ? "\n" : getText$1(node.children);
    if (domhandler_1$4.isCDATA(node))
        return getText$1(node.children);
    if (domhandler_1$4.isText(node))
        return node.data;
    return "";
}
stringify$2.getText = getText$1;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if (domhandler_1$4.isTag(node))
        return textContent(node.children);
    if (domhandler_1$4.isCDATA(node))
        return textContent(node.children);
    if (domhandler_1$4.isText(node))
        return node.data;
    return "";
}
stringify$2.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if (domhandler_1$4.hasChildren(node) && node.type === domelementtype_1.ElementType.Tag) {
        return innerText(node.children);
    }
    if (domhandler_1$4.isCDATA(node))
        return innerText(node.children);
    if (domhandler_1$4.isText(node))
        return node.data;
    return "";
}
stringify$2.innerText = innerText;

var traversal = {};

Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$3 = lib$7;
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren$1(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
traversal.getChildren = getChildren$1;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent$1(elem) {
    return elem.parent || null;
}
traversal.getParent = getParent$1;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings$1(elem) {
    var _a, _b;
    var parent = getParent$1(elem);
    if (parent != null)
        return getChildren$1(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
traversal.getSiblings = getSiblings$1;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue$1(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
traversal.getAttributeValue = getAttributeValue$1;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib$1(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
traversal.hasAttrib = hasAttrib$1;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName$1(elem) {
    return elem.name;
}
traversal.getName = getName$1;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !domhandler_1$3.isTag(next))
        (_a = next, next = _a.next);
    return next;
}
traversal.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !domhandler_1$3.isTag(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
traversal.prevElementSibling = prevElementSibling;

var manipulation = {};

Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
manipulation.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
manipulation.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
manipulation.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$1(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
manipulation.append = append$1;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
manipulation.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
manipulation.prepend = prepend;

var querying = {};

Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$2 = lib$7;
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter$1(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
querying.filter = filter$1;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && domhandler_1$2.hasChildren(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
querying.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
querying.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne$1(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!domhandler_1$2.isTag(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne$1(test, checked.children);
        }
    }
    return elem;
}
querying.findOne = findOne$1;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne$1(test, nodes) {
    return nodes.some(function (checked) {
        return domhandler_1$2.isTag(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne$1(test, checked.children)));
    });
}
querying.existsOne = existsOne$1;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll$1(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1$2.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1$2.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
querying.findAll = findAll$1;

var legacy = {};

Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
var domhandler_1$1 = lib$7;
var querying_1 = querying;
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return domhandler_1$1.isTag(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1$1.isTag;
        }
        return function (elem) { return domhandler_1$1.isTag(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return domhandler_1$1.isText(elem) && data(elem.data); };
        }
        return function (elem) { return domhandler_1$1.isText(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return domhandler_1$1.isTag(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return domhandler_1$1.isTag(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return key in Checks
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
legacy.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? querying_1.filter(test, nodes, recurse, limit) : [];
}
legacy.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return querying_1.findOne(getAttribCheck("id", id), nodes, recurse);
}
legacy.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);
}
legacy.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);
}
legacy.getElementsByTagType = getElementsByTagType;

var helpers = {};

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.uniqueSort = helpers.compareDocumentPosition = helpers.removeSubsets = void 0;
var domhandler_1 = lib$7;
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets$1(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
helpers.removeSubsets = removeSubsets$1;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = domhandler_1.hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = domhandler_1.hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
helpers.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
helpers.uniqueSort = uniqueSort;

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(stringify$2, exports);
__exportStar(traversal, exports);
__exportStar(manipulation, exports);
__exportStar(querying, exports);
__exportStar(legacy, exports);
__exportStar(helpers, exports);
var domhandler_1 = lib$7;
Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
}(lib$8));

var boolbase = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var compile$3 = {};

var lib$3 = {};

var parse$7 = {};

var __spreadArray$1 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(parse$7, "__esModule", { value: true });
parse$7.isTraversal = void 0;
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes$1 = new Map([
    ["~", "element"],
    ["^", "start"],
    ["$", "end"],
    ["*", "any"],
    ["!", "not"],
    ["|", "hyphen"],
]);
var Traversals = {
    ">": "child",
    "<": "parent",
    "~": "sibling",
    "+": "adjacent",
};
var attribSelectors = {
    "#": ["id", "equals"],
    ".": ["class", "element"],
};
// Pseudos, whose data property is parsed as well.
var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "host",
    "host-context",
]);
var traversalNames = new Set(__spreadArray$1([
    "descendant"
], Object.keys(Traversals).map(function (k) { return Traversals[k]; })));
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    return traversalNames.has(selector.type);
}
parse$7.isTraversal = isTraversal;
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes$1 = new Set(['"', "'"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isWhitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$6(selector, options) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "" + selector, options, 0);
    if (endIndex < selector.length) {
        throw new Error("Unmatched selector: " + selector.slice(endIndex));
    }
    return subselects;
}
parse$7.default = parse$6;
function parseSelector(subselects, selector, options, selectorIndex) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var tokens = [];
    var sawWS = false;
    function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error("Expected name, found " + selector.slice(selectorIndex));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        while (isWhitespace(selector.charAt(selectorIndex + offset)))
            offset++;
        selectorIndex += offset;
    }
    function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charAt(--pos) === "\\")
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    stripWhitespace(0);
    while (selector !== "") {
        var firstChar = selector.charAt(selectorIndex);
        if (isWhitespace(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        }
        else if (firstChar in Traversals) {
            ensureNotTraversal();
            tokens.push({ type: Traversals[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === ",") {
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        }
        else if (selector.startsWith("/*", selectorIndex)) {
            var endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
                throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
        }
        else {
            if (sawWS) {
                ensureNotTraversal();
                tokens.push({ type: "descendant" });
                sawWS = false;
            }
            if (firstChar in attribSelectors) {
                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];
                tokens.push({
                    type: "attribute",
                    name: name_1,
                    action: action,
                    value: getName(1),
                    namespace: null,
                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.
                    ignoreCase: options.xmlMode ? null : false,
                });
            }
            else if (firstChar === "[") {
                stripWhitespace(1);
                // Determine attribute name and namespace
                var name_2 = void 0;
                var namespace = null;
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = "";
                    selectorIndex += 1;
                }
                if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    selectorIndex += 2;
                }
                name_2 = getName(0);
                if (namespace === null &&
                    selector.charAt(selectorIndex) === "|" &&
                    selector.charAt(selectorIndex + 1) !== "=") {
                    namespace = name_2;
                    name_2 = getName(1);
                }
                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
                    name_2 = name_2.toLowerCase();
                }
                stripWhitespace(0);
                // Determine comparison operation
                var action = "exists";
                var possibleAction = actionTypes$1.get(selector.charAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charAt(selectorIndex + 1) !== "=") {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charAt(selectorIndex) === "=") {
                    action = "equals";
                    stripWhitespace(1);
                }
                // Determine value
                var value = "";
                var ignoreCase = null;
                if (action !== "exists") {
                    if (quotes$1.has(selector.charAt(selectorIndex))) {
                        var quote = selector.charAt(selectorIndex);
                        var sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        var valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charAt(selectorIndex)) &&
                                selector.charAt(selectorIndex) !== "]") ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    var forceIgnore = selector.charAt(selectorIndex);
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === "s" || forceIgnore === "S") {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === "i" || forceIgnore === "I") {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                // If `xmlMode` is set, there are no rules; otherwise, use the `caseInsensitiveAttributes` list.
                if (!options.xmlMode) {
                    // TODO: Skip this for `exists`, as there is no value to compare to.
                    ignoreCase !== null && ignoreCase !== void 0 ? ignoreCase : (ignoreCase = caseInsensitiveAttributes.has(name_2));
                }
                if (selector.charAt(selectorIndex) !== "]") {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                var attributeSelector = {
                    type: "attribute",
                    name: name_2,
                    action: action,
                    value: value,
                    namespace: namespace,
                    ignoreCase: ignoreCase,
                };
                tokens.push(attributeSelector);
            }
            else if (firstChar === ":") {
                if (selector.charAt(selectorIndex + 1) === ":") {
                    tokens.push({
                        type: "pseudo-element",
                        name: getName(2).toLowerCase(),
                    });
                    continue;
                }
                var name_3 = getName(1).toLowerCase();
                var data = null;
                if (selector.charAt(selectorIndex) === "(") {
                    if (unpackPseudos.has(name_3)) {
                        if (quotes$1.has(selector.charAt(selectorIndex + 1))) {
                            throw new Error("Pseudo-selector " + name_3 + " cannot be quoted");
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);
                        if (selector.charAt(selectorIndex) !== ")") {
                            throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                        }
                        selectorIndex += 1;
                    }
                    else {
                        selectorIndex += 1;
                        var start = selectorIndex;
                        var counter = 1;
                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                            if (selector.charAt(selectorIndex) === "(" &&
                                !isEscaped(selectorIndex)) {
                                counter++;
                            }
                            else if (selector.charAt(selectorIndex) === ")" &&
                                !isEscaped(selectorIndex)) {
                                counter--;
                            }
                        }
                        if (counter) {
                            throw new Error("Parenthesis not matched");
                        }
                        data = selector.slice(start, selectorIndex - 1);
                        if (stripQuotesFromPseudos.has(name_3)) {
                            var quot = data.charAt(0);
                            if (quot === data.slice(-1) && quotes$1.has(quot)) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({ type: "pseudo", name: name_3, data: data });
            }
            else {
                var namespace = null;
                var name_4 = void 0;
                if (firstChar === "*") {
                    selectorIndex += 1;
                    name_4 = "*";
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    if (selector.charAt(selectorIndex) === "|") {
                        namespace = "";
                        selectorIndex += 1;
                    }
                    name_4 = getName(0);
                }
                else {
                    /*
                     * We have finished parsing the selector.
                     * Remove descendant tokens at the end if they exist,
                     * and return the last index, so that parsing can be
                     * picked up from here.
                     */
                    if (tokens.length &&
                        tokens[tokens.length - 1].type === "descendant") {
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selectorIndex;
                }
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = name_4;
                    if (selector.charAt(selectorIndex + 1) === "*") {
                        name_4 = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name_4 = getName(1);
                    }
                }
                if (name_4 === "*") {
                    tokens.push({ type: "universal", namespace: namespace });
                }
                else {
                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
                        name_4 = name_4.toLowerCase();
                    }
                    tokens.push({ type: "tag", name: name_4, namespace: namespace });
                }
            }
        }
    }
    addToken(subselects, tokens);
    return selectorIndex;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
}

var stringify$1 = {};

var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(stringify$1, "__esModule", { value: true });
var actionTypes = {
    equals: "",
    element: "~",
    start: "^",
    end: "$",
    any: "*",
    not: "!",
    hyphen: "|",
};
var charsToEscape = new Set(__spreadArray(__spreadArray([], Object.keys(actionTypes)
    .map(function (typeKey) { return actionTypes[typeKey]; })
    .filter(Boolean)), [
    ":",
    "[",
    "]",
    " ",
    "\\",
    "(",
    ")",
    "'",
]));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector.map(stringifySubselector).join(", ");
}
stringify$1.default = stringify;
function stringifySubselector(token) {
    return token.map(stringifyToken).join("");
}
function stringifyToken(token) {
    switch (token.type) {
        // Simple types
        case "child":
            return " > ";
        case "parent":
            return " < ";
        case "sibling":
            return " ~ ";
        case "adjacent":
            return " + ";
        case "descendant":
            return " ";
        case "universal":
            return getNamespace(token.namespace) + "*";
        case "tag":
            return getNamespacedName(token);
        case "pseudo-element":
            return "::" + escapeName(token.name);
        case "pseudo":
            if (token.data === null)
                return ":" + escapeName(token.name);
            if (typeof token.data === "string") {
                return ":" + escapeName(token.name) + "(" + escapeName(token.data) + ")";
            }
            return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";
        case "attribute": {
            if (token.name === "id" &&
                token.action === "equals" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "#" + escapeName(token.value);
            }
            if (token.name === "class" &&
                token.action === "element" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "." + escapeName(token.value);
            }
            var name_1 = getNamespacedName(token);
            if (token.action === "exists") {
                return "[" + name_1 + "]";
            }
            return "[" + name_1 + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : token.ignoreCase === false ? "s" : "") + "]";
        }
    }
}
function getNamespacedName(token) {
    return "" + getNamespace(token.namespace) + escapeName(token.name);
}
function getNamespace(namespace) {
    return namespace !== null
        ? (namespace === "*" ? "*" : escapeName(namespace)) + "|"
        : "";
}
function escapeName(str) {
    return str
        .split("")
        .map(function (c) { return (charsToEscape.has(c) ? "\\" + c : c); })
        .join("");
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.parse = void 0;
__exportStar(parse$7, exports);
var parse_1 = parse$7;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return __importDefault(parse_1).default; } });
var stringify_1 = stringify$1;
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return __importDefault(stringify_1).default; } });
}(lib$3));

var sort = {};

var procedure = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1,
};
function isTraversal(t) {
    return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;
}(procedure));

Object.defineProperty(sort, "__esModule", { value: true });
var procedure_1$1 = procedure;
var attributes$1 = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
sort.default = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1$1.procedure[token.type];
    if (token.type === "attribute") {
        proc = attributes$1[token.action];
        if (proc === attributes$1.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === "pseudo") {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}

var general = {};

var attributes = {};

Object.defineProperty(attributes, "__esModule", { value: true });
attributes.attributeRules = void 0;
var boolbase_1$2 = boolbase;
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attribute selectors
 */
attributes.attributeRules = {
    equals: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, _a, _b) {
        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;
        var adapter = _b.adapter;
        if (/\s/.test(value)) {
            return boolbase_1$2.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)" + escapeRegex(value) + "(?:$|\\s)", ignoreCase ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};

var pseudoSelectors = {};

var filters$1 = {};

var lib$2 = {};

var parse$5 = {};

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(parse$5, "__esModule", { value: true });
parse$5.parse = void 0;
// [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var RE_NTH_ELEMENT = /^([+-]?\d*n)?\s*(?:([+-]?)\s*(\d+))?$/;
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$4(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    var parsed = formula.match(RE_NTH_ELEMENT);
    if (!parsed) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
    }
    var a;
    if (parsed[1]) {
        a = parseInt(parsed[1], 10);
        if (isNaN(a)) {
            a = parsed[1].startsWith("-") ? -1 : 1;
        }
    }
    else
        a = 0;
    var b = (parsed[2] === "-" ? -1 : 1) *
        (parsed[3] ? parseInt(parsed[3], 10) : 0);
    return [a, b];
}
parse$5.parse = parse$4;

var compile$2 = {};

Object.defineProperty(compile$2, "__esModule", { value: true });
compile$2.compile = void 0;
var boolbase_1$1 = boolbase;
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function compile$1(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1$1.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1$1.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
compile$2.compile = compile$1;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = exports.parse = void 0;
var parse_1 = parse$5;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_1.parse; } });
var compile_1 = compile$2;
Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_1.compile; } });
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of `parse` and `compile`.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
    return compile_1.compile(parse_1.parse(formula));
}
exports.default = nthCheck;
}(lib$2));

(function (exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filters = void 0;
var nth_check_1 = __importDefault(lib$2);
var boolbase_1 = boolbase;
function getChildFunc(next, adapter) {
    return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
    };
}
exports.filters = {
    contains: function (next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
        };
    },
    icontains: function (next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return (next(elem) &&
                adapter.getText(elem).toLowerCase().includes(itext));
        };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
        var adapter = _a.adapter;
        return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
            // Equivalent to :root
            return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
            // NOTE: can't be unpacked, as :has uses this for side-effects
            return function (elem) { return equals(context[0], elem) && next(elem); };
        }
        return function (elem) { return context.includes(elem) && next(elem); };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
            return boolbase_1.falseFunc;
        }
        return function active(elem) {
            return func(elem) && next(elem);
        };
    };
}
}(filters$1));

var pseudos = {};

Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
pseudos.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :" + name + " requires an argument");
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
    }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;

var aliases = {};

Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
aliases.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};

var subselects = {};

(function (exports) {
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = boolbase;
var procedure_1 = procedure;
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
    if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
    return function (elem) { return adapter.isTag(elem) && next(elem); };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
        return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
    var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals,
    };
    var func = compileToken(token, opts, context);
    return function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is and :matches have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` is an alias for `:is`.
     */
    matches: is,
    not: function (next, token, options, context, compileToken) {
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
            return next;
        if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
        return function not(elem) {
            return !func(elem) && next(elem);
        };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: adapter,
            equals: options.equals,
        };
        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
        var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
        })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        if (context) {
            return function (elem) {
                context[0] = elem;
                var childs = adapter.getChildren(elem);
                var nextElements = shouldTestNextSiblings
                    ? __spreadArray(__spreadArray([], childs), getNextSiblings(elem, adapter)) : childs;
                return (next(elem) && adapter.existsOne(hasElement, nextElements));
            };
        }
        return function (elem) {
            return next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
    },
};
}(subselects));

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = boolbase;
var css_what_1 = lib$3;
var filters_1 = filters$1;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
var pseudos_1 = pseudos;
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
var aliases_1 = aliases;
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
var subselects_1 = subselects;
function compilePseudoSelector(next, selector, options, context, compileToken) {
    var name = selector.name, data = selector.data;
    if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
    }
    if (name in aliases_1.aliases) {
        if (data != null) {
            throw new Error("Pseudo " + name + " doesn't have any arguments");
        }
        // The alias has to be parsed here, to make sure options are respected.
        var alias = css_what_1.parse(aliases_1.aliases[name], options);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
    }
    if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        pseudos_1.verifyPseudoArgs(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
                ? function (elem) { return pseudo_1(elem, options, data); }
                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
    }
    throw new Error("unmatched pseudo-class :" + name);
}
exports.compilePseudoSelector = compilePseudoSelector;
}(pseudoSelectors));

Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_1 = attributes;
var pseudo_selectors_1 = pseudoSelectors;
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case "pseudo-element":
            throw new Error("Pseudo-elements are not supported by css-select");
        case "attribute":
            return attributes_1.attributeRules[selector.action](next, selector, options);
        case "pseudo":
            return pseudo_selectors_1.compilePseudoSelector(next, selector, options, context, compileToken);
        // Tags
        case "tag":
            return function tag(elem) {
                return adapter.getName(elem) === selector.name && next(elem);
            };
        // Traversal
        case "descendant":
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            // eslint-disable-next-line no-case-declarations
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        case "_flexibleDescendant":
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        case "parent":
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        case "child":
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        case "sibling":
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        case "adjacent":
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        case "universal":
            return next;
    }
}
general.compileGeneralSelector = compileGeneralSelector;

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(compile$3, "__esModule", { value: true });
compile$3.compileToken = compile$3.compileUnsafe = compile$3.compile = void 0;
var css_what_1 = lib$3;
var boolbase_1 = boolbase;
var sort_1 = __importDefault(sort);
var procedure_1 = procedure;
var general_1 = general;
var subselects_1 = subselects;
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return subselects_1.ensureIsTag(next, options.adapter);
}
compile$3.compile = compile;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? css_what_1.parse(selector, options) : selector;
    return compileToken(token, options, context);
}
compile$3.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = { type: "pseudo", name: "scope", data: null };
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && procedure_1.isTraversal(t[0]) && t[0].type !== "descendant") ;
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") ;
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
compile$3.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : general_1.compileGeneralSelector(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(lib$8);
var boolbase_1 = boolbase;
var compile_1 = compile$3;
var subselects_1 = subselects;
var defaultEquals = function (a, b) { return a === b; };
var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
};
function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts = options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
    return opts;
}
function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
    };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
            query = compile_1.compileUnsafe(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
    };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    for (var i = 0; i < elems.length; i++) {
        var nextSiblings = subselects_1.getNextSiblings(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
    }
    return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : compile_1.compile(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports.default = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = pseudoSelectors;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } });
}(lib$9));

/**
 * @param {any} node
 * @return {node is any}
 */
const isTag = (node) => {
  return node.type === 'element';
};

const existsOne = (test, elems) => {
  return elems.some((elem) => {
    if (isTag(elem)) {
      return test(elem) || existsOne(test, getChildren(elem));
    } else {
      return false;
    }
  });
};

const getAttributeValue = (elem, name) => {
  return elem.attributes[name];
};

const getChildren = (node) => {
  return node.children || [];
};

const getName = (elemAst) => {
  return elemAst.name;
};

const getParent = (node) => {
  return node.parentNode || null;
};

const getSiblings = (elem) => {
  var parent = getParent(elem);
  return parent ? getChildren(parent) : [];
};

const getText = (node) => {
  if (node.children[0].type === 'text' && node.children[0].type === 'cdata') {
    return node.children[0].value;
  }
  return '';
};

const hasAttrib = (elem, name) => {
  return elem.attributes[name] !== undefined;
};

const removeSubsets = (nodes) => {
  let idx = nodes.length;
  let node;
  let ancestor;
  let replace;
  // Check if each node (or one of its ancestors) is already contained in the
  // array.
  while (--idx > -1) {
    node = ancestor = nodes[idx];
    // Temporarily remove the node under consideration
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.includes(ancestor)) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = getParent(ancestor);
    }
    // If the node has been found to be unique, re-insert it.
    if (replace) {
      nodes[idx] = node;
    }
  }
  return nodes;
};

const findAll = (test, elems) => {
  const result = [];
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        result.push(elem);
      }
      result.push(...findAll(test, getChildren(elem)));
    }
  }
  return result;
};

const findOne = (test, elems) => {
  for (const elem of elems) {
    if (isTag(elem)) {
      if (test(elem)) {
        return elem;
      }
      const result = findOne(test, getChildren(elem));
      if (result) {
        return result;
      }
    }
  }
  return null;
};

const svgoCssSelectAdapter$2 = {
  isTag,
  existsOne,
  getAttributeValue,
  getChildren,
  getName,
  getParent,
  getSiblings,
  getText,
  hasAttrib,
  removeSubsets,
  findAll,
  findOne,
};

var cssSelectAdapter = svgoCssSelectAdapter$2;

const { selectAll: selectAll$2, selectOne: selectOne$1, is: is$2 } = lib$9;
const xastAdaptor = cssSelectAdapter;

const cssSelectOptions$1 = {
  xmlMode: true,
  adapter: xastAdaptor,
};

const querySelectorAll$1 = (node, selector) => {
  return selectAll$2(selector, node, cssSelectOptions$1);
};
xast.querySelectorAll = querySelectorAll$1;

const querySelector$1 = (node, selector) => {
  return selectOne$1(selector, node, cssSelectOptions$1);
};
xast.querySelector = querySelector$1;

const matches$1 = (node, selector) => {
  return is$2(node, selector, cssSelectOptions$1);
};
xast.matches = matches$1;

const closestByName$5 = (node, name) => {
  let currentNode = node;
  while (currentNode) {
    if (currentNode.type === 'element' && currentNode.name === name) {
      return currentNode;
    }
    currentNode = currentNode.parentNode;
  }
  return null;
};
xast.closestByName = closestByName$5;

const traverseBreak$1 = Symbol();
xast.traverseBreak = traverseBreak$1;

const traverse$5 = (node, fn) => {
  if (fn(node) === traverseBreak$1) {
    return traverseBreak$1;
  }
  if (node.type === 'root' || node.type === 'element') {
    for (const child of node.children) {
      if (traverse$5(child, fn) === traverseBreak$1) {
        return traverseBreak$1;
      }
    }
  }
};
xast.traverse = traverse$5;

const visit$1 = (node, visitor) => {
  const callbacks = visitor[node.type];
  if (callbacks && callbacks.enter) {
    callbacks.enter(node);
  }
  // visit root children
  if (node.type === 'root') {
    // copy children array to not loose cursor when children is spliced
    for (const child of node.children) {
      visit$1(child, visitor);
    }
  }
  // visit element children if still attached to parent
  if (node.type === 'element') {
    if (node.parentNode.children.includes(node)) {
      for (const child of node.children) {
        visit$1(child, visitor);
      }
    }
  }
  if (callbacks && callbacks.exit) {
    callbacks.exit(node);
  }
};
xast.visit = visit$1;

const detachNodeFromParent$3 = (node) => {
  const parentNode = node.parentNode;
  // avoid splice to not break for loops
  parentNode.children = parentNode.children.filter((child) => child !== node);
};
xast.detachNodeFromParent = detachNodeFromParent$3;

const { closestByName: closestByName$4 } = xast;

addAttributesToSVGElement.type = 'perItem';

addAttributesToSVGElement.active = false;

addAttributesToSVGElement.description = 'adds attributes to an outer <svg> element';

var ENOCLS$1 = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;

/**
 * Add attributes to an outer <svg> element. Example config:
 *
 * @author April Arcus
 */
addAttributesToSVGElement.fn = (node, params) => {
  if (
    node.type === 'element' &&
    node.name === 'svg' &&
    closestByName$4(node.parentNode, 'svg') == null
  ) {
    if (!params || !(Array.isArray(params.attributes) || params.attribute)) {
      console.error(ENOCLS$1);
      return;
    }

    const attributes = params.attributes || [params.attribute];

    for (const attribute of attributes) {
      if (typeof attribute === 'string') {
        if (node.attributes[attribute] == null) {
          node.attributes[attribute] = undefined;
        }
      }
      if (typeof attribute === 'object') {
        for (const key of Object.keys(attribute)) {
          if (node.attributes[key] == null) {
            node.attributes[key] = attribute[key];
          }
        }
      }
    }
  }
};

var addClassesToSVGElement = {};

addClassesToSVGElement.type = 'full';

addClassesToSVGElement.active = false;

addClassesToSVGElement.description = 'adds classnames to an outer <svg> element';

var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins:
- addClassesToSVGElement:
    className: "mySvg"

plugins:
- addClassesToSVGElement:
    classNames: ["mySvg", "size-big"]
`;

/**
 * Add classnames to an outer <svg> element. Example config:
 *
 * plugins:
 * - addClassesToSVGElement:
 *     className: 'mySvg'
 *
 * plugins:
 * - addClassesToSVGElement:
 *     classNames: ['mySvg', 'size-big']
 *
 * @author April Arcus
 */
addClassesToSVGElement.fn = function (data, params) {
  if (
    !params ||
    !(
      (Array.isArray(params.classNames) && params.classNames.some(String)) ||
      params.className
    )
  ) {
    console.error(ENOCLS);
    return data;
  }

  var classNames = params.classNames || [params.className],
    svg = data.children[0];

  if (svg.isElem('svg')) {
    svg.class.add.apply(svg.class, classNames);
  }

  return data;
};

var cleanupAttrs = {};

cleanupAttrs.type = 'perItem';

cleanupAttrs.active = true;

cleanupAttrs.description =
  'cleanups attributes from newlines, trailing and repeating spaces';

cleanupAttrs.params = {
  newlines: true,
  trim: true,
  spaces: true,
};

var regNewlinesNeedSpace = /(\S)\r?\n(\S)/g,
  regNewlines = /\r?\n/g,
  regSpaces = /\s{2,}/g;

/**
 * Cleanup attributes values from newlines, trailing and repeating spaces.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
cleanupAttrs.fn = function (item, params) {
  if (item.type === 'element') {
    for (const name of Object.keys(item.attributes)) {
      if (params.newlines) {
        // new line which requires a space instead of themselve
        item.attributes[name] = item.attributes[name].replace(
          regNewlinesNeedSpace,
          (match, p1, p2) => p1 + ' ' + p2
        );

        // simple new line
        item.attributes[name] = item.attributes[name].replace(regNewlines, '');
      }

      if (params.trim) {
        item.attributes[name] = item.attributes[name].trim();
      }

      if (params.spaces) {
        item.attributes[name] = item.attributes[name].replace(regSpaces, ' ');
      }
    }
  }
};

var cleanupEnableBackground = {};

const { traverse: traverse$4 } = xast;

cleanupEnableBackground.type = 'full';

cleanupEnableBackground.active = true;

cleanupEnableBackground.description =
  'remove or cleanup enable-background attribute when possible';

/**
 * Remove or cleanup enable-background attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/filters.html#EnableBackgroundProperty
 *
 * @example
 * <svg width="100" height="50" enable-background="new 0 0 100 50">
 *             ⬇
 * <svg width="100" height="50">
 *
 * @param {Object} root current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
cleanupEnableBackground.fn = function (root) {
  const regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
  let hasFilter = false;
  const elems = ['svg', 'mask', 'pattern'];

  traverse$4(root, (node) => {
    if (node.type === 'element') {
      if (
        elems.includes(node.name) &&
        node.attributes['enable-background'] != null &&
        node.attributes.width != null &&
        node.attributes.height != null
      ) {
        const match = node.attributes['enable-background'].match(
          regEnableBackground
        );

        if (match) {
          if (
            node.attributes.width === match[1] &&
            node.attributes.height === match[3]
          ) {
            if (node.name === 'svg') {
              delete node.attributes['enable-background'];
            } else {
              node.attributes['enable-background'] = 'new';
            }
          }
        }
      }
      if (node.name === 'filter') {
        hasFilter = true;
      }
    }
  });

  if (hasFilter === false) {
    traverse$4(root, (node) => {
      if (node.type === 'element') {
        //we don't need 'enable-background' if we have no filters
        delete node.attributes['enable-background'];
      }
    });
  }

  return root;
};

var cleanupIDs = {};

var tools = {};

/**
 * Encode plain SVG data string into Data URI string.
 *
 * @param {string} str input string
 * @param {string} type Data URI type
 * @return {string} output string
 */
tools.encodeSVGDatauri = function (str, type) {
  var prefix = 'data:image/svg+xml';
  if (!type || type === 'base64') {
    // base64
    prefix += ';base64,';
    str = prefix + Buffer.from(str).toString('base64');
  } else if (type === 'enc') {
    // URI encoded
    str = prefix + ',' + encodeURIComponent(str);
  } else if (type === 'unenc') {
    // unencoded
    str = prefix + ',' + str;
  }
  return str;
};

/**
 * Decode SVG Data URI string into plain SVG string.
 *
 * @param {string} str input string
 * @return {string} output string
 */
tools.decodeSVGDatauri = function (str) {
  var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
  var match = regexp.exec(str);

  // plain string
  if (!match) return str;

  var data = match[3];

  if (match[2]) {
    // base64
    str = Buffer.from(data, 'base64').toString('utf8');
  } else if (data.charAt(0) === '%') {
    // URI encoded
    str = decodeURIComponent(data);
  } else if (data.charAt(0) === '<') {
    // unencoded
    str = data;
  }
  return str;
};

/**
 * @param {any[]} a
 * @param {any[]} b
 */
tools.intersectArrays = function (a, b) {
  return a.filter(function (n) {
    return b.indexOf(n) > -1;
  });
};

/**
 * Convert a row of numbers to an optimized string view.
 *
 * @example
 * [0, -1, .5, .5] → "0-1 .5.5"
 *
 * @param {number[]} data
 * @param {Object} params
 * @param {string} [command] path data instruction
 * @return {string}
 */
tools.cleanupOutData = function (data, params, command) {
  var str = '',
    delimiter,
    prev;

  data.forEach(function (item, i) {
    // space delimiter by default
    delimiter = ' ';

    // no extra space in front of first number
    if (i == 0) delimiter = '';

    // no extra space after 'arcto' command flags(large-arc and sweep flags)
    // a20 60 45 0 1 30 20 → a20 60 45 0130 20
    if (params.noSpaceAfterFlags && (command == 'A' || command == 'a')) {
      var pos = i % 7;
      if (pos == 4 || pos == 5) delimiter = '';
    }

    // remove floating-point numbers leading zeros
    // 0.5 → .5
    // -0.5 → -.5
    const itemStr = params.leadingZero
      ? removeLeadingZero$3(item)
      : item.toString();

    // no extra space in front of negative number or
    // in front of a floating number if a previous number is floating too
    if (
      params.negativeExtraSpace &&
      delimiter != '' &&
      (item < 0 || (itemStr.charAt(0) === '.' && prev % 1 !== 0))
    ) {
      delimiter = '';
    }
    // save prev item value
    prev = item;
    str += delimiter + itemStr;
  });
  return str;
};

/**
 * Remove floating-point numbers leading zero.
 *
 * @example
 * 0.5 → .5
 *
 * @example
 * -0.5 → -.5
 *
 * @param {number} num input number
 *
 * @return {string} output number as string
 */
var removeLeadingZero$3 = function (num) {
  var strNum = num.toString();

  if (0 < num && num < 1 && strNum.charAt(0) === '0') {
    strNum = strNum.slice(1);
  } else if (-1 < num && num < 0 && strNum.charAt(1) === '0') {
    strNum = strNum.charAt(0) + strNum.slice(2);
  }
  return strNum;
};
tools.removeLeadingZero = removeLeadingZero$3;

const parseName$6 = (name) => {
  if (name == null) {
    return {
      prefix: '',
      local: '',
    };
  }
  if (name === 'xmlns') {
    return {
      prefix: 'xmlns',
      local: '',
    };
  }
  const chunks = name.split(':');
  if (chunks.length === 1) {
    return {
      prefix: '',
      local: chunks[0],
    };
  }
  return {
    prefix: chunks[0],
    local: chunks[1],
  };
};
tools.parseName = parseName$6;

var _collections = {};

(function (exports) {

// https://www.w3.org/TR/SVG11/intro.html#Definitions
exports.elemsGroups = {
  animation: [
    'animate',
    'animateColor',
    'animateMotion',
    'animateTransform',
    'set',
  ],
  descriptive: ['desc', 'metadata', 'title'],
  shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
  structural: ['defs', 'g', 'svg', 'symbol', 'use'],
  paintServer: [
    'solidColor',
    'linearGradient',
    'radialGradient',
    'meshGradient',
    'pattern',
    'hatch',
  ],
  nonRendering: [
    'linearGradient',
    'radialGradient',
    'pattern',
    'clipPath',
    'mask',
    'marker',
    'symbol',
    'filter',
    'solidColor',
  ],
  container: [
    'a',
    'defs',
    'g',
    'marker',
    'mask',
    'missing-glyph',
    'pattern',
    'svg',
    'switch',
    'symbol',
    'foreignObject',
  ],
  textContent: [
    'altGlyph',
    'altGlyphDef',
    'altGlyphItem',
    'glyph',
    'glyphRef',
    'textPath',
    'text',
    'tref',
    'tspan',
  ],
  textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
  lightSource: [
    'feDiffuseLighting',
    'feSpecularLighting',
    'feDistantLight',
    'fePointLight',
    'feSpotLight',
  ],
  filterPrimitive: [
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feFlood',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMorphology',
    'feOffset',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
  ],
};

exports.textElems = exports.elemsGroups.textContent.concat('title');

exports.pathElems = ['path', 'glyph', 'missing-glyph'];

// https://www.w3.org/TR/SVG11/intro.html#Definitions
exports.attrsGroups = {
  animationAddition: ['additive', 'accumulate'],
  animationAttributeTarget: ['attributeType', 'attributeName'],
  animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
  animationTiming: [
    'begin',
    'dur',
    'end',
    'min',
    'max',
    'restart',
    'repeatCount',
    'repeatDur',
    'fill',
  ],
  animationValue: [
    'calcMode',
    'values',
    'keyTimes',
    'keySplines',
    'from',
    'to',
    'by',
  ],
  conditionalProcessing: [
    'requiredFeatures',
    'requiredExtensions',
    'systemLanguage',
  ],
  core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
  graphicalEvent: [
    'onfocusin',
    'onfocusout',
    'onactivate',
    'onclick',
    'onmousedown',
    'onmouseup',
    'onmouseover',
    'onmousemove',
    'onmouseout',
    'onload',
  ],
  presentation: [
    'alignment-baseline',
    'baseline-shift',
    'clip',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cursor',
    'direction',
    'display',
    'dominant-baseline',
    'enable-background',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'image-rendering',
    'letter-spacing',
    'lighting-color',
    'marker-end',
    'marker-mid',
    'marker-start',
    'mask',
    'opacity',
    'overflow',
    'paint-order',
    'pointer-events',
    'shape-rendering',
    'stop-color',
    'stop-opacity',
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'text-anchor',
    'text-decoration',
    'text-overflow',
    'text-rendering',
    'transform',
    'unicode-bidi',
    'vector-effect',
    'visibility',
    'word-spacing',
    'writing-mode',
  ],
  xlink: [
    'xlink:href',
    'xlink:show',
    'xlink:actuate',
    'xlink:type',
    'xlink:role',
    'xlink:arcrole',
    'xlink:title',
  ],
  documentEvent: [
    'onunload',
    'onabort',
    'onerror',
    'onresize',
    'onscroll',
    'onzoom',
  ],
  filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
  transferFunction: [
    'type',
    'tableValues',
    'slope',
    'intercept',
    'amplitude',
    'exponent',
    'offset',
  ],
};

exports.attrsGroupsDefaults = {
  core: { 'xml:space': 'default' },
  presentation: {
    clip: 'auto',
    'clip-path': 'none',
    'clip-rule': 'nonzero',
    mask: 'none',
    opacity: '1',
    'stop-color': '#000',
    'stop-opacity': '1',
    'fill-opacity': '1',
    'fill-rule': 'nonzero',
    fill: '#000',
    stroke: 'none',
    'stroke-width': '1',
    'stroke-linecap': 'butt',
    'stroke-linejoin': 'miter',
    'stroke-miterlimit': '4',
    'stroke-dasharray': 'none',
    'stroke-dashoffset': '0',
    'stroke-opacity': '1',
    'paint-order': 'normal',
    'vector-effect': 'none',
    display: 'inline',
    visibility: 'visible',
    'marker-start': 'none',
    'marker-mid': 'none',
    'marker-end': 'none',
    'color-interpolation': 'sRGB',
    'color-interpolation-filters': 'linearRGB',
    'color-rendering': 'auto',
    'shape-rendering': 'auto',
    'text-rendering': 'auto',
    'image-rendering': 'auto',
    'font-style': 'normal',
    'font-variant': 'normal',
    'font-weight': 'normal',
    'font-stretch': 'normal',
    'font-size': 'medium',
    'font-size-adjust': 'none',
    kerning: 'auto',
    'letter-spacing': 'normal',
    'word-spacing': 'normal',
    'text-decoration': 'none',
    'text-anchor': 'start',
    'text-overflow': 'clip',
    'writing-mode': 'lr-tb',
    'glyph-orientation-vertical': 'auto',
    'glyph-orientation-horizontal': '0deg',
    direction: 'ltr',
    'unicode-bidi': 'normal',
    'dominant-baseline': 'auto',
    'alignment-baseline': 'baseline',
    'baseline-shift': 'baseline',
  },
  transferFunction: {
    slope: '1',
    intercept: '0',
    amplitude: '1',
    exponent: '1',
    offset: '0',
  },
};

// https://www.w3.org/TR/SVG11/eltindex.html
exports.elems = {
  a: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
      'xlink',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'target',
    ],
    defaults: {
      target: '_self',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
      // not spec compliant
      'tspan',
    ],
  },
  altGlyph: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
      'xlink',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'x',
      'y',
      'dx',
      'dy',
      'glyphRef',
      'format',
      'rotate',
    ],
  },
  altGlyphDef: {
    attrsGroups: ['core'],
    content: ['glyphRef'],
  },
  altGlyphItem: {
    attrsGroups: ['core'],
    content: ['glyphRef', 'altGlyphItem'],
  },
  animate: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'animationAddition',
      'animationAttributeTarget',
      'animationEvent',
      'animationTiming',
      'animationValue',
      'presentation',
      'xlink',
    ],
    attrs: ['externalResourcesRequired'],
    contentGroups: ['descriptive'],
  },
  animateColor: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'animationEvent',
      'xlink',
      'animationAttributeTarget',
      'animationTiming',
      'animationValue',
      'animationAddition',
      'presentation',
    ],
    attrs: ['externalResourcesRequired'],
    contentGroups: ['descriptive'],
  },
  animateMotion: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'animationEvent',
      'xlink',
      'animationTiming',
      'animationValue',
      'animationAddition',
    ],
    attrs: [
      'externalResourcesRequired',
      'path',
      'keyPoints',
      'rotate',
      'origin',
    ],
    defaults: {
      rotate: '0',
    },
    contentGroups: ['descriptive'],
    content: ['mpath'],
  },
  animateTransform: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'animationEvent',
      'xlink',
      'animationAttributeTarget',
      'animationTiming',
      'animationValue',
      'animationAddition',
    ],
    attrs: ['externalResourcesRequired', 'type'],
    contentGroups: ['descriptive'],
  },
  circle: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'cx',
      'cy',
      'r',
    ],
    defaults: {
      cx: '0',
      cy: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  clipPath: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'clipPathUnits',
    ],
    defaults: {
      clipPathUnits: 'userSpaceOnUse',
    },
    contentGroups: ['animation', 'descriptive', 'shape'],
    content: ['text', 'use'],
  },
  'color-profile': {
    attrsGroups: ['core', 'xlink'],
    attrs: ['local', 'name', 'rendering-intent'],
    defaults: {
      name: 'sRGB',
      'rendering-intent': 'auto',
    },
    contentGroups: ['descriptive'],
  },
  cursor: {
    attrsGroups: ['core', 'conditionalProcessing', 'xlink'],
    attrs: ['externalResourcesRequired', 'x', 'y'],
    defaults: {
      x: '0',
      y: '0',
    },
    contentGroups: ['descriptive'],
  },
  defs: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  desc: {
    attrsGroups: ['core'],
    attrs: ['class', 'style'],
  },
  ellipse: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'cx',
      'cy',
      'rx',
      'ry',
    ],
    defaults: {
      cx: '0',
      cy: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  feBlend: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      // TODO: in - 'If no value is provided and this is the first filter primitive,
      // then this filter primitive will use SourceGraphic as its input'
      'in',
      'in2',
      'mode',
    ],
    defaults: {
      mode: 'normal',
    },
    content: ['animate', 'set'],
  },
  feColorMatrix: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'type', 'values'],
    defaults: {
      type: 'matrix',
    },
    content: ['animate', 'set'],
  },
  feComponentTransfer: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in'],
    content: ['feFuncA', 'feFuncB', 'feFuncG', 'feFuncR'],
  },
  feComposite: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'in2', 'operator', 'k1', 'k2', 'k3', 'k4'],
    defaults: {
      operator: 'over',
      k1: '0',
      k2: '0',
      k3: '0',
      k4: '0',
    },
    content: ['animate', 'set'],
  },
  feConvolveMatrix: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      'in',
      'order',
      'kernelMatrix',
      // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
      // with the exception that if the sum is zero, then the divisor is set to 1'
      'divisor',
      'bias',
      // TODO: targetX - 'By default, the convolution matrix is centered in X over each
      // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
      'targetX',
      'targetY',
      'edgeMode',
      // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
      // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
      'kernelUnitLength',
      'preserveAlpha',
    ],
    defaults: {
      order: '3',
      bias: '0',
      edgeMode: 'duplicate',
      preserveAlpha: 'false',
    },
    content: ['animate', 'set'],
  },
  feDiffuseLighting: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      'in',
      'surfaceScale',
      'diffuseConstant',
      'kernelUnitLength',
    ],
    defaults: {
      surfaceScale: '1',
      diffuseConstant: '1',
    },
    contentGroups: ['descriptive'],
    content: [
      // TODO: 'exactly one light source element, in any order'
      'feDistantLight',
      'fePointLight',
      'feSpotLight',
    ],
  },
  feDisplacementMap: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      'in',
      'in2',
      'scale',
      'xChannelSelector',
      'yChannelSelector',
    ],
    defaults: {
      scale: '0',
      xChannelSelector: 'A',
      yChannelSelector: 'A',
    },
    content: ['animate', 'set'],
  },
  feDistantLight: {
    attrsGroups: ['core'],
    attrs: ['azimuth', 'elevation'],
    defaults: {
      azimuth: '0',
      elevation: '0',
    },
    content: ['animate', 'set'],
  },
  feFlood: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style'],
    content: ['animate', 'animateColor', 'set'],
  },
  feFuncA: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate'],
  },
  feFuncB: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate'],
  },
  feFuncG: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate'],
  },
  feFuncR: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate'],
  },
  feGaussianBlur: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'stdDeviation'],
    defaults: {
      stdDeviation: '0',
    },
    content: ['set', 'animate'],
  },
  feImage: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive', 'xlink'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'preserveAspectRatio',
      'href',
      'xlink:href',
    ],
    defaults: {
      preserveAspectRatio: 'xMidYMid meet',
    },
    content: ['animate', 'animateTransform', 'set'],
  },
  feMerge: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style'],
    content: ['feMergeNode'],
  },
  feMergeNode: {
    attrsGroups: ['core'],
    attrs: ['in'],
    content: ['animate', 'set'],
  },
  feMorphology: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'operator', 'radius'],
    defaults: {
      operator: 'erode',
      radius: '0',
    },
    content: ['animate', 'set'],
  },
  feOffset: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'dx', 'dy'],
    defaults: {
      dx: '0',
      dy: '0',
    },
    content: ['animate', 'set'],
  },
  fePointLight: {
    attrsGroups: ['core'],
    attrs: ['x', 'y', 'z'],
    defaults: {
      x: '0',
      y: '0',
      z: '0',
    },
    content: ['animate', 'set'],
  },
  feSpecularLighting: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      'in',
      'surfaceScale',
      'specularConstant',
      'specularExponent',
      'kernelUnitLength',
    ],
    defaults: {
      surfaceScale: '1',
      specularConstant: '1',
      specularExponent: '1',
    },
    contentGroups: [
      'descriptive',
      // TODO: exactly one 'light source element'
      'lightSource',
    ],
  },
  feSpotLight: {
    attrsGroups: ['core'],
    attrs: [
      'x',
      'y',
      'z',
      'pointsAtX',
      'pointsAtY',
      'pointsAtZ',
      'specularExponent',
      'limitingConeAngle',
    ],
    defaults: {
      x: '0',
      y: '0',
      z: '0',
      pointsAtX: '0',
      pointsAtY: '0',
      pointsAtZ: '0',
      specularExponent: '1',
    },
    content: ['animate', 'set'],
  },
  feTile: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in'],
    content: ['animate', 'set'],
  },
  feTurbulence: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: [
      'class',
      'style',
      'baseFrequency',
      'numOctaves',
      'seed',
      'stitchTiles',
      'type',
    ],
    defaults: {
      baseFrequency: '0',
      numOctaves: '1',
      seed: '0',
      stitchTiles: 'noStitch',
      type: 'turbulence',
    },
    content: ['animate', 'set'],
  },
  filter: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'x',
      'y',
      'width',
      'height',
      'filterRes',
      'filterUnits',
      'primitiveUnits',
      'href',
      'xlink:href',
    ],
    defaults: {
      primitiveUnits: 'userSpaceOnUse',
      x: '-10%',
      y: '-10%',
      width: '120%',
      height: '120%',
    },
    contentGroups: ['descriptive', 'filterPrimitive'],
    content: ['animate', 'set'],
  },
  font: {
    attrsGroups: ['core', 'presentation'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'horiz-origin-x',
      'horiz-origin-y',
      'horiz-adv-x',
      'vert-origin-x',
      'vert-origin-y',
      'vert-adv-y',
    ],
    defaults: {
      'horiz-origin-x': '0',
      'horiz-origin-y': '0',
    },
    contentGroups: ['descriptive'],
    content: ['font-face', 'glyph', 'hkern', 'missing-glyph', 'vkern'],
  },
  'font-face': {
    attrsGroups: ['core'],
    attrs: [
      'font-family',
      'font-style',
      'font-variant',
      'font-weight',
      'font-stretch',
      'font-size',
      'unicode-range',
      'units-per-em',
      'panose-1',
      'stemv',
      'stemh',
      'slope',
      'cap-height',
      'x-height',
      'accent-height',
      'ascent',
      'descent',
      'widths',
      'bbox',
      'ideographic',
      'alphabetic',
      'mathematical',
      'hanging',
      'v-ideographic',
      'v-alphabetic',
      'v-mathematical',
      'v-hanging',
      'underline-position',
      'underline-thickness',
      'strikethrough-position',
      'strikethrough-thickness',
      'overline-position',
      'overline-thickness',
    ],
    defaults: {
      'font-style': 'all',
      'font-variant': 'normal',
      'font-weight': 'all',
      'font-stretch': 'normal',
      'unicode-range': 'U+0-10FFFF',
      'units-per-em': '1000',
      'panose-1': '0 0 0 0 0 0 0 0 0 0',
      slope: '0',
    },
    contentGroups: ['descriptive'],
    content: [
      // TODO: "at most one 'font-face-src' element"
      'font-face-src',
    ],
  },
  // TODO: empty content
  'font-face-format': {
    attrsGroups: ['core'],
    attrs: ['string'],
  },
  'font-face-name': {
    attrsGroups: ['core'],
    attrs: ['name'],
  },
  'font-face-src': {
    attrsGroups: ['core'],
    content: ['font-face-name', 'font-face-uri'],
  },
  'font-face-uri': {
    attrsGroups: ['core', 'xlink'],
    attrs: ['href', 'xlink:href'],
    content: ['font-face-format'],
  },
  foreignObject: {
    attrsGroups: [
      'core',
      'conditionalProcessing',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'x',
      'y',
      'width',
      'height',
    ],
    defaults: {
      x: 0,
      y: 0,
    },
  },
  g: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  glyph: {
    attrsGroups: ['core', 'presentation'],
    attrs: [
      'class',
      'style',
      'd',
      'horiz-adv-x',
      'vert-origin-x',
      'vert-origin-y',
      'vert-adv-y',
      'unicode',
      'glyph-name',
      'orientation',
      'arabic-form',
      'lang',
    ],
    defaults: {
      'arabic-form': 'initial',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  glyphRef: {
    attrsGroups: ['core', 'presentation'],
    attrs: [
      'class',
      'style',
      'd',
      'horiz-adv-x',
      'vert-origin-x',
      'vert-origin-y',
      'vert-adv-y',
    ],
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  hatch: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: [
      'class',
      'style',
      'x',
      'y',
      'pitch',
      'rotate',
      'hatchUnits',
      'hatchContentUnits',
      'transform',
    ],
    defaults: {
      hatchUnits: 'objectBoundingBox',
      hatchContentUnits: 'userSpaceOnUse',
      x: '0',
      y: '0',
      pitch: '0',
      rotate: '0',
    },
    contentGroups: ['animation', 'descriptive'],
    content: ['hatchPath'],
  },
  hatchPath: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'd', 'offset'],
    defaults: {
      offset: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  hkern: {
    attrsGroups: ['core'],
    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
  },
  image: {
    attrsGroups: [
      'core',
      'conditionalProcessing',
      'graphicalEvent',
      'xlink',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'preserveAspectRatio',
      'transform',
      'x',
      'y',
      'width',
      'height',
      'href',
      'xlink:href',
    ],
    defaults: {
      x: '0',
      y: '0',
      preserveAspectRatio: 'xMidYMid meet',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  line: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'x1',
      'y1',
      'x2',
      'y2',
    ],
    defaults: {
      x1: '0',
      y1: '0',
      x2: '0',
      y2: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  linearGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'x1',
      'y1',
      'x2',
      'y2',
      'gradientUnits',
      'gradientTransform',
      'spreadMethod',
      'href',
      'xlink:href',
    ],
    defaults: {
      x1: '0',
      y1: '0',
      x2: '100%',
      y2: '0',
      spreadMethod: 'pad',
    },
    contentGroups: ['descriptive'],
    content: ['animate', 'animateTransform', 'set', 'stop'],
  },
  marker: {
    attrsGroups: ['core', 'presentation'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'viewBox',
      'preserveAspectRatio',
      'refX',
      'refY',
      'markerUnits',
      'markerWidth',
      'markerHeight',
      'orient',
    ],
    defaults: {
      markerUnits: 'strokeWidth',
      refX: '0',
      refY: '0',
      markerWidth: '3',
      markerHeight: '3',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  mask: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'x',
      'y',
      'width',
      'height',
      'mask-type',
      'maskUnits',
      'maskContentUnits',
    ],
    defaults: {
      maskUnits: 'objectBoundingBox',
      maskContentUnits: 'userSpaceOnUse',
      x: '-10%',
      y: '-10%',
      width: '120%',
      height: '120%',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  metadata: {
    attrsGroups: ['core'],
  },
  'missing-glyph': {
    attrsGroups: ['core', 'presentation'],
    attrs: [
      'class',
      'style',
      'd',
      'horiz-adv-x',
      'vert-origin-x',
      'vert-origin-y',
      'vert-adv-y',
    ],
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  mpath: {
    attrsGroups: ['core', 'xlink'],
    attrs: ['externalResourcesRequired', 'href', 'xlink:href'],
    contentGroups: ['descriptive'],
  },
  path: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'd',
      'pathLength',
    ],
    contentGroups: ['animation', 'descriptive'],
  },
  pattern: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation', 'xlink'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'viewBox',
      'preserveAspectRatio',
      'x',
      'y',
      'width',
      'height',
      'patternUnits',
      'patternContentUnits',
      'patternTransform',
      'href',
      'xlink:href',
    ],
    defaults: {
      patternUnits: 'objectBoundingBox',
      patternContentUnits: 'userSpaceOnUse',
      x: '0',
      y: '0',
      width: '0',
      height: '0',
      preserveAspectRatio: 'xMidYMid meet',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'paintServer',
      'shape',
      'structural',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  polygon: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'points',
    ],
    contentGroups: ['animation', 'descriptive'],
  },
  polyline: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'points',
    ],
    contentGroups: ['animation', 'descriptive'],
  },
  radialGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'cx',
      'cy',
      'r',
      'fx',
      'fy',
      'fr',
      'gradientUnits',
      'gradientTransform',
      'spreadMethod',
      'href',
      'xlink:href',
    ],
    defaults: {
      gradientUnits: 'objectBoundingBox',
      cx: '50%',
      cy: '50%',
      r: '50%',
    },
    contentGroups: ['descriptive'],
    content: ['animate', 'animateTransform', 'set', 'stop'],
  },
  meshGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'x', 'y', 'gradientUnits', 'transform'],
    contentGroups: ['descriptive', 'paintServer', 'animation'],
    content: ['meshRow'],
  },
  meshRow: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['descriptive'],
    content: ['meshPatch'],
  },
  meshPatch: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['descriptive'],
    content: ['stop'],
  },
  rect: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'x',
      'y',
      'width',
      'height',
      'rx',
      'ry',
    ],
    defaults: {
      x: '0',
      y: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  script: {
    attrsGroups: ['core', 'xlink'],
    attrs: ['externalResourcesRequired', 'type', 'href', 'xlink:href'],
  },
  set: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'animation',
      'xlink',
      'animationAttributeTarget',
      'animationTiming',
    ],
    attrs: ['externalResourcesRequired', 'to'],
    contentGroups: ['descriptive'],
  },
  solidColor: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['paintServer'],
  },
  stop: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'offset', 'path'],
    content: ['animate', 'animateColor', 'set'],
  },
  style: {
    attrsGroups: ['core'],
    attrs: ['type', 'media', 'title'],
    defaults: {
      type: 'text/css',
    },
  },
  svg: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'documentEvent',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'x',
      'y',
      'width',
      'height',
      'viewBox',
      'preserveAspectRatio',
      'zoomAndPan',
      'version',
      'baseProfile',
      'contentScriptType',
      'contentStyleType',
    ],
    defaults: {
      x: '0',
      y: '0',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid meet',
      zoomAndPan: 'magnify',
      version: '1.1',
      baseProfile: 'none',
      contentScriptType: 'application/ecmascript',
      contentStyleType: 'text/css',
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  switch: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: ['animation', 'descriptive', 'shape'],
    content: [
      'a',
      'foreignObject',
      'g',
      'image',
      'svg',
      'switch',
      'text',
      'use',
    ],
  },
  symbol: {
    attrsGroups: ['core', 'graphicalEvent', 'presentation'],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'preserveAspectRatio',
      'viewBox',
      'refX',
      'refY',
    ],
    defaults: {
      refX: 0,
      refY: 0,
    },
    contentGroups: [
      'animation',
      'descriptive',
      'shape',
      'structural',
      'paintServer',
    ],
    content: [
      'a',
      'altGlyphDef',
      'clipPath',
      'color-profile',
      'cursor',
      'filter',
      'font',
      'font-face',
      'foreignObject',
      'image',
      'marker',
      'mask',
      'pattern',
      'script',
      'style',
      'switch',
      'text',
      'view',
    ],
  },
  text: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'lengthAdjust',
      'x',
      'y',
      'dx',
      'dy',
      'rotate',
      'textLength',
    ],
    defaults: {
      x: '0',
      y: '0',
      lengthAdjust: 'spacing',
    },
    contentGroups: ['animation', 'descriptive', 'textContentChild'],
    content: ['a'],
  },
  textPath: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
      'xlink',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'href',
      'xlink:href',
      'startOffset',
      'method',
      'spacing',
      'd',
    ],
    defaults: {
      startOffset: '0',
      method: 'align',
      spacing: 'exact',
    },
    contentGroups: ['descriptive'],
    content: [
      'a',
      'altGlyph',
      'animate',
      'animateColor',
      'set',
      'tref',
      'tspan',
    ],
  },
  title: {
    attrsGroups: ['core'],
    attrs: ['class', 'style'],
  },
  tref: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
      'xlink',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'href',
      'xlink:href',
    ],
    contentGroups: ['descriptive'],
    content: ['animate', 'animateColor', 'set'],
  },
  tspan: {
    attrsGroups: [
      'conditionalProcessing',
      'core',
      'graphicalEvent',
      'presentation',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'x',
      'y',
      'dx',
      'dy',
      'rotate',
      'textLength',
      'lengthAdjust',
    ],
    contentGroups: ['descriptive'],
    content: [
      'a',
      'altGlyph',
      'animate',
      'animateColor',
      'set',
      'tref',
      'tspan',
    ],
  },
  use: {
    attrsGroups: [
      'core',
      'conditionalProcessing',
      'graphicalEvent',
      'presentation',
      'xlink',
    ],
    attrs: [
      'class',
      'style',
      'externalResourcesRequired',
      'transform',
      'x',
      'y',
      'width',
      'height',
      'href',
      'xlink:href',
    ],
    defaults: {
      x: '0',
      y: '0',
    },
    contentGroups: ['animation', 'descriptive'],
  },
  view: {
    attrsGroups: ['core'],
    attrs: [
      'externalResourcesRequired',
      'viewBox',
      'preserveAspectRatio',
      'zoomAndPan',
      'viewTarget',
    ],
    contentGroups: ['descriptive'],
  },
  vkern: {
    attrsGroups: ['core'],
    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
  },
};

// https://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
exports.editorNamespaces = [
  'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
  'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd',
  'http://www.inkscape.org/namespaces/inkscape',
  'http://www.bohemiancoding.com/sketch/ns',
  'http://ns.adobe.com/AdobeIllustrator/10.0/',
  'http://ns.adobe.com/Graphs/1.0/',
  'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/',
  'http://ns.adobe.com/Variables/1.0/',
  'http://ns.adobe.com/SaveForWeb/1.0/',
  'http://ns.adobe.com/Extensibility/1.0/',
  'http://ns.adobe.com/Flows/1.0/',
  'http://ns.adobe.com/ImageReplacement/1.0/',
  'http://ns.adobe.com/GenericCustomNamespace/1.0/',
  'http://ns.adobe.com/XPath/1.0/',
  'http://schemas.microsoft.com/visio/2003/SVGExtensions/',
  'http://taptrix.com/vectorillustrator/svg_extensions',
  'http://www.figma.com/figma/ns',
  'http://purl.org/dc/elements/1.1/',
  'http://creativecommons.org/ns#',
  'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  'http://www.serif.com/',
  'http://www.vector.evaxdesign.sk',
];

// https://www.w3.org/TR/SVG11/linking.html#processingIRI
exports.referencesProps = [
  'clip-path',
  'color-profile',
  'fill',
  'filter',
  'marker-start',
  'marker-mid',
  'marker-end',
  'mask',
  'stroke',
  'style',
];

// https://www.w3.org/TR/SVG11/propidx.html
exports.inheritableAttrs = [
  'clip-rule',
  'color',
  'color-interpolation',
  'color-interpolation-filters',
  'color-profile',
  'color-rendering',
  'cursor',
  'direction',
  'dominant-baseline',
  'fill',
  'fill-opacity',
  'fill-rule',
  'font',
  'font-family',
  'font-size',
  'font-size-adjust',
  'font-stretch',
  'font-style',
  'font-variant',
  'font-weight',
  'glyph-orientation-horizontal',
  'glyph-orientation-vertical',
  'image-rendering',
  'letter-spacing',
  'marker',
  'marker-end',
  'marker-mid',
  'marker-start',
  'paint-order',
  'pointer-events',
  'shape-rendering',
  'stroke',
  'stroke-dasharray',
  'stroke-dashoffset',
  'stroke-linecap',
  'stroke-linejoin',
  'stroke-miterlimit',
  'stroke-opacity',
  'stroke-width',
  'text-anchor',
  'text-rendering',
  'transform',
  'visibility',
  'word-spacing',
  'writing-mode',
];

exports.presentationNonInheritableGroupAttrs = [
  'display',
  'clip-path',
  'filter',
  'mask',
  'opacity',
  'text-decoration',
  'transform',
  'unicode-bidi',
  'visibility',
];

// https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
exports.colorsNames = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#0ff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000',
  blanchedalmond: '#ffebcd',
  blue: '#00f',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#0ff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#f0f',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#789',
  lightslategrey: '#789',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#0f0',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#f0f',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#639',
  red: '#f00',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#fff',
  whitesmoke: '#f5f5f5',
  yellow: '#ff0',
  yellowgreen: '#9acd32',
};

exports.colorsShortNames = {
  '#f0ffff': 'azure',
  '#f5f5dc': 'beige',
  '#ffe4c4': 'bisque',
  '#a52a2a': 'brown',
  '#ff7f50': 'coral',
  '#ffd700': 'gold',
  '#808080': 'gray',
  '#008000': 'green',
  '#4b0082': 'indigo',
  '#fffff0': 'ivory',
  '#f0e68c': 'khaki',
  '#faf0e6': 'linen',
  '#800000': 'maroon',
  '#000080': 'navy',
  '#808000': 'olive',
  '#ffa500': 'orange',
  '#da70d6': 'orchid',
  '#cd853f': 'peru',
  '#ffc0cb': 'pink',
  '#dda0dd': 'plum',
  '#800080': 'purple',
  '#f00': 'red',
  '#ff0000': 'red',
  '#fa8072': 'salmon',
  '#a0522d': 'sienna',
  '#c0c0c0': 'silver',
  '#fffafa': 'snow',
  '#d2b48c': 'tan',
  '#008080': 'teal',
  '#ff6347': 'tomato',
  '#ee82ee': 'violet',
  '#f5deb3': 'wheat',
};

// https://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor
exports.colorsProps = [
  'color',
  'fill',
  'stroke',
  'stop-color',
  'flood-color',
  'lighting-color',
];
}(_collections));

const { traverse: traverse$3, traverseBreak } = xast;
const { parseName: parseName$5 } = tools;

cleanupIDs.type = 'full';

cleanupIDs.active = true;

cleanupIDs.description = 'removes unused IDs and minifies used';

cleanupIDs.params = {
  remove: true,
  minify: true,
  prefix: '',
  preserve: [],
  preservePrefixes: [],
  force: false,
};

var referencesProps$3 = new Set(_collections.referencesProps),
  regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/,
  regReferencesHref = /^#(.+?)$/,
  regReferencesBegin = /(\w+)\./,
  styleOrScript$1 = ['style', 'script'],
  generateIDchars = [
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
  ],
  maxIDindex = generateIDchars.length - 1;

/**
 * Remove unused and minify used IDs
 * (only if there are no any <style> or <script>).
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 *
 * @author Kir Belevich
 */
cleanupIDs.fn = function (root, params) {
  var currentID,
    currentIDstring,
    IDs = new Map(),
    referencesIDs = new Map(),
    hasStyleOrScript = false,
    preserveIDs = new Set(
      Array.isArray(params.preserve)
        ? params.preserve
        : params.preserve
        ? [params.preserve]
        : []
    ),
    preserveIDPrefixes = new Set(
      Array.isArray(params.preservePrefixes)
        ? params.preservePrefixes
        : params.preservePrefixes
        ? [params.preservePrefixes]
        : []
    ),
    idValuePrefix = '#',
    idValuePostfix = '.';

  traverse$3(root, (node) => {
    if (hasStyleOrScript === true) {
      return traverseBreak;
    }

    // quit if <style> or <script> present ('force' param prevents quitting)
    if (!params.force) {
      if (node.isElem(styleOrScript$1) && node.children.length !== 0) {
        hasStyleOrScript = true;
        return;
      }

      // Don't remove IDs if the whole SVG consists only of defs.
      if (node.type === 'element' && node.name === 'svg') {
        let hasDefsOnly = true;
        for (const child of node.children) {
          if (child.type !== 'element' || child.name !== 'defs') {
            hasDefsOnly = false;
            break;
          }
        }
        if (hasDefsOnly) {
          return traverseBreak;
        }
      }
    }

    // …and don't remove any ID if yes
    if (node.type === 'element') {
      for (const [name, value] of Object.entries(node.attributes)) {
        let key;
        let match;

        // save IDs
        if (name === 'id') {
          key = value;
          if (IDs.has(key)) {
            delete node.attributes.id; // remove repeated id
          } else {
            IDs.set(key, node);
          }
        } else {
          // save references
          const { local } = parseName$5(name);
          if (
            referencesProps$3.has(name) &&
            (match = value.match(regReferencesUrl))
          ) {
            key = match[2]; // url() reference
          } else if (
            (local === 'href' && (match = value.match(regReferencesHref))) ||
            (name === 'begin' && (match = value.match(regReferencesBegin)))
          ) {
            key = match[1]; // href reference
          }
          if (key) {
            const refs = referencesIDs.get(key) || [];
            refs.push({ element: node, name, value });
            referencesIDs.set(key, refs);
          }
        }
      }
    }
  });

  if (hasStyleOrScript) {
    return root;
  }

  const idPreserved = (id) =>
    preserveIDs.has(id) || idMatchesPrefix(preserveIDPrefixes, id);

  for (const [key, refs] of referencesIDs) {
    if (IDs.has(key)) {
      // replace referenced IDs with the minified ones
      if (params.minify && !idPreserved(key)) {
        do {
          currentIDstring = getIDstring(
            (currentID = generateID(currentID)),
            params
          );
        } while (idPreserved(currentIDstring));

        IDs.get(key).attributes.id = currentIDstring;

        for (const { element, name, value } of refs) {
          element.attributes[name] = value.includes(idValuePrefix)
            ? value.replace(
                idValuePrefix + key,
                idValuePrefix + currentIDstring
              )
            : value.replace(
                key + idValuePostfix,
                currentIDstring + idValuePostfix
              );
        }
      }
      // don't remove referenced IDs
      IDs.delete(key);
    }
  }
  // remove non-referenced IDs attributes from elements
  if (params.remove) {
    for (var keyElem of IDs) {
      if (!idPreserved(keyElem[0])) {
        delete keyElem[1].attributes.id;
      }
    }
  }
  return root;
};

/**
 * Check if an ID starts with any one of a list of strings.
 *
 * @param {Array} of prefix strings
 * @param {String} current ID
 * @return {Boolean} if currentID starts with one of the strings in prefixArray
 */
function idMatchesPrefix(prefixArray, currentID) {
  if (!currentID) return false;

  for (var prefix of prefixArray) if (currentID.startsWith(prefix)) return true;
  return false;
}

/**
 * Generate unique minimal ID.
 *
 * @param {Array} [currentID] current ID
 * @return {Array} generated ID array
 */
function generateID(currentID) {
  if (!currentID) return [0];

  currentID[currentID.length - 1]++;

  for (var i = currentID.length - 1; i > 0; i--) {
    if (currentID[i] > maxIDindex) {
      currentID[i] = 0;

      if (currentID[i - 1] !== undefined) {
        currentID[i - 1]++;
      }
    }
  }
  if (currentID[0] > maxIDindex) {
    currentID[0] = 0;
    currentID.unshift(0);
  }
  return currentID;
}

/**
 * Get string from generated ID array.
 *
 * @param {Array} arr input ID array
 * @return {String} output ID string
 */
function getIDstring(arr, params) {
  var str = params.prefix;
  return str + arr.map((i) => generateIDchars[i]).join('');
}

var cleanupListOfValues = {};

const { removeLeadingZero: removeLeadingZero$2 } = tools;

cleanupListOfValues.type = 'perItem';

cleanupListOfValues.active = false;

cleanupListOfValues.description = 'rounds list of values to the fixed precision';

cleanupListOfValues.params = {
  floatPrecision: 3,
  leadingZero: true,
  defaultPx: true,
  convertToPx: true,
};

const regNumericValues$3 = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
const regSeparator = /\s+,?\s*|,\s*/;
const absoluteLengths$1 = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
};

/**
 * Round list of values to the fixed precision.
 *
 * @example
 * <svg viewBox="0 0 200.28423 200.28423" enable-background="new 0 0 200.28423 200.28423">
 *         ⬇
 * <svg viewBox="0 0 200.284 200.284" enable-background="new 0 0 200.284 200.284">
 *
 *
 * <polygon points="208.250977 77.1308594 223.069336 ... "/>
 *         ⬇
 * <polygon points="208.251 77.131 223.069 ... "/>
 *
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author kiyopikko
 */
cleanupListOfValues.fn = function (item, params) {
  if (item.type !== 'element') {
    return;
  }

  if (item.attributes.points != null) {
    item.attributes.points = roundValues(item.attributes.points);
  }

  if (item.attributes['enable-background'] != null) {
    item.attributes['enable-background'] = roundValues(
      item.attributes['enable-background']
    );
  }

  if (item.attributes.viewBox != null) {
    item.attributes.viewBox = roundValues(item.attributes.viewBox);
  }

  if (item.attributes['stroke-dasharray'] != null) {
    item.attributes['stroke-dasharray'] = roundValues(
      item.attributes['stroke-dasharray']
    );
  }

  if (item.attributes.dx != null) {
    item.attributes.dx = roundValues(item.attributes.dx);
  }

  if (item.attributes.dy != null) {
    item.attributes.dy = roundValues(item.attributes.dy);
  }

  if (item.attributes.x != null) {
    item.attributes.x = roundValues(item.attributes.x);
  }

  if (item.attributes.y != null) {
    item.attributes.y = roundValues(item.attributes.y);
  }

  function roundValues(lists) {
    var num,
      units,
      match,
      matchNew,
      listsArr = lists.split(regSeparator),
      roundedList = [];

    for (const elem of listsArr) {
      match = elem.match(regNumericValues$3);
      matchNew = elem.match(/new/);

      // if attribute value matches regNumericValues
      if (match) {
        // round it to the fixed precision
        (num = +(+match[1]).toFixed(params.floatPrecision)),
          (units = match[3] || '');

        // convert absolute values to pixels
        if (params.convertToPx && units && units in absoluteLengths$1) {
          var pxNum = +(absoluteLengths$1[units] * match[1]).toFixed(
            params.floatPrecision
          );

          if (String(pxNum).length < match[0].length)
            (num = pxNum), (units = 'px');
        }

        // and remove leading zero
        if (params.leadingZero) {
          num = removeLeadingZero$2(num);
        }

        // remove default 'px' units
        if (params.defaultPx && units === 'px') {
          units = '';
        }

        roundedList.push(num + units);
      }
      // if attribute value is "new"(only enable-background).
      else if (matchNew) {
        roundedList.push('new');
      } else if (elem) {
        roundedList.push(elem);
      }
    }

    return roundedList.join(' ');
  }
};

var cleanupNumericValues = {};

cleanupNumericValues.type = 'perItem';

cleanupNumericValues.active = true;

cleanupNumericValues.description =
  'rounds numeric values to the fixed precision, removes default ‘px’ units';

cleanupNumericValues.params = {
  floatPrecision: 3,
  leadingZero: true,
  defaultPx: true,
  convertToPx: true,
};

var regNumericValues$2 = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/,
  removeLeadingZero$1 = tools.removeLeadingZero,
  absoluteLengths = {
    // relative to px
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    in: 96,
    pt: 4 / 3,
    pc: 16,
  };

/**
 * Round numeric values to the fixed precision,
 * remove default 'px' units.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
cleanupNumericValues.fn = function (item, params) {
  if (item.type === 'element') {
    var floatPrecision = params.floatPrecision;

    if (item.attributes.viewBox != null) {
      var nums = item.attributes.viewBox.split(/\s,?\s*|,\s*/g);
      item.attributes.viewBox = nums
        .map(function (value) {
          var num = +value;
          return isNaN(num) ? value : +num.toFixed(floatPrecision);
        })
        .join(' ');
    }

    for (const [name, value] of Object.entries(item.attributes)) {
      // The `version` attribute is a text string and cannot be rounded
      if (name === 'version') {
        continue;
      }

      var match = value.match(regNumericValues$2);

      // if attribute value matches regNumericValues
      if (match) {
        // round it to the fixed precision
        var num = +(+match[1]).toFixed(floatPrecision),
          units = match[3] || '';

        // convert absolute values to pixels
        if (params.convertToPx && units && units in absoluteLengths) {
          var pxNum = +(absoluteLengths[units] * match[1]).toFixed(
            floatPrecision
          );

          if (String(pxNum).length < match[0].length) {
            num = pxNum;
            units = 'px';
          }
        }

        // and remove leading zero
        if (params.leadingZero) {
          num = removeLeadingZero$1(num);
        }

        // remove default 'px' units
        if (params.defaultPx && units === 'px') {
          units = '';
        }

        item.attributes[name] = num + units;
      }
    }
  }
};

var collapseGroups = {};

const { inheritableAttrs: inheritableAttrs$3, elemsGroups: elemsGroups$3 } = _collections;

collapseGroups.type = 'perItemReverse';

collapseGroups.active = true;

collapseGroups.description = 'collapses useless groups';

function hasAnimatedAttr(item, name) {
  if (item.type === 'element') {
    return (
      (elemsGroups$3.animation.includes(item.name) &&
        item.attributes.attributeName === name) ||
      (item.children.length !== 0 &&
        item.children.some((child) => hasAnimatedAttr(child, name)))
    );
  }
  return false;
}

/*
 * Collapse useless groups.
 *
 * @example
 * <g>
 *     <g attr1="val1">
 *         <path d="..."/>
 *     </g>
 * </g>
 *         ⬇
 * <g>
 *     <g>
 *         <path attr1="val1" d="..."/>
 *     </g>
 * </g>
 *         ⬇
 * <path attr1="val1" d="..."/>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
collapseGroups.fn = function (item) {
  // non-empty elements
  if (
    item.type === 'element' &&
    item.name !== 'switch' &&
    item.children.length !== 0
  ) {
    item.children.forEach(function (g, i) {
      // non-empty groups
      if (g.type === 'element' && g.name === 'g' && g.children.length !== 0) {
        // move group attibutes to the single child element
        if (Object.keys(g.attributes).length !== 0 && g.children.length === 1) {
          var inner = g.children[0];

          if (
            inner.type === 'element' &&
            inner.attributes.id == null &&
            g.attributes.filter == null &&
            (g.attributes.class == null || inner.attributes.class == null) &&
            ((g.attributes['clip-path'] == null && g.attributes.mask == null) ||
              (inner.type === 'element' &&
                inner.name === 'g' &&
                g.attributes.transform == null &&
                inner.attributes.transform == null))
          ) {
            for (const [name, value] of Object.entries(g.attributes)) {
              if (g.children.some((item) => hasAnimatedAttr(item, name)))
                return;

              if (inner.attributes[name] == null) {
                inner.attributes[name] = value;
              } else if (name == 'transform') {
                inner.attributes[name] = value + ' ' + inner.attributes[name];
              } else if (inner.attributes[name] === 'inherit') {
                inner.attributes[name] = value;
              } else if (
                inheritableAttrs$3.includes(name) === false &&
                inner.attributes[name] !== value
              ) {
                return;
              }

              delete g.attributes[name];
            }
          }
        }

        // collapse groups without attributes
        if (
          Object.keys(g.attributes).length === 0 &&
          !g.children.some((item) => item.isElem(elemsGroups$3.animation))
        ) {
          item.spliceContent(i, 1, g.children);
        }
      }
    });
  }
};

var convertColors = {};

convertColors.type = 'perItem';

convertColors.active = true;

convertColors.description = 'converts colors: rgb() to #rrggbb and #rrggbb to #rgb';

convertColors.params = {
  currentColor: false,
  names2hex: true,
  rgb2hex: true,
  shorthex: true,
  shortname: true,
};

var collections$2 = _collections,
  rNumber = '([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)',
  rComma = '\\s*,\\s*',
  regRGB = new RegExp(
    '^rgb\\(\\s*' + rNumber + rComma + rNumber + rComma + rNumber + '\\s*\\)$'
  ),
  regHEX = /^#(([a-fA-F0-9])\2){3}$/,
  none = /\bnone\b/i;

/**
 * Convert different colors formats in element attributes to hex.
 *
 * @see https://www.w3.org/TR/SVG11/types.html#DataTypeColor
 * @see https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
 *
 * @example
 * Convert color name keyword to long hex:
 * fuchsia ➡ #ff00ff
 *
 * Convert rgb() to long hex:
 * rgb(255, 0, 255) ➡ #ff00ff
 * rgb(50%, 100, 100%) ➡ #7f64ff
 *
 * Convert long hex to short hex:
 * #aabbcc ➡ #abc
 *
 * Convert hex to short name
 * #000080 ➡ navy
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertColors.fn = function (item, params) {
  if (item.type === 'element') {
    for (const [name, value] of Object.entries(item.attributes)) {
      if (collections$2.colorsProps.includes(name)) {
        let val = value;
        let match;

        // Convert colors to currentColor
        if (params.currentColor) {
          if (typeof params.currentColor === 'string') {
            match = val === params.currentColor;
          } else if (params.currentColor.exec) {
            match = params.currentColor.exec(val);
          } else {
            match = !val.match(none);
          }
          if (match) {
            val = 'currentColor';
          }
        }

        // Convert color name keyword to long hex
        if (params.names2hex && val.toLowerCase() in collections$2.colorsNames) {
          val = collections$2.colorsNames[val.toLowerCase()];
        }

        // Convert rgb() to long hex
        if (params.rgb2hex && (match = val.match(regRGB))) {
          match = match.slice(1, 4).map(function (m) {
            if (m.indexOf('%') > -1) m = Math.round(parseFloat(m) * 2.55);

            return Math.max(0, Math.min(m, 255));
          });

          val = rgb2hex(match);
        }

        // Convert long hex to short hex
        if (params.shorthex && (match = val.match(regHEX))) {
          val = '#' + match[0][1] + match[0][3] + match[0][5];
        }

        // Convert hex to short name
        if (params.shortname) {
          var lowerVal = val.toLowerCase();
          if (lowerVal in collections$2.colorsShortNames) {
            val = collections$2.colorsShortNames[lowerVal];
          }
        }

        item.attributes[name] = val;
      }
    }
  }
};

/**
 * Convert [r, g, b] to #rrggbb.
 *
 * @see https://gist.github.com/983535
 *
 * @example
 * rgb2hex([255, 255, 255]) // '#ffffff'
 *
 * @param {Array} rgb [r, g, b]
 * @return {String} #rrggbb
 *
 * @author Jed Schmidt
 */
function rgb2hex(rgb) {
  return (
    '#' +
    ('00000' + ((rgb[0] << 16) | (rgb[1] << 8) | rgb[2]).toString(16))
      .slice(-6)
      .toUpperCase()
  );
}

var convertEllipseToCircle = {};

convertEllipseToCircle.type = 'perItem';

convertEllipseToCircle.active = true;

convertEllipseToCircle.description = 'converts non-eccentric <ellipse>s to <circle>s';

/**
 * Converts non-eccentric <ellipse>s to <circle>s.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Taylor Hunt
 */
convertEllipseToCircle.fn = function (item) {
  if (item.isElem('ellipse')) {
    const rx = item.attributes.rx || 0;
    const ry = item.attributes.ry || 0;

    if (
      rx === ry ||
      rx === 'auto' ||
      ry === 'auto' // SVG2
    ) {
      var radius = rx !== 'auto' ? rx : ry;
      item.renameElem('circle');
      delete item.attributes.rx;
      delete item.attributes.ry;
      item.attributes.r = radius;
    }
  }
};

var convertPathData = {};

var style = {};

var stable$2 = {exports: {}};

(function (module, exports) {
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//! © 2018 Angry Bytes and contributors. MIT licensed.

(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {
  // A stable array sort, because `Array#sort()` is not guaranteed stable.
  // This is an implementation of merge sort, without recursion.

  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  // Execute the sort using the input array and a second buffer as work space.
  // Returns one of those two, containing the final result.
  function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
      return arr
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  // Run a single pass with the given chunk size.
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  return stable;

})));
}(stable$2));

var syntax = {exports: {}};

var create$4 = {};

//
//                              list
//                            ┌──────┐
//             ┌──────────────┼─head │
//             │              │ tail─┼──────────────┐
//             │              └──────┘              │
//             ▼                                    ▼
//            item        item        item        item
//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
//          │ data │    │ data │    │ data │    │ data │
//          └──────┘    └──────┘    └──────┘    └──────┘
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List$d = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List$d.createItem = createItem;
List$d.prototype.createItem = createItem;

List$d.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List$d.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List$d.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List$d.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.toJSON = List$d.prototype.toArray;

List$d.prototype.isEmpty = function() {
    return this.head === null;
};

List$d.prototype.first = function() {
    return this.head && this.head.data;
};

List$d.prototype.last = function() {
    return this.tail && this.tail.data;
};

List$d.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.forEach = List$d.prototype.each;

List$d.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.forEachRight = List$d.prototype.eachRight;

List$d.prototype.reduce = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);
    var acc = initialValue;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List$d.prototype.reduceRight = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);
    var acc = initialValue;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List$d.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$d.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List$d.prototype.map = function(fn, context) {
    var result = new List$d();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.filter = function(fn, context) {
    var result = new List$d();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List$d.prototype.copy = function() {
    var result = new List$d();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List$d.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List$d.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List$d.prototype.append = function(item) {
    return this.insert(item);
};

List$d.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List$d.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List$d.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List$d.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List$d.prototype.push = function(data) {
    this.insert(createItem(data));
};

List$d.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List$d.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List$d.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List$d.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List$d.prototype.appendList = function(list) {
    return this.insertList(list);
};

List$d.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List$d.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

var List_1 = List$d;

var createCustomError$3 = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};

var createCustomError$2 = createCustomError$3;
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var SyntaxError$4 = function(message, source, offset, line, column) {
    var error = createCustomError$2('SyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

var _SyntaxError$1 = SyntaxError$4;

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
var TYPE$H = {
    EOF: 0,                 // <EOF-token>
    Ident: 1,               // <ident-token>
    Function: 2,            // <function-token>
    AtKeyword: 3,           // <at-keyword-token>
    Hash: 4,                // <hash-token>
    String: 5,              // <string-token>
    BadString: 6,           // <bad-string-token>
    Url: 7,                 // <url-token>
    BadUrl: 8,              // <bad-url-token>
    Delim: 9,               // <delim-token>
    Number: 10,             // <number-token>
    Percentage: 11,         // <percentage-token>
    Dimension: 12,          // <dimension-token>
    WhiteSpace: 13,         // <whitespace-token>
    CDO: 14,                // <CDO-token>
    CDC: 15,                // <CDC-token>
    Colon: 16,              // <colon-token>     :
    Semicolon: 17,          // <semicolon-token> ;
    Comma: 18,              // <comma-token>     ,
    LeftSquareBracket: 19,  // <[-token>
    RightSquareBracket: 20, // <]-token>
    LeftParenthesis: 21,    // <(-token>
    RightParenthesis: 22,   // <)-token>
    LeftCurlyBracket: 23,   // <{-token>
    RightCurlyBracket: 24,  // <}-token>
    Comment: 25
};

var NAME$3 = Object.keys(TYPE$H).reduce(function(result, key) {
    result[TYPE$H[key]] = key;
    return result;
}, {});

var _const = {
    TYPE: TYPE$H,
    NAME: NAME$3
};

var EOF$1 = 0;

// https://drafts.csswg.org/css-syntax-3/
// § 4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit$6(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit$4(code) {
    return (
        isDigit$6(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter$1(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter$1(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName$2(code) {
    return isNameStart(code) || isDigit$6(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline$1(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace$2(code) {
    return isNewline$1(code) || code === 0x0020 || code === 0x0009;
}

// § 4.3.8. Check if two code points are a valid escape
function isValidEscape$2(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline$1(second) || second === EOF$1) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

// § 4.3.9. Check if three code points would start an identifier
function isIdentifierStart$2(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape$2(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape$2(first, second);
    }

    // anything else
    // Return false.
    return false;
}

// § 4.3.10. Check if three code points would start a number
function isNumberStart$1(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit$6(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit$6(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit$6(second) ? 2 : 0;
    }

    // digit
    if (isDigit$6(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM$2(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
//
// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
var CATEGORY = new Array(0x80);
charCodeCategory$1.Eof = 0x80;
charCodeCategory$1.WhiteSpace = 0x82;
charCodeCategory$1.Digit = 0x83;
charCodeCategory$1.NameStart = 0x84;
charCodeCategory$1.NonPrintable = 0x85;

for (var i = 0; i < CATEGORY.length; i++) {
    switch (true) {
        case isWhiteSpace$2(i):
            CATEGORY[i] = charCodeCategory$1.WhiteSpace;
            break;

        case isDigit$6(i):
            CATEGORY[i] = charCodeCategory$1.Digit;
            break;

        case isNameStart(i):
            CATEGORY[i] = charCodeCategory$1.NameStart;
            break;

        case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory$1.NonPrintable;
            break;

        default:
            CATEGORY[i] = i || charCodeCategory$1.Eof;
    }
}

function charCodeCategory$1(code) {
    return code < 0x80 ? CATEGORY[code] : charCodeCategory$1.NameStart;
}
var charCodeDefinitions$1 = {
    isDigit: isDigit$6,
    isHexDigit: isHexDigit$4,
    isUppercaseLetter: isUppercaseLetter$1,
    isLowercaseLetter: isLowercaseLetter,
    isLetter: isLetter,
    isNonAscii: isNonAscii,
    isNameStart: isNameStart,
    isName: isName$2,
    isNonPrintable: isNonPrintable,
    isNewline: isNewline$1,
    isWhiteSpace: isWhiteSpace$2,
    isValidEscape: isValidEscape$2,
    isIdentifierStart: isIdentifierStart$2,
    isNumberStart: isNumberStart$1,

    isBOM: isBOM$2,
    charCodeCategory: charCodeCategory$1
};

var charCodeDef = charCodeDefinitions$1;
var isDigit$5 = charCodeDef.isDigit;
var isHexDigit$3 = charCodeDef.isHexDigit;
var isUppercaseLetter = charCodeDef.isUppercaseLetter;
var isName$1 = charCodeDef.isName;
var isWhiteSpace$1 = charCodeDef.isWhiteSpace;
var isValidEscape$1 = charCodeDef.isValidEscape;

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength$1(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar$5(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr$6(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart$1(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit$5(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
function consumeEscaped$1(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit$3(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit$3(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        var code = getCharCode(source, offset);
        if (isWhiteSpace$1(code)) {
            offset += getNewlineLength$1(source, offset, code);
        }
    }

    return offset;
}

// §4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName$1(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // name code point
        if (isName$1(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped$1(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// §4.3.12. Consume a number
function consumeNumber$5(source, offset) {
    var code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit$5(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit$5(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        code = source.charCodeAt(offset += 2);

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar$5(source, offset, 101 /* e */)) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit$5(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

// § 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants$1(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped$1(source, offset);
        }
    }

    return offset;
}

var utils$7 = {
    consumeEscaped: consumeEscaped$1,
    consumeName: consumeName$1,
    consumeNumber: consumeNumber$5,
    consumeBadUrlRemnants: consumeBadUrlRemnants$1,

    cmpChar: cmpChar$5,
    cmpStr: cmpStr$6,

    getNewlineLength: getNewlineLength$1,
    findWhiteSpaceStart: findWhiteSpaceStart$1,
    findWhiteSpaceEnd: findWhiteSpaceEnd$1
};

var constants$2 = _const;
var TYPE$G = constants$2.TYPE;
var NAME$2 = constants$2.NAME;

var utils$6 = utils$7;
var cmpStr$5 = utils$6.cmpStr;

var EOF = TYPE$G.EOF;
var WHITESPACE$c = TYPE$G.WhiteSpace;
var COMMENT$a = TYPE$G.Comment;

var OFFSET_MASK$1 = 0x00FFFFFF;
var TYPE_SHIFT$1 = 24;

var TokenStream$4 = function() {
    this.offsetAndType = null;
    this.balance = null;

    this.reset();
};

TokenStream$4.prototype = {
    reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    },

    lookupType: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT$1;
        }

        return EOF;
    },
    lookupOffset: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK$1;
        }

        return this.source.length;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr$5(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK$1,
                this.offsetAndType[offset] & OFFSET_MASK$1,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK$1
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK$1;
        }

        return this.firstCharOffset;
    },

    // TODO: -> skipUntilBalanced
    getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK$1;
        var type;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            type = this.offsetAndType[cursor] >> TYPE_SHIFT$1;

            // check token is stop type
            switch (mode(type, this.source, offset)) {
                case 1:
                    break loop;

                case 2:
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }

                    offset = this.offsetAndType[cursor] & OFFSET_MASK$1;
            }
        }

        return cursor - this.tokenIndex;
    },
    isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
    },
    isDelim: function(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === TYPE$G.Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === TYPE$G.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT$1) !== WHITESPACE$c) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE$c || this.tokenType === COMMENT$a) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK$1;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT$1;
            this.tokenEnd = next & OFFSET_MASK$1;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT$1;
            this.tokenEnd = next & OFFSET_MASK$1;
        } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    forEachToken(fn) {
        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK$1;
            var type = item >> TYPE_SHIFT$1;

            offset = end;

            fn(type, start, end, i);
        }
    },

    dump() {
        var tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: NAME$2[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

var TokenStream_1 = TokenStream$4;

function noop$3(value) {
    return value;
}

function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        (multiplier.min === multiplier.max
            ? '{' + multiplier.min + '}'
            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-∞' : node.min) +
                ',' +
                (node.max === null ? '∞' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    var result = node.terms.map(function(term) {
        return generate$8(term, decorate, forceBraces, compact);
    }).join(combinator);

    if (node.explicit || forceBraces) {
        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function generate$8(node, decorate, forceBraces, compact) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                generate$8(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

var generate_1 = function(node, options) {
    var decorate = noop$3;
    var forceBraces = false;
    var compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return generate$8(node, decorate, forceBraces, compact);
};

const createCustomError$1 = createCustomError$3;
const generate$7 = generate_1;
const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError$1 = function(type, referenceName) {
    const error = createCustomError$1(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError$1 = function(message, syntax, node, matchResult) {
    const error = createCustomError$1('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate$7(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

var error$1 = {
    SyntaxReferenceError: SyntaxReferenceError$1,
    SyntaxMatchError: SyntaxMatchError$1
};

var hasOwnProperty$a = Object.prototype.hasOwnProperty;
var keywords$2 = Object.create(null);
var properties$1 = Object.create(null);
var HYPHENMINUS$5 = 45; // '-'.charCodeAt()

function isCustomProperty$1(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS$5 &&
           str.charCodeAt(offset + 1) === HYPHENMINUS$5;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS$5 &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty$a.call(keywords$2, keyword)) {
        return keywords$2[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty$a.call(keywords$2, name)) {
        return keywords$2[keyword] = keywords$2[name];
    }

    var custom = isCustomProperty$1(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords$2[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty$a.call(properties$1, property)) {
        return properties$1[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    var custom = isCustomProperty$1(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty$a.call(properties$1, name)) {
            return properties$1[property] = properties$1[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties$1[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

var names$2 = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty$1,
    vendorPrefix: getVendorPrefix
};

var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

var adoptBuffer$2 = function adoptBuffer(buffer, size) {
    if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
};

var TokenStream$3 = TokenStream_1;
var adoptBuffer$1 = adoptBuffer$2;

var constants$1 = _const;
var TYPE$F = constants$1.TYPE;

var charCodeDefinitions = charCodeDefinitions$1;
var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM$1 = charCodeDefinitions.isBOM;

var utils$5 = utils$7;
var cmpStr$4 = utils$5.cmpStr;
var getNewlineLength = utils$5.getNewlineLength;
var findWhiteSpaceEnd = utils$5.findWhiteSpaceEnd;
var consumeEscaped = utils$5.consumeEscaped;
var consumeName = utils$5.consumeName;
var consumeNumber$4 = utils$5.consumeNumber;
var consumeBadUrlRemnants = utils$5.consumeBadUrlRemnants;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize$3(source, stream) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    // § 4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber$4(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>’s unit to the returned value.
            // Return the <dimension-token>.
            type = TYPE$F.Dimension;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = TYPE$F.Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = TYPE$F.Number;
    }

    // § 4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If string’s value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr$4(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = TYPE$F.Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = TYPE$F.Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = TYPE$F.Ident;
    }

    // § 4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = TYPE$F.String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <string-token>.
                    return;

                // newline
                case charCodeCategory.WhiteSpace:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = TYPE$F.BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    var nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>’s value.
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>’s value.
            }
        }
    }

    // § 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = TYPE$F.Url;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <url-token>.
                    return;

                // whitespace
                case charCodeCategory.WhiteSpace:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeCategory.NonPrintable:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>’s value.
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE$F.BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>’s value.
            }
        }
    }

    if (!stream) {
        stream = new TokenStream$3();
    }

    // ensure source is a string
    source = String(source || '');

    var sourceLength = source.length;
    var offsetAndType = adoptBuffer$1(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    var balance = adoptBuffer$1(stream.balance, sourceLength + 1);
    var tokenCount = 0;
    var start = isBOM$1(getCharCode(0));
    var offset = start;
    var balanceCloseType = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    // § 4.3.1. Consume a token
    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;

        balance[tokenCount] = sourceLength;

        switch (charCodeCategory(code)) {
            // whitespace
            case charCodeCategory.WhiteSpace:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = TYPE$F.WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = TYPE$F.Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>’s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = TYPE$F.LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = TYPE$F.RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = TYPE$F.Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = TYPE$F.CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = TYPE$F.Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = TYPE$F.Comment;
                    offset = source.indexOf('*/', offset + 2) + 2;
                    if (offset === 1) {
                        offset = source.length;
                    }
                } else {
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = TYPE$F.Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = TYPE$F.Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = TYPE$F.CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = TYPE$F.AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = TYPE$F.LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = TYPE$F.Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = TYPE$F.RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = TYPE$F.LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = TYPE$F.RightCurlyBracket;
                offset++;
                break;

            // digit
            case charCodeCategory.Digit:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case charCodeCategory.NameStart:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

            // EOF
            case charCodeCategory.Eof:
                // Return an <EOF-token>.
                break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = TYPE$F.Delim;
                offset++;
        }

        switch (type) {
            case balanceCloseType:
                balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                    if (balance[balancePrev] === sourceLength) {
                        balance[balancePrev] = tokenCount;
                    }
                }
                break;

            case TYPE$F.LeftParenthesis:
            case TYPE$F.Function:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightParenthesis;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE$F.LeftSquareBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightSquareBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE$F.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE$F.RightCurlyBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    }

    // finalize buffers
    offsetAndType[tokenCount] = (TYPE$F.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    // update stream
    stream.source = source;
    stream.firstCharOffset = start;
    stream.offsetAndType = offsetAndType;
    stream.tokenCount = tokenCount;
    stream.balance = balance;
    stream.reset();
    stream.next();

    return stream;
}

// extend tokenizer with constants
Object.keys(constants$1).forEach(function(key) {
    tokenize$3[key] = constants$1[key];
});

// extend tokenizer with static methods from utils
Object.keys(charCodeDefinitions).forEach(function(key) {
    tokenize$3[key] = charCodeDefinitions[key];
});
Object.keys(utils$5).forEach(function(key) {
    tokenize$3[key] = utils$5[key];
});

var tokenizer$3 = tokenize$3;

var isDigit$4 = tokenizer$3.isDigit;
var cmpChar$4 = tokenizer$3.cmpChar;
var TYPE$E = tokenizer$3.TYPE;

var DELIM$6 = TYPE$E.Delim;
var WHITESPACE$b = TYPE$E.WhiteSpace;
var COMMENT$9 = TYPE$E.Comment;
var IDENT$i = TYPE$E.Ident;
var NUMBER$9 = TYPE$E.Number;
var DIMENSION$7 = TYPE$E.Dimension;
var PLUSSIGN$8 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)
var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN$1 = true;
var ALLOW_SIGN$1 = false;

function isDelim$1(token, code) {
    return token !== null && token.type === DELIM$6 && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WHITESPACE$b || token.type === COMMENT$9)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    var code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit$4(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$1(token, offset_, getNextToken) {
    var sign = false;
    var offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== NUMBER$9) {
        if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null && token.type !== NUMBER$9) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var genericAnPlusB = function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    var offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === NUMBER$9) {
        return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === IDENT$i && token.value.charCodeAt(0) === HYPHENMINUS$4) {
        // expect 1st char is N
        if (!cmpChar$4(token.value, 1, N$4)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === IDENT$i || (isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === IDENT$i)) {
        // just ignore a plus
        if (token.type !== IDENT$i) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar$4(token.value, 0, N$4)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === DIMENSION$7) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;

        for (var i = sign; i < token.value.length; i++) {
            if (!isDigit$4(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar$4(token.value, i, N$4)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB$1(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
            }
        }
    }

    return 0;
};

var isHexDigit$2 = tokenizer$3.isHexDigit;
var cmpChar$3 = tokenizer$3.cmpChar;
var TYPE$D = tokenizer$3.TYPE;

var IDENT$h = TYPE$D.Ident;
var DELIM$5 = TYPE$D.Delim;
var NUMBER$8 = TYPE$D.Number;
var DIMENSION$6 = TYPE$D.Dimension;
var PLUSSIGN$7 = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS$3 = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
var U$2 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === DELIM$5 && token.value.charCodeAt(0) === code;
}

function startsWith$1(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
                return 6; // dissallow following question marks
            }

            return 0; // dash at the ending of a hex sequence is not allowed
        }

        if (!isHexDigit$2(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        }    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
var genericUrange = function urange(token, getNextToken) {
    var length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== IDENT$h || !cmpChar$3(token.value, 0, U$2)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN$7)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === IDENT$h) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK$2)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === NUMBER$8) {
        if (!startsWith$1(token, PLUSSIGN$7)) {
            return 0;
        }

        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === DIMENSION$6 || token.type === NUMBER$8) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === DIMENSION$6) {
        if (!startsWith$1(token, PLUSSIGN$7)) {
            return 0;
        }

        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
};

var tokenizer$2 = tokenizer$3;
var isIdentifierStart = tokenizer$2.isIdentifierStart;
var isHexDigit$1 = tokenizer$2.isHexDigit;
var isDigit$3 = tokenizer$2.isDigit;
var cmpStr$3 = tokenizer$2.cmpStr;
var consumeNumber$3 = tokenizer$2.consumeNumber;
var TYPE$C = tokenizer$2.TYPE;
var anPlusB = genericAnPlusB;
var urange = genericUrange;

var cssWideKeywords$1 = ['unset', 'initial', 'inherit'];
var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

// safe char code getter
function charCode(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr$3(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (var i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit$3(str.charCodeAt(offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        var num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        if (opts.min !== null && num < opts.min) {
            return true;
        }

        if (opts.max !== null && num > opts.max) {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    var startIdx = token.index;
    var length = 0;

    // balanced token consuming
    do {
        length++;

        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === TYPE$C.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

function func(name) {
    name = name + '(';

    return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
        }

        return 0;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== TYPE$C.Ident) {
        return 0;
    }

    var name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords$1)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
    // in that property’s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== TYPE$C.Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== TYPE$C.Hash) {
        return 0;
    }

    var length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (var i = 1; i < length; i++) {
        if (!isHexDigit$1(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== TYPE$C.Hash) {
        return 0;
    }

    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var length = 0;
    var level = 0;
    var startIdx = token.index;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE$C.BadString:
            case TYPE$C.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE$C.RightCurlyBracket:
            case TYPE$C.RightParenthesis:
            case TYPE$C.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                level--;
                break;

            // ... or top-level <semicolon-token> tokens
            case TYPE$C.Semicolon:
                if (level === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case TYPE$C.Delim:
                if (token.value === '!' && level === 0) {
                    break scan;
                }

                break;

            case TYPE$C.Function:
            case TYPE$C.LeftParenthesis:
            case TYPE$C.LeftSquareBracket:
            case TYPE$C.LeftCurlyBracket:
                level++;
                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var startIdx = token.index;
    var length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE$C.BadString:
            case TYPE$C.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE$C.RightCurlyBracket:
            case TYPE$C.RightParenthesis:
            case TYPE$C.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE$C.Dimension) {
            return 0;
        }

        var numberEnd = consumeNumber$3(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// §5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== TYPE$C.Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE$C.Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

// § 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    var numberEnd = consumeNumber$3(token.value, 0);
    var isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// §5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== TYPE$C.Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit$3(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

var generic$1 = {
    // token types
    'ident-token': tokenType(TYPE$C.Ident),
    'function-token': tokenType(TYPE$C.Function),
    'at-keyword-token': tokenType(TYPE$C.AtKeyword),
    'hash-token': tokenType(TYPE$C.Hash),
    'string-token': tokenType(TYPE$C.String),
    'bad-string-token': tokenType(TYPE$C.BadString),
    'url-token': tokenType(TYPE$C.Url),
    'bad-url-token': tokenType(TYPE$C.BadUrl),
    'delim-token': tokenType(TYPE$C.Delim),
    'number-token': tokenType(TYPE$C.Number),
    'percentage-token': tokenType(TYPE$C.Percentage),
    'dimension-token': tokenType(TYPE$C.Dimension),
    'whitespace-token': tokenType(TYPE$C.WhiteSpace),
    'CDO-token': tokenType(TYPE$C.CDO),
    'CDC-token': tokenType(TYPE$C.CDC),
    'colon-token': tokenType(TYPE$C.Colon),
    'semicolon-token': tokenType(TYPE$C.Semicolon),
    'comma-token': tokenType(TYPE$C.Comma),
    '[-token': tokenType(TYPE$C.LeftSquareBracket),
    ']-token': tokenType(TYPE$C.RightSquareBracket),
    '(-token': tokenType(TYPE$C.LeftParenthesis),
    ')-token': tokenType(TYPE$C.RightParenthesis),
    '{-token': tokenType(TYPE$C.LeftCurlyBracket),
    '}-token': tokenType(TYPE$C.RightCurlyBracket),

    // token type aliases
    'string': tokenType(TYPE$C.String),
    'ident': tokenType(TYPE$C.Ident),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue,

    // dimensions
    'dimension': calc(dimension(null)),
    'angle': calc(dimension(ANGLE)),
    'decibel': calc(dimension(DECIBEL)),
    'frequency': calc(dimension(FREQUENCY)),
    'flex': calc(dimension(FLEX)),
    'length': calc(zero(dimension(LENGTH))),
    'resolution': calc(dimension(RESOLUTION)),
    'semitones': calc(dimension(SEMITONES)),
    'time': calc(dimension(TIME)),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),

    // old IE stuff
    '-ms-legacy-expression': func('expression')
};

var createCustomError = createCustomError$3;

var _SyntaxError = function SyntaxError(message, input, offset) {
    var error = createCustomError('SyntaxError', message);

    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' +
        '  ' + error.input + '\n' +
        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    return error;
};

var SyntaxError$3 = _SyntaxError;

var TAB$1 = 9;
var N$3 = 10;
var F$2 = 12;
var R$2 = 13;
var SPACE$2 = 32;

var Tokenizer$1 = function(str) {
    this.str = str;
    this.pos = 0;
};

Tokenizer$1.prototype = {
    charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function() {
        return this.charCodeAt(this.pos);
    },
    nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R$2 && code !== N$3 && code !== F$2 && code !== SPACE$2 && code !== TAB$1) {
                break;
            }
        }

        return pos;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    },
    peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function(message) {
        throw new SyntaxError$3(message, this.str, this.pos);
    }
};

var tokenizer$1 = Tokenizer$1;

var Tokenizer = tokenizer$1;
var TAB = 9;
var N$2 = 10;
var F$1 = 12;
var R$1 = 13;
var SPACE$1 = 32;
var EXCLAMATIONMARK$3 = 33;    // !
var NUMBERSIGN$4 = 35;         // #
var AMPERSAND$1 = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS$7 = 40;    // (
var RIGHTPARENTHESIS$7 = 41;   // )
var ASTERISK$6 = 42;           // *
var PLUSSIGN$6 = 43;           // +
var COMMA$4 = 44;              // ,
var HYPERMINUS = 45;         // -
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN$2 = 62;    // >
var QUESTIONMARK$1 = 63;       // ?
var COMMERCIALAT = 64;       // @
var LEFTSQUAREBRACKET$4 = 91;  // [
var RIGHTSQUAREBRACKET$2 = 93; // ]
var LEFTCURLYBRACKET$4 = 123;  // {
var VERTICALLINE$3 = 124;      // |
var RIGHTCURLYBRACKET$2 = 125; // }
var INFINITY = 8734;         // ∞
var NAME_CHAR = createCharMap(function(ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
}

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET$4);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA$4) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$2) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET$2);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK$6:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN$6:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK$1:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN$4:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET$4) {
                range = readMultiplierRange(tokenizer);
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET$4:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma: comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty$1(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation—[min,max]—within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    var min = null; // -Infinity
    var max = null; // Infinity
    var sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET$4);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA$4);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));
    }

    tokenizer.eat(RIGHTSQUAREBRACKET$2);

    // If no range is indicated, either by using the bracketed range notation
    // or in the property description, then [−∞,∞] is assumed.
    if (min === null && max === null) {
        return null;
    }

    return {
        type: 'Range',
        min: min,
        max: max
    };
}

function readType(tokenizer) {
    var name;
    var opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$7 &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS$7) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET$4) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name,
        opts: opts
    });
}

function readKeywordOrFunction(tokenizer) {
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$7) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name: name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET$4);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET$2);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK$3) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET$2:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET$4:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty$1(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE$3:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.nextCharCode() === VERTICALLINE$3
                        ? tokenizer.pos + 2
                        : tokenizer.pos + 1
                )
            };

        case AMPERSAND$1:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND$1);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA$4:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE$1:
        case TAB:
        case N$2:
        case R$1:
        case F$1:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK$6:
        case PLUSSIGN$6:
        case QUESTIONMARK$1:
        case NUMBERSIGN$4:
        case EXCLAMATIONMARK$3:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET$4:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse$3(source) {
    var tokenizer = new Tokenizer(source);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse$3('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

var parse_1 = parse$3;

var noop$2 = function() {};

function ensureFunction$1(value) {
    return typeof value === 'function' ? value : noop$2;
}

var walk$d = function(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop$2;
    var leave = noop$2;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction$1(options.enter);
        leave = ensureFunction$1(options.leave);
    }

    if (enter === noop$2 && leave === noop$2) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node);
};

var tokenize$2 = tokenizer$3;
var TokenStream$2 = TokenStream_1;
var tokenStream = new TokenStream$2();
var astToTokens = {
    decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = '';

        return {
            children: handlers.children,
            node: function(node) {
                var tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            chunk: function(chunk) {
                buffer += chunk;
                if (prev.node !== curNode) {
                    nodes.push({
                        len: chunk.length,
                        node: curNode
                    });
                } else {
                    prev.len += chunk.length;
                }
            },
            result: function() {
                return prepareTokens$1(buffer, nodes);
            }
        };
    }
};

function prepareTokens$1(str, nodes) {
    var tokens = [];
    var nodesOffset = 0;
    var nodesIndex = 0;
    var currentNode = nodes ? nodes[nodesIndex].node : null;

    tokenize$2(str, tokenStream);

    while (!tokenStream.eof) {
        if (nodes) {
            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
                nodesOffset += nodes[nodesIndex++].len;
                currentNode = nodes[nodesIndex].node;
            }
        }

        tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
            node: currentNode
        });
        tokenStream.next();
        // console.log({ ...tokens[tokens.length - 1], node: undefined });
    }

    return tokens;
}

var prepareTokens_1 = function(value, syntax) {
    if (typeof value === 'string') {
        return prepareTokens$1(value, null);
    }

    return syntax.generate(value, astToTokens);
};

var parse$2 = parse_1;

var MATCH$1 = { type: 'Match' };
var MISMATCH$1 = { type: 'Mismatch' };
var DISALLOW_EMPTY$1 = { type: 'DisallowEmpty' };
var LEFTPARENTHESIS$6 = 40;  // (
var RIGHTPARENTHESIS$6 = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH$1 && elseBranch === MISMATCH$1) {
        return match;
    }

    if (match === MATCH$1 && thenBranch === MATCH$1 && elseBranch === MATCH$1) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH$1 && thenBranch === MATCH$1) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match: match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$6 &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$6
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ':
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            var result = MATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH$1
                );
            }
            return result;

        case '|':
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            var result = MISMATCH$1;
            var map = null;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map: map
                            },
                            MATCH$1,
                            result
                        );
                    }

                    if (map !== null) {
                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH$1,
                    result
                );
            }
            return result;

        case '&&':
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            var result = MISMATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH$1;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;

        case '||':
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            var result = atLeastOneTermMatched ? MATCH$1 : MISMATCH$1;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH$1;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
    }
}

function buildMultiplierMatchGraph(node) {
    var result = MATCH$1;
    var matchTerm = buildMatchGraph$1(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY$1,
            MISMATCH$1
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH$1
        );

        result.then = createCondition(
            MATCH$1,
            MATCH$1,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH$1
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH$1) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH$1
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH$1,
                    MATCH$1,
                    result
                ),
                MISMATCH$1
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH$1,
            MATCH$1,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH$1) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH$1
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH$1
            );
        }
    }

    return result;
}

function buildMatchGraph$1(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group':
            var result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraph$1),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY$1,
                    MISMATCH$1
                );
            }

            return result;

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

var matchGraph$1 = {
    MATCH: MATCH$1,
    MISMATCH: MISMATCH$1,
    DISALLOW_EMPTY: DISALLOW_EMPTY$1,
    buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === 'string') {
            syntaxTree = parse$2(syntaxTree);
        }

        return {
            type: 'MatchGraph',
            match: buildMatchGraph$1(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
        };
    }
};

var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
var matchGraph = matchGraph$1;
var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
var TYPE$B = _const.TYPE;

var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;

var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;

function reverseList(list) {
    var prev = null;
    var next = null;
    var item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (var i = 0; i < testStr.length; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== TYPE$B.Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE$B.Comma ||
        token.type === TYPE$B.Function ||
        token.type === TYPE$B.LeftParenthesis ||
        token.type === TYPE$B.LeftSquareBracket ||
        token.type === TYPE$B.LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE$B.RightParenthesis ||
        token.type === TYPE$B.RightSquareBracket ||
        token.type === TYPE$B.RightCurlyBracket ||
        token.type === TYPE$B.Delim
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE$B.WhiteSpace || token.type === TYPE$B.Comment));
    }

    function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            thenStack: thenStack,
            tokenIndex: tokenIndex,
            prev: prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token: token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;

    // null – stashing allowed, nothing stashed
    // false – stashing disabled, nothing stashed
    // anithing else – fail stashable syntaxes, some syntax stashed
    var syntaxStash = null;

    var iterationCount = 0; // count iterations and prevent infinite loop
    var exitReason = null;

    var token = null;
    var tokenIndex = -1;
    var longestMatch = 0;
    var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     var result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer':
                var terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    var matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    var name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty$9.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic':
                var opts = syntaxStack !== null ? syntaxStack.opts : null;
                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            case 'Type':
            case 'Property':
                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                var dictSyntax = hasOwnProperty$9.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    var lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === TYPE$B.Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;

            case 'Keyword':
                var name = state.name;

                if (token !== null) {
                    var keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === TYPE$B.Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                var string = '';

                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    totalIterationCount += iterationCount;

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens: tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch: longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case STUB:
                    break;

                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree$1(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    var item = matchResult.match;
    var host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    var hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

var match = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree$1,
    getTotalIterationCount: function() {
        return totalIterationCount;
    }
};

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

var trace$1 = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};

var List$c = List_1;

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List$c();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

var search$1 = {
    matchFragments: matchFragments
};

var List$b = List_1;
var hasOwnProperty$8 = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty$8.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List$b;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty$8.call(fields, key) &&
                hasOwnProperty$8.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty$8.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

var structure = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty$8.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};

var SyntaxReferenceError = error$1.SyntaxReferenceError;
var SyntaxMatchError = error$1.SyntaxMatchError;
var names$1 = names$2;
var generic = generic$1;
var parse$1 = parse_1;
var generate$6 = generate_1;
var walk$c = walk$d;
var prepareTokens = prepareTokens_1;
var buildMatchGraph = matchGraph$1.buildMatchGraph;
var matchAsTree = match.matchAsTree;
var trace = trace$1;
var search = search$1;
var getStructureFromConfig = structure.getStructureFromConfig;
var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate$6(map[name].syntax, { compact: compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate$6(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(match, error, iterations) {
    return {
        matched: match,
        iterations: iterations,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, value, useCommon) {
    var tokens = prepareTokens(value, lexer.syntax);
    var result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

var Lexer$1 = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = {};
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.atrules) {
            for (var name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer$1.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name, parent = null) {
        var ref = {
            type: type,
            name: name
        };
        var descriptor = {
            type: type,
            name: name,
            parent: parent,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse$1(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get: function() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    },
    addAtrule_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce((res, descName) => {
                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                    return res;
                }, {})
                : null
        };
    },
    addProperty_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic['-ms-legacy-expression']) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    checkAtruleName: function(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    },
    checkAtrulePrelude: function(atruleName, prelude) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
        }
    },
    checkAtruleDescriptorName: function(atruleName, descriptorName) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names$1.keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    },
    checkPropertyName: function(propertyName) {
        var property = names$1.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return new Error('Lexer matching doesn\'t applicable for custom properties');
        }

        if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError('Unknown property', propertyName);
        }
    },

    matchAtrulePrelude: function(atruleName, prelude) {
        var error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        if (!prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
    },
    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names$1.keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    },
    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getAtrule: function(atruleName, fallbackBasename = true) {
        var atrule = names$1.keyword(atruleName);
        var atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    },
    getAtrulePrelude: function(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    },
    getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    },
    getProperty: function(propertyName, fallbackBasename = true) {
        var property = names$1.property(propertyName);
        var propertyEntry = property.vendor && fallbackBasename
            ? this.properties[property.name] || this.properties[property.basename]
            : this.properties[property.name];

        return propertyEntry || null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk$c(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

var Lexer_1 = Lexer$1;

var definitionSyntax$1 = {
    SyntaxError: _SyntaxError,
    parse: parse_1,
    generate: generate_1,
    walk: walk$d
};

var adoptBuffer = adoptBuffer$2;
var isBOM = tokenizer$3.isBOM;

var N$1 = 10;
var F = 12;
var R = 13;

function computeLinesAndColumns(host, source) {
    var sourceLength = source.length;
    var lines = adoptBuffer(host.lines, sourceLength); // +1
    var line = host.startLine;
    var columns = adoptBuffer(host.columns, sourceLength);
    var column = host.startColumn;
    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

    for (var i = startOffset; i < sourceLength; i++) { // -1
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N$1 || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$1) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    host.lines = lines;
    host.columns = columns;
}

var OffsetToLocation$1 = function() {
    this.lines = null;
    this.columns = null;
    this.linesAndColumnsComputed = false;
};

OffsetToLocation$1.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
    },

    ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
        }
    },
    getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },
    getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

var OffsetToLocation_1 = OffsetToLocation$1;

var TYPE$A = tokenizer$3.TYPE;
var WHITESPACE$a = TYPE$A.WhiteSpace;
var COMMENT$8 = TYPE$A.Comment;

var sequence$1 = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$8:
                this.scanner.next();
                continue;

            case WHITESPACE$a:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};

var OffsetToLocation = OffsetToLocation_1;
var SyntaxError$2 = _SyntaxError$1;
var TokenStream$1 = TokenStream_1;
var List$a = List_1;
var tokenize$1 = tokenizer$3;
var constants = _const;
var { findWhiteSpaceStart, cmpStr: cmpStr$2 } = utils$7;
var sequence = sequence$1;
var noop$1 = function() {};

var TYPE$z = constants.TYPE;
var NAME$1 = constants.NAME;
var WHITESPACE$9 = TYPE$z.WhiteSpace;
var COMMENT$7 = TYPE$z.Comment;
var IDENT$g = TYPE$z.Ident;
var FUNCTION$6 = TYPE$z.Function;
var URL$3 = TYPE$z.Url;
var HASH$5 = TYPE$z.Hash;
var PERCENTAGE$3 = TYPE$z.Percentage;
var NUMBER$7 = TYPE$z.Number;
var NUMBERSIGN$3 = 0x0023; // U+0023 NUMBER SIGN (#)
var NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

var create$3 = function createParser(config) {
    var parser = {
        scanner: new TokenStream$1(),
        locationMap: new OffsetToLocation(),

        filename: '<unknown>',
        needPositions: false,
        onParseError: noop$1,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List$a();
        },
        createSingleNodeList: function(node) {
            return new List$a().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType: function(offset) {
            do {
                var type = this.scanner.lookupType(offset++);
                if (type !== WHITESPACE$9) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
                var offset = this.scanner.tokenStart;
                var message = NAME$1[tokenType] + ' is expected';

                // tweak message and offset
                switch (tokenType) {
                    case IDENT$g:
                        // when identifier is expected but there is a function or url
                        if (this.scanner.tokenType === FUNCTION$6 || this.scanner.tokenType === URL$3) {
                            offset = this.scanner.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case HASH$5:
                        if (this.scanner.isDelim(NUMBERSIGN$3)) {
                            this.scanner.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case PERCENTAGE$3:
                        if (this.scanner.tokenType === NUMBER$7) {
                            offset = this.scanner.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;

                    default:
                        // when test type is part of another token show error for current position + 1
                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                            offset = offset + 1;
                        }
                }

                this.error(message, offset);
            }

            this.scanner.next();
        },

        consume: function(tokenType) {
            var value = this.scanner.getTokenValue();

            this.eat(tokenType);

            return value;
        },
        consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

            this.eat(FUNCTION$6);

            return name;
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.locationMap.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        },

        error: function(message, offset) {
            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
                ? this.locationMap.getLocation(offset)
                : this.scanner.eof
                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
                    : this.locationMap.getLocation(this.scanner.tokenStart);

            throw new SyntaxError$2(
                message || 'Unexpected input',
                this.scanner.source,
                location.offset,
                location.line,
                location.column
            );
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var onComment = options.onComment;
        var ast;

        tokenize$1(source, parser.scanner);
        parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$1;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.scanner.forEachToken((type, start, end) => {
                if (type === COMMENT$7) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr$2(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.error();
        }

        return ast;
    };
};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
base64$1.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
base64$1.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = base64$1;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var util$3 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

(function (exports) {
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}(util$3));

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$2 = util$3;
var has$1 = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$2.toSetString(aStr);
    return has$1.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util$2.toSetString(aStr);
    if (has$1.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

arraySet.ArraySet = ArraySet$1;

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util$1 = util$3;

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList$1.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$1.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

mappingList.MappingList = MappingList$1;

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = base64Vlq;
var util = util$3;
var ArraySet = arraySet.ArraySet;
var MappingList = mappingList.MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator$1(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator$1.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator$1.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator$1({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator$1.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator$1.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator$1.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator$1.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator$1.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator$1.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator$1.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator$1.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$1;

var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

var sourceMap$1 = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};

var sourceMap = sourceMap$1;
var hasOwnProperty$7 = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

var create$2 = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty$7.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};

var List$9 = List_1;

var create$1 = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List$9 === false) {
                        node.children = new List$9().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List$9) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};

var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty$6.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty$6.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = config.fields.slice();
    var contextName = config.context;
    var useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        var prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    var breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList
        }
    };
}

var create = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};
    var breakWalk = Symbol('break-walk');
    var skipNode = Symbol('skip-node');

    for (var name in types) {
        if (hasOwnProperty$6.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    var walk = function(root, options) {
        function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                debugger;
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            break: breakWalk,
            skip: skipNode,

            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        var found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        var found = null;

        walk(ast, {
            reverse: true,
            enter: function(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        var found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
};

var List$8 = List_1;

var clone$2 = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List$8) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};

const hasOwnProperty$5 = Object.prototype.hasOwnProperty;
const shape$2 = {
    generic: true,
    types: appendOrAssign,
    atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy$1(value) {
    return isObject(value)
        ? Object.assign({}, value)
        : value;
}

function assign(dest, src) {
    return Object.assign(dest, src);
}

function deepAssign(dest, src) {
    for (const key in src) {
        if (hasOwnProperty$5.call(src, key)) {
            if (isObject(dest[key])) {
                deepAssign(dest[key], copy$1(src[key]));
            } else {
                dest[key] = copy$1(src[key]);
            }
        }
    }

    return dest;
}

function append(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function appendOrAssign(a, b) {
    if (typeof b === 'string') {
        return append(a, b);
    }

    const result = Object.assign({}, a);
    for (let key in b) {
        if (hasOwnProperty$5.call(b, key)) {
            result[key] = append(hasOwnProperty$5.call(a, key) ? a[key] : undefined, b[key]);
        }
    }

    return result;
}

function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);

    return !isObject(result) || Object.keys(result).length
        ? result
        : null;
}

function mix$1(dest, src, shape) {
    for (const key in shape) {
        if (hasOwnProperty$5.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty$5.call(src, key)) {
                    dest[key] = copy$1(src[key]);
                }
            }
        } else if (shape[key]) {
            if (typeof shape[key] === 'function') {
                const fn = shape[key];
                dest[key] = fn({}, dest[key]);
                dest[key] = fn(dest[key] || {}, src[key]);
            } else if (isObject(shape[key])) {
                const result = {};

                for (let name in dest[key]) {
                    result[name] = mix$1({}, dest[key][name], shape[key]);
                }

                for (let name in src[key]) {
                    result[name] = mix$1(result[name] || {}, src[key][name], shape[key]);
                }

                dest[key] = result;
            } else if (Array.isArray(shape[key])) {
                const res = {};
                const innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});

                for (const [name, value] of Object.entries(dest[key] || {})) {
                    res[name] = {};
                    if (value) {
                        mix$1(res[name], value, innerShape);
                    }
                }

                for (const name in src[key]) {
                    if (hasOwnProperty$5.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }

                        if (src[key] && src[key][name]) {
                            mix$1(res[name], src[key][name], innerShape);
                        }
                    }
                }

                dest[key] = res;
            }
        }
    }
    return dest;
}

var mix_1 = (dest, src) => mix$1(dest, src, shape$2);

var List$7 = List_1;
var SyntaxError$1 = _SyntaxError$1;
var TokenStream = TokenStream_1;
var Lexer = Lexer_1;
var definitionSyntax = definitionSyntax$1;
var tokenize = tokenizer$3;
var createParser = create$3;
var createGenerator = create$2;
var createConvertor = create$1;
var createWalker = create;
var clone$1 = clone$2;
var names = names$2;
var mix = mix_1;

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List$7,
        SyntaxError: SyntaxError$1,
        TokenStream: TokenStream,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        definitionSyntax: definitionSyntax,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        tokenize: tokenize,
        parse: parse,
        walk: walk,
        generate: generate,

        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        clone: clone$1,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
}
create$4.create = function(config) {
    return createSyntax(mix({}, config));
};

var require$$0 = {
	"@charset": {
	syntax: "@charset \"<charset>\";",
	groups: [
		"CSS Charsets"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
},
	"@counter-style": {
	syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
	interfaces: [
		"CSSCounterStyleRule"
	],
	groups: [
		"CSS Counter Styles"
	],
	descriptors: {
		"additive-symbols": {
			syntax: "[ <integer> && <symbol> ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		fallback: {
			syntax: "<counter-style-name>",
			media: "all",
			initial: "decimal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		negative: {
			syntax: "<symbol> <symbol>?",
			media: "all",
			initial: "\"-\" hyphen-minus",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		pad: {
			syntax: "<integer> && <symbol>",
			media: "all",
			initial: "0 \"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		prefix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\"\"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		range: {
			syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"speak-as": {
			syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
			media: "all",
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		suffix: {
			syntax: "<symbol>",
			media: "all",
			initial: "\". \"",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		symbols: {
			syntax: "<symbol>+",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		system: {
			syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
			media: "all",
			initial: "symbolic",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
},
	"@document": {
	syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
},
	"@font-face": {
	syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
	interfaces: [
		"CSSFontFaceRule"
	],
	groups: [
		"CSS Fonts"
	],
	descriptors: {
		"font-display": {
			syntax: "[ auto | block | swap | fallback | optional ]",
			media: "visual",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"font-family": {
			syntax: "<family-name>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-feature-settings": {
			syntax: "normal | <feature-tag-value>#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-variation-settings": {
			syntax: "normal | [ <string> <number> ]#",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"font-stretch": {
			syntax: "<font-stretch-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-style": {
			syntax: "normal | italic | oblique <angle>{0,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-weight": {
			syntax: "<font-weight-absolute>{1,2}",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"font-variant": {
			syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
			media: "all",
			initial: "normal",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		src: {
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		"unicode-range": {
			syntax: "<unicode-range>#",
			media: "all",
			initial: "U+0-10FFFF",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
},
	"@font-feature-values": {
	syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
	interfaces: [
		"CSSFontFeatureValuesRule"
	],
	groups: [
		"CSS Fonts"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
},
	"@import": {
	syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
	groups: [
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
},
	"@keyframes": {
	syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
	interfaces: [
		"CSSKeyframeRule",
		"CSSKeyframesRule"
	],
	groups: [
		"CSS Animations"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
},
	"@media": {
	syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSMediaRule",
		"CSSCustomMediaRule"
	],
	groups: [
		"CSS Conditional Rules",
		"Media Queries"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
},
	"@namespace": {
	syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
	groups: [
		"CSS Namespaces"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
},
	"@page": {
	syntax: "@page <page-selector-list> {\n  <page-body>\n}",
	interfaces: [
		"CSSPageRule"
	],
	groups: [
		"CSS Pages"
	],
	descriptors: {
		bleed: {
			syntax: "auto | <length>",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		marks: {
			syntax: "none | [ crop || cross ]",
			media: [
				"visual",
				"paged"
			],
			initial: "none",
			percentages: "no",
			computed: "asSpecified",
			order: "orderOfAppearance",
			status: "standard"
		},
		size: {
			syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
			media: [
				"visual",
				"paged"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecifiedRelativeToAbsoluteLengths",
			order: "orderOfAppearance",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
},
	"@property": {
	syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
	interfaces: [
		"CSS",
		"CSSPropertyRule"
	],
	groups: [
		"CSS Houdini"
	],
	descriptors: {
		syntax: {
			syntax: "<string>",
			media: "all",
			percentages: "no",
			initial: "n/a (required)",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		inherits: {
			syntax: "true | false",
			media: "all",
			percentages: "no",
			initial: "auto",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		},
		"initial-value": {
			syntax: "<string>",
			media: "all",
			initial: "n/a (required)",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "experimental"
		}
	},
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
},
	"@supports": {
	syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSGroupingRule",
		"CSSConditionRule",
		"CSSSupportsRule"
	],
	groups: [
		"CSS Conditional Rules"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
},
	"@viewport": {
	syntax: "@viewport {\n  <group-rule-body>\n}",
	interfaces: [
		"CSSViewportRule"
	],
	groups: [
		"CSS Device Adaptation"
	],
	descriptors: {
		height: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-height",
				"max-height"
			],
			percentages: [
				"min-height",
				"max-height"
			],
			computed: [
				"min-height",
				"max-height"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		"max-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"max-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-height": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToHeightOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-width": {
			syntax: "<viewport-length>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToWidthOfInitialViewport",
			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
			order: "uniqueOrder",
			status: "standard"
		},
		"min-zoom": {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		},
		orientation: {
			syntax: "auto | portrait | landscape",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"user-zoom": {
			syntax: "zoom | fixed",
			media: [
				"visual",
				"continuous"
			],
			initial: "zoom",
			percentages: "referToSizeOfBoundingBox",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		"viewport-fit": {
			syntax: "auto | contain | cover",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "no",
			computed: "asSpecified",
			order: "uniqueOrder",
			status: "standard"
		},
		width: {
			syntax: "<viewport-length>{1,2}",
			media: [
				"visual",
				"continuous"
			],
			initial: [
				"min-width",
				"max-width"
			],
			percentages: [
				"min-width",
				"max-width"
			],
			computed: [
				"min-width",
				"max-width"
			],
			order: "orderOfAppearance",
			status: "standard"
		},
		zoom: {
			syntax: "auto | <number> | <percentage>",
			media: [
				"visual",
				"continuous"
			],
			initial: "auto",
			percentages: "the zoom factor itself",
			computed: "autoNonNegativeOrPercentage",
			order: "uniqueOrder",
			status: "standard"
		}
	},
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
}
};

var all = {
	syntax: "initial | inherit | unset | revert",
	media: "noPracticalMedia",
	inherited: false,
	animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "noPracticalInitialValue",
	appliesto: "allElements",
	computed: "asSpecifiedAppliesToEachProperty",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
};
var animation = {
	syntax: "<single-animation>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-iteration-count",
		"animation-direction",
		"animation-fill-mode",
		"animation-play-state"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"animation-name",
		"animation-duration",
		"animation-timing-function",
		"animation-delay",
		"animation-direction",
		"animation-iteration-count",
		"animation-fill-mode",
		"animation-play-state"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
};
var appearance = {
	syntax: "none | auto | textfield | menulist-button | <compat-auto>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
};
var azimuth = {
	syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
	media: "aural",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Speech"
	],
	initial: "center",
	appliesto: "allElements",
	computed: "normalizedAngle",
	order: "orderOfAppearance",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
};
var background$1 = {
	syntax: "[ <bg-layer> , ]* <final-bg-layer>",
	media: "visual",
	inherited: false,
	animationType: [
		"background-color",
		"background-image",
		"background-clip",
		"background-position",
		"background-size",
		"background-repeat",
		"background-attachment"
	],
	percentages: [
		"background-position",
		"background-size"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	appliesto: "allElements",
	computed: [
		"background-image",
		"background-position",
		"background-size",
		"background-repeat",
		"background-origin",
		"background-clip",
		"background-attachment",
		"background-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
};
var border$1 = {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-color",
		"border-style",
		"border-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-width",
		"border-style",
		"border-color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
};
var bottom = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
};
var clear = {
	syntax: "none | left | right | both | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
};
var clip = {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: false,
	animationType: "rectangle",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "absolutelyPositionedElements",
	computed: "autoOrRectangle",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
};
var color$2 = {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "variesFromBrowserToBrowser",
	appliesto: "allElements",
	computed: "translucentValuesRGBAOtherwiseRGB",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
};
var columns = {
	syntax: "<'column-width'> || <'column-count'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-width",
		"column-count"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-width",
		"column-count"
	],
	appliesto: "blockContainersExceptTableWrappers",
	computed: [
		"column-width",
		"column-count"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
};
var contain = {
	syntax: "none | strict | content | [ size || layout || style || paint ]",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Containment"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
};
var content = {
	syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "normal",
	appliesto: "beforeAndAfterPseudos",
	computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
};
var cursor = {
	syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
};
var direction = {
	syntax: "ltr | rtl",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "ltr",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
};
var display = {
	syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Display"
	],
	initial: "inline",
	appliesto: "allElements",
	computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
};
var filter = {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
};
var flex = {
	syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
	media: "visual",
	inherited: false,
	animationType: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	appliesto: "flexItemsAndInFlowPseudos",
	computed: [
		"flex-grow",
		"flex-shrink",
		"flex-basis"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
};
var float = {
	syntax: "left | right | none | inline-start | inline-end",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "none",
	appliesto: "allElementsNoEffectIfDisplayNone",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
};
var font$1 = {
	syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
	media: "visual",
	inherited: true,
	animationType: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	percentages: [
		"font-size",
		"line-height"
	],
	groups: [
		"CSS Fonts"
	],
	initial: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	appliesto: "allElements",
	computed: [
		"font-style",
		"font-variant",
		"font-weight",
		"font-stretch",
		"font-size",
		"line-height",
		"font-family"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
};
var gap = {
	syntax: "<'row-gap'> <'column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"row-gap",
		"column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"row-gap",
		"column-gap"
	],
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: [
		"row-gap",
		"column-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
};
var grid = {
	syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-auto-rows",
		"grid-auto-columns"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-rows",
		"grid-template-columns",
		"grid-template-areas",
		"grid-auto-rows",
		"grid-auto-columns",
		"grid-auto-flow",
		"grid-column-gap",
		"grid-row-gap",
		"column-gap",
		"row-gap"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
};
var height = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAutoOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
};
var hyphens = {
	syntax: "none | manual | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "manual",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
};
var inset = {
	syntax: "<'top'>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
};
var isolation = {
	syntax: "auto | isolate",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
};
var left = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
};
var margin = {
	syntax: "[ <length> | <percentage> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: [
		"margin-bottom",
		"margin-left",
		"margin-right",
		"margin-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
};
var mask = {
	syntax: "<mask-layer>#",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	percentages: [
		"mask-position"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-image",
		"mask-mode",
		"mask-repeat",
		"mask-position",
		"mask-clip",
		"mask-origin",
		"mask-size",
		"mask-composite"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
};
var offset = {
	syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	percentages: [
		"offset-position",
		"offset-distance",
		"offset-anchor"
	],
	groups: [
		"CSS Motion Path"
	],
	initial: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	appliesto: "transformableElements",
	computed: [
		"offset-position",
		"offset-path",
		"offset-distance",
		"offset-anchor",
		"offset-rotate"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
};
var opacity = {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "1.0",
	appliesto: "allElements",
	computed: "specifiedValueClipped0To1",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
};
var order = {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
};
var orphans = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
};
var outline = {
	syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: [
		"outline-color",
		"outline-style",
		"outline-width"
	],
	appliesto: "allElements",
	computed: [
		"outline-color",
		"outline-width",
		"outline-style"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
};
var overflow = {
	syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: [
		"overflow-x",
		"overflow-y"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
};
var padding = {
	syntax: "[ <length> | <percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: [
		"padding-bottom",
		"padding-left",
		"padding-right",
		"padding-top"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
};
var perspective = {
	syntax: "none | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "absoluteLengthOrNone",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
};
var position$1 = {
	syntax: "static | relative | absolute | sticky | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "static",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
};
var quotes = {
	syntax: "none | auto | [ <string> <string> ]+",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Generated Content"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
};
var resize = {
	syntax: "none | both | horizontal | vertical | block | inline",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
};
var right = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
};
var rotate = {
	syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
};
var scale = {
	syntax: "none | <number>{1,3}",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
};
var top = {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToContainingBlockHeight",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
};
var transform = {
	syntax: "none | <transform-list>",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
};
var transition = {
	syntax: "<single-transition>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	appliesto: "allElementsAndPseudos",
	computed: [
		"transition-delay",
		"transition-duration",
		"transition-property",
		"transition-timing-function"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
};
var translate = {
	syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
	media: "visual",
	inherited: false,
	animationType: "transform",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
};
var visibility = {
	syntax: "visible | hidden | collapse",
	media: "visual",
	inherited: true,
	animationType: "visibility",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "visible",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
};
var widows = {
	syntax: "<integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "2",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
};
var width = {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAutoOrAbsoluteLength",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
};
var zoom = {
	syntax: "normal | reset | <number> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
};
var require$$1 = {
	"--*": {
	syntax: "<declaration-value>",
	media: "all",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Variables"
	],
	initial: "seeProse",
	appliesto: "allElements",
	computed: "asSpecifiedWithVarsSubstituted",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
},
	"-ms-accelerator": {
	syntax: "false | true",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "false",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
},
	"-ms-block-progression": {
	syntax: "tb | rl | bt | lr",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "tb",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
},
	"-ms-content-zoom-chaining": {
	syntax: "none | chained",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
},
	"-ms-content-zooming": {
	syntax: "none | zoom",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "zoomForTheTopLevelNoneForTheRest",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
},
	"-ms-content-zoom-limit": {
	syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-limit-max",
		"-ms-content-zoom-limit-min"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
},
	"-ms-content-zoom-limit-max": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "maxZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "400%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
},
	"-ms-content-zoom-limit-min": {
	syntax: "<percentage>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "minZoomFactor",
	groups: [
		"Microsoft Extensions"
	],
	initial: "100%",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
},
	"-ms-content-zoom-snap": {
	syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-content-zoom-snap-type",
		"-ms-content-zoom-snap-points"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
},
	"-ms-content-zoom-snap-points": {
	syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0%, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
},
	"-ms-content-zoom-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
},
	"-ms-filter": {
	syntax: "<string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "\"\"",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
},
	"-ms-flow-from": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
},
	"-ms-flow-into": {
	syntax: "[ none | <custom-ident> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "iframeElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
},
	"-ms-grid-columns": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
},
	"-ms-grid-rows": {
	syntax: "none | <track-list> | <auto-track-list>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
},
	"-ms-high-contrast-adjust": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
},
	"-ms-hyphenate-limit-chars": {
	syntax: "auto | <integer>{1,3}",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
},
	"-ms-hyphenate-limit-lines": {
	syntax: "no-limit | <integer>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "no-limit",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
},
	"-ms-hyphenate-limit-zone": {
	syntax: "<percentage> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToLineBoxWidth",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
},
	"-ms-ime-align": {
	syntax: "auto | after",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
},
	"-ms-overflow-style": {
	syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
},
	"-ms-scrollbar-3dlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
},
	"-ms-scrollbar-arrow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ButtonText",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
},
	"-ms-scrollbar-base-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
},
	"-ms-scrollbar-darkshadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
},
	"-ms-scrollbar-face-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDFace",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
},
	"-ms-scrollbar-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDHighlight",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
},
	"-ms-scrollbar-shadow-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "ThreeDDarkShadow",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
},
	"-ms-scrollbar-track-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "Scrollbar",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
},
	"-ms-scroll-chaining": {
	syntax: "chained | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "chained",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
},
	"-ms-scroll-limit": {
	syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-limit-x-min",
		"-ms-scroll-limit-y-min",
		"-ms-scroll-limit-x-max",
		"-ms-scroll-limit-y-max"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
},
	"-ms-scroll-limit-x-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
},
	"-ms-scroll-limit-x-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
},
	"-ms-scroll-limit-y-max": {
	syntax: "auto | <length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
},
	"-ms-scroll-limit-y-min": {
	syntax: "<length>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
},
	"-ms-scroll-rails": {
	syntax: "none | railed",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "railed",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
},
	"-ms-scroll-snap-points-x": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
},
	"-ms-scroll-snap-points-y": {
	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "snapInterval(0px, 100%)",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
},
	"-ms-scroll-snap-type": {
	syntax: "none | proximity | mandatory",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
},
	"-ms-scroll-snap-x": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-x"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
},
	"-ms-scroll-snap-y": {
	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: [
		"-ms-scroll-snap-type",
		"-ms-scroll-snap-points-y"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
},
	"-ms-scroll-translation": {
	syntax: "none | vertical-to-horizontal",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
},
	"-ms-text-autospace": {
	syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
},
	"-ms-touch-select": {
	syntax: "grippers | none",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "grippers",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
},
	"-ms-user-select": {
	syntax: "none | element | text",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "text",
	appliesto: "nonReplacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
},
	"-ms-wrap-flow": {
	syntax: "auto | both | start | end | maximum | clear",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
},
	"-ms-wrap-margin": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "0",
	appliesto: "exclusionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
},
	"-ms-wrap-through": {
	syntax: "wrap | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Microsoft Extensions"
	],
	initial: "wrap",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
},
	"-moz-appearance": {
	syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-moz-binding": {
	syntax: "<url> | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
},
	"-moz-border-bottom-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
},
	"-moz-border-left-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
},
	"-moz-border-right-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
},
	"-moz-border-top-colors": {
	syntax: "<color>+ | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
},
	"-moz-context-properties": {
	syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElementsThatCanReferenceImages",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
},
	"-moz-float-edge": {
	syntax: "border-box | content-box | margin-box | padding-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "content-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
},
	"-moz-force-broken-image-icon": {
	syntax: "<integer [0,1]>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "images",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
},
	"-moz-image-region": {
	syntax: "<shape> | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "xulImageElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
},
	"-moz-orient": {
	syntax: "inline | block | horizontal | vertical",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "inline",
	appliesto: "anyElementEffectOnProgressAndMeter",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
},
	"-moz-outline-radius": {
	syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	percentages: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	groups: [
		"Mozilla Extensions"
	],
	initial: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	appliesto: "allElements",
	computed: [
		"-moz-outline-radius-topleft",
		"-moz-outline-radius-topright",
		"-moz-outline-radius-bottomright",
		"-moz-outline-radius-bottomleft"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
},
	"-moz-outline-radius-bottomleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
},
	"-moz-outline-radius-bottomright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
},
	"-moz-outline-radius-topleft": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
},
	"-moz-outline-radius-topright": {
	syntax: "<outline-radius>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"Mozilla Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
},
	"-moz-stack-sizing": {
	syntax: "ignore | stretch-to-fit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "stretch-to-fit",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
},
	"-moz-text-blink": {
	syntax: "none | blink",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
},
	"-moz-user-focus": {
	syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
},
	"-moz-user-input": {
	syntax: "auto | none | enabled | disabled",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
},
	"-moz-user-modify": {
	syntax: "read-only | read-write | write-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
},
	"-moz-window-dragging": {
	syntax: "drag | no-drag",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "drag",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
},
	"-moz-window-shadow": {
	syntax: "default | menu | tooltip | sheet | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "default",
	appliesto: "allElementsCreatingNativeWindows",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
},
	"-webkit-appearance": {
	syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "noneButOverriddenInUserAgentCSS",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
},
	"-webkit-border-before": {
	syntax: "<'border-width'> || <'border-style'> || <'color'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: [
		"-webkit-border-before-width"
	],
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"color"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
},
	"-webkit-border-before-color": {
	syntax: "<'color'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-border-before-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"WebKit Extensions"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"-webkit-box-reflect": {
	syntax: "[ above | below | right | left ]? <length>? <image>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
},
	"-webkit-line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"WebKit Extensions",
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
},
	"-webkit-mask": {
	syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-mask-image",
		"-webkit-mask-repeat",
		"-webkit-mask-attachment",
		"-webkit-mask-position",
		"-webkit-mask-origin",
		"-webkit-mask-clip"
	],
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
},
	"-webkit-mask-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
},
	"-webkit-mask-clip": {
	syntax: "[ <box> | border | padding | content | text ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "border",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"-webkit-mask-composite": {
	syntax: "<composite-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "source-over",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
},
	"-webkit-mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteURIOrNone",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"-webkit-mask-origin": {
	syntax: "[ <box> | border | padding | content ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "padding",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"-webkit-mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"-webkit-mask-position-x": {
	syntax: "[ <length-percentage> | left | center | right ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
},
	"-webkit-mask-position-y": {
	syntax: "[ <length-percentage> | top | center | bottom ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfElement",
	groups: [
		"WebKit Extensions"
	],
	initial: "0%",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
},
	"-webkit-mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"-webkit-mask-repeat-x": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
},
	"-webkit-mask-repeat-y": {
	syntax: "repeat | no-repeat | space | round",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "absoluteLengthOrPercentage",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
},
	"-webkit-mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"-webkit-overflow-scrolling": {
	syntax: "auto | touch",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
},
	"-webkit-tap-highlight-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "black",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
},
	"-webkit-text-fill-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
},
	"-webkit-text-stroke": {
	syntax: "<length> || <color>",
	media: "visual",
	inherited: true,
	animationType: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	appliesto: "allElements",
	computed: [
		"-webkit-text-stroke-width",
		"-webkit-text-stroke-color"
	],
	order: "canonicalOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
},
	"-webkit-text-stroke-color": {
	syntax: "<color>",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
},
	"-webkit-text-stroke-width": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "absoluteLength",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
},
	"-webkit-touch-callout": {
	syntax: "default | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "default",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
},
	"-webkit-user-modify": {
	syntax: "read-only | read-write | read-write-plaintext-only",
	media: "interactive",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"WebKit Extensions"
	],
	initial: "read-only",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard"
},
	"align-content": {
	syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multilineFlexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
},
	"align-items": {
	syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
},
	"align-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
	computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
},
	"align-tracks": {
	syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
},
	all: all,
	animation: animation,
	"animation-delay": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
},
	"animation-direction": {
	syntax: "<single-animation-direction>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "normal",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
},
	"animation-duration": {
	syntax: "<time>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
},
	"animation-fill-mode": {
	syntax: "<single-animation-fill-mode>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
},
	"animation-iteration-count": {
	syntax: "<single-animation-iteration-count>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "1",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
},
	"animation-name": {
	syntax: "[ none | <keyframes-name> ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "none",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
},
	"animation-play-state": {
	syntax: "<single-animation-play-state>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "running",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
},
	"animation-timing-function": {
	syntax: "<timing-function>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Animations"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
},
	appearance: appearance,
	"aspect-ratio": {
	syntax: "auto | <ratio>",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
},
	azimuth: azimuth,
	"backdrop-filter": {
	syntax: "none | <filter-function-list>",
	media: "visual",
	inherited: false,
	animationType: "filterList",
	percentages: "no",
	groups: [
		"Filter Effects"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
},
	"backface-visibility": {
	syntax: "visible | hidden",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "visible",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
},
	background: background$1,
	"background-attachment": {
	syntax: "<attachment>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "scroll",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
},
	"background-blend-mode": {
	syntax: "<blend-mode>#",
	media: "none",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
},
	"background-clip": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "border-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
},
	"background-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "transparent",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
},
	"background-image": {
	syntax: "<bg-image>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
},
	"background-origin": {
	syntax: "<box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
},
	"background-position": {
	syntax: "<bg-position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0% 0%",
	appliesto: "allElements",
	computed: "listEachItemTwoKeywordsOriginOffsets",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
},
	"background-position-x": {
	syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "left",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
},
	"background-position-y": {
	syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "top",
	appliesto: "allElements",
	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
},
	"background-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "repeat",
	appliesto: "allElements",
	computed: "listEachItemHasTwoKeywordsOnePerDimension",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
},
	"background-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "relativeToBackgroundPositioningArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "auto auto",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
},
	"block-overflow": {
	syntax: "clip | ellipsis | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "clip",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"block-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
},
	border: border$1,
	"border-block": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
},
	"border-block-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
},
	"border-block-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
},
	"border-block-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
},
	"border-block-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-end-color",
		"border-block-end-style",
		"border-block-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
},
	"border-block-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
},
	"border-block-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
},
	"border-block-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
},
	"border-block-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-block-start-color",
		"border-block-start-style",
		"border-block-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-block-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
},
	"border-block-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
},
	"border-block-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
},
	"border-block-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
},
	"border-bottom": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-bottom-style",
		"border-bottom-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-bottom-style",
		"border-bottom-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
},
	"border-bottom-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
},
	"border-bottom-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
},
	"border-bottom-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
},
	"border-bottom-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
},
	"border-bottom-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
},
	"border-collapse": {
	syntax: "collapse | separate",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "separate",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
},
	"border-color": {
	syntax: "<color>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-color",
		"border-right-color",
		"border-bottom-color",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-color",
		"border-left-color",
		"border-right-color",
		"border-top-color"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
},
	"border-end-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
},
	"border-end-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
},
	"border-image": {
	syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"border-image-slice",
		"border-image-width"
	],
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-image-source",
		"border-image-slice",
		"border-image-width",
		"border-image-outset",
		"border-image-repeat"
	],
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: [
		"border-image-outset",
		"border-image-repeat",
		"border-image-slice",
		"border-image-source",
		"border-image-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
},
	"border-image-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
},
	"border-image-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "stretch",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
},
	"border-image-slice": {
	syntax: "<number-percentage>{1,4} && fill?",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToSizeOfBorderImage",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "100%",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
	order: "percentagesOrLengthsFollowedByFill",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
},
	"border-image-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "noneOrImageWithAbsoluteURI",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
},
	"border-image-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToWidthOrHeightOfBorderImageArea",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "1",
	appliesto: "allElementsExceptTableElementsWhenCollapse",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
},
	"border-inline": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
},
	"border-inline-end": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-end-color",
		"border-inline-end-style",
		"border-inline-end-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-end-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
},
	"border-inline-color": {
	syntax: "<'border-top-color'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
},
	"border-inline-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
},
	"border-inline-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
},
	"border-inline-end-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
},
	"border-inline-end-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
},
	"border-inline-end-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
},
	"border-inline-start": {
	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-inline-start-color",
		"border-inline-start-style",
		"border-inline-start-width"
	],
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: [
		"border-width",
		"border-style",
		"color"
	],
	appliesto: "allElements",
	computed: [
		"border-width",
		"border-style",
		"border-inline-start-color"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
},
	"border-inline-start-color": {
	syntax: "<'border-top-color'>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
},
	"border-inline-start-style": {
	syntax: "<'border-top-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Logical Properties"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
},
	"border-inline-start-width": {
	syntax: "<'border-top-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
},
	"border-left": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-left-color",
		"border-left-style",
		"border-left-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	appliesto: "allElements",
	computed: [
		"border-left-width",
		"border-left-style",
		"border-left-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
},
	"border-left-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
},
	"border-left-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
},
	"border-left-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
},
	"border-radius": {
	syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-left-radius",
		"border-top-right-radius",
		"border-bottom-right-radius",
		"border-bottom-left-radius"
	],
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: [
		"border-bottom-left-radius",
		"border-bottom-right-radius",
		"border-top-left-radius",
		"border-top-right-radius"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
},
	"border-right": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-right-color",
		"border-right-style",
		"border-right-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	appliesto: "allElements",
	computed: [
		"border-right-width",
		"border-right-style",
		"border-right-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
},
	"border-right-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
},
	"border-right-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
},
	"border-right-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
},
	"border-spacing": {
	syntax: "<length> <length>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "0",
	appliesto: "tableElements",
	computed: "twoAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
},
	"border-start-end-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
},
	"border-start-start-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
},
	"border-style": {
	syntax: "<line-style>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-style",
		"border-right-style",
		"border-bottom-style",
		"border-left-style"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-style",
		"border-left-style",
		"border-right-style",
		"border-top-style"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
},
	"border-top": {
	syntax: "<line-width> || <line-style> || <color>",
	media: "visual",
	inherited: false,
	animationType: [
		"border-top-color",
		"border-top-style",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	appliesto: "allElements",
	computed: [
		"border-top-width",
		"border-top-style",
		"border-top-color"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
},
	"border-top-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
},
	"border-top-left-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
},
	"border-top-right-radius": {
	syntax: "<length-percentage>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfBorderBox",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "0",
	appliesto: "allElementsUAsNotRequiredWhenCollapse",
	computed: "twoAbsoluteLengthOrPercentages",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
},
	"border-top-style": {
	syntax: "<line-style>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
},
	"border-top-width": {
	syntax: "<line-width>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
},
	"border-width": {
	syntax: "<line-width>{1,4}",
	media: "visual",
	inherited: false,
	animationType: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: [
		"border-top-width",
		"border-right-width",
		"border-bottom-width",
		"border-left-width"
	],
	appliesto: "allElements",
	computed: [
		"border-bottom-width",
		"border-left-width",
		"border-right-width",
		"border-top-width"
	],
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
},
	bottom: bottom,
	"box-align": {
	syntax: "start | center | end | baseline | stretch",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "stretch",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
},
	"box-decoration-break": {
	syntax: "slice | clone",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "slice",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
},
	"box-direction": {
	syntax: "normal | reverse | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "normal",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
},
	"box-flex": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "0",
	appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
},
	"box-flex-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "inFlowChildrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
},
	"box-lines": {
	syntax: "single | multiple",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "single",
	appliesto: "boxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
},
	"box-ordinal-group": {
	syntax: "<integer>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "1",
	appliesto: "childrenOfBoxElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
},
	"box-orient": {
	syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "inlineAxisHorizontalInXUL",
	appliesto: "elementsWithDisplayBoxOrInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
},
	"box-pack": {
	syntax: "start | center | end | justify",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions",
		"WebKit Extensions"
	],
	initial: "start",
	appliesto: "elementsWithDisplayMozBoxMozInlineBox",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
},
	"box-shadow": {
	syntax: "none | <shadow>#",
	media: "visual",
	inherited: false,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Backgrounds and Borders"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "absoluteLengthsSpecifiedColorAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
},
	"box-sizing": {
	syntax: "content-box | border-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "content-box",
	appliesto: "allElementsAcceptingWidthOrHeight",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
},
	"break-after": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
},
	"break-before": {
	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
},
	"break-inside": {
	syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fragmentation"
	],
	initial: "auto",
	appliesto: "blockLevelElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
},
	"caption-side": {
	syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "top",
	appliesto: "tableCaptionElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
},
	"caret-color": {
	syntax: "auto | <color>",
	media: "interactive",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asAutoOrColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
},
	clear: clear,
	clip: clip,
	"clip-path": {
	syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
},
	color: color$2,
	"color-adjust": {
	syntax: "economy | exact",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Color"
	],
	initial: "economy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
},
	"column-count": {
	syntax: "<integer> | auto",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
},
	"column-fill": {
	syntax: "auto | balance | balance-all",
	media: "visualInContinuousMediaNoEffectInOverflowColumns",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "balance",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
},
	"column-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"column-rule": {
	syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: [
		"column-rule-width",
		"column-rule-style",
		"column-rule-color"
	],
	appliesto: "multicolElements",
	computed: [
		"column-rule-color",
		"column-rule-style",
		"column-rule-width"
	],
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
},
	"column-rule-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "currentcolor",
	appliesto: "multicolElements",
	computed: "computedColor",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
},
	"column-rule-style": {
	syntax: "<'border-style'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "multicolElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
},
	"column-rule-width": {
	syntax: "<'border-width'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "medium",
	appliesto: "multicolElements",
	computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
},
	"column-span": {
	syntax: "none | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "none",
	appliesto: "inFlowBlockLevelElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
},
	"column-width": {
	syntax: "<length> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Columns"
	],
	initial: "auto",
	appliesto: "blockContainersExceptTableWrappers",
	computed: "absoluteLengthZeroOrLarger",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
},
	columns: columns,
	contain: contain,
	content: content,
	"counter-increment": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
},
	"counter-reset": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
},
	"counter-set": {
	syntax: "[ <custom-ident> <integer>? ]+ | none",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Counter Styles"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
},
	cursor: cursor,
	direction: direction,
	display: display,
	"empty-cells": {
	syntax: "show | hide",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "show",
	appliesto: "tableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
},
	filter: filter,
	flex: flex,
	"flex-basis": {
	syntax: "content | <'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToFlexContainersInnerMainSize",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "auto",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
},
	"flex-direction": {
	syntax: "row | row-reverse | column | column-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "row",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
},
	"flex-flow": {
	syntax: "<'flex-direction'> || <'flex-wrap'>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: [
		"flex-direction",
		"flex-wrap"
	],
	appliesto: "flexContainers",
	computed: [
		"flex-direction",
		"flex-wrap"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
},
	"flex-grow": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "0",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
},
	"flex-shrink": {
	syntax: "<number>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "1",
	appliesto: "flexItemsAndInFlowPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
},
	"flex-wrap": {
	syntax: "nowrap | wrap | wrap-reverse",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Flexible Box Layout"
	],
	initial: "nowrap",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
},
	float: float,
	font: font$1,
	"font-family": {
	syntax: "[ <family-name> | <generic-family> ]#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "dependsOnUserAgent",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
},
	"font-feature-settings": {
	syntax: "normal | <feature-tag-value>#",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
},
	"font-kerning": {
	syntax: "auto | normal | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
},
	"font-language-override": {
	syntax: "normal | <string>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
},
	"font-optical-sizing": {
	syntax: "auto | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
},
	"font-variation-settings": {
	syntax: "normal | [ <string> <number> ]#",
	media: "visual",
	inherited: true,
	animationType: "transform",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
},
	"font-size": {
	syntax: "<absolute-size> | <relative-size> | <length-percentage>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToParentElementsFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
},
	"font-size-adjust": {
	syntax: "none | <number>",
	media: "visual",
	inherited: true,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
},
	"font-smooth": {
	syntax: "auto | never | always | <absolute-size> | <length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
},
	"font-stretch": {
	syntax: "<font-stretch-absolute>",
	media: "visual",
	inherited: true,
	animationType: "fontStretch",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
},
	"font-style": {
	syntax: "normal | italic | oblique <angle>?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
},
	"font-synthesis": {
	syntax: "none | [ weight || style ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "weight style",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
},
	"font-variant": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
},
	"font-variant-alternates": {
	syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
},
	"font-variant-caps": {
	syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
},
	"font-variant-east-asian": {
	syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
},
	"font-variant-ligatures": {
	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
},
	"font-variant-numeric": {
	syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
},
	"font-variant-position": {
	syntax: "normal | sub | super",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
},
	"font-weight": {
	syntax: "<font-weight-absolute> | bolder | lighter",
	media: "visual",
	inherited: true,
	animationType: "fontWeight",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
},
	gap: gap,
	grid: grid,
	"grid-area": {
	syntax: "<grid-line> [ / <grid-line> ]{0,3}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-column-start",
		"grid-row-end",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
},
	"grid-auto-columns": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
},
	"grid-auto-flow": {
	syntax: "[ row | column ] || dense",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "row",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
},
	"grid-auto-rows": {
	syntax: "<track-size>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
},
	"grid-column": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-column-start",
		"grid-column-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-column-start",
		"grid-column-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
},
	"grid-column-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
},
	"grid-column-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
},
	"grid-column-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
},
	"grid-gap": {
	syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
	media: "visual",
	inherited: false,
	animationType: [
		"grid-row-gap",
		"grid-column-gap"
	],
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-gap",
		"grid-column-gap"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-row-gap",
		"grid-column-gap"
	],
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
},
	"grid-row": {
	syntax: "<grid-line> [ / <grid-line> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-row-start",
		"grid-row-end"
	],
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: [
		"grid-row-start",
		"grid-row-end"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
},
	"grid-row-end": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
},
	"grid-row-gap": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "0",
	appliesto: "gridContainers",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"grid-row-start": {
	syntax: "<grid-line>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "auto",
	appliesto: "gridItemsAndBoxesWithinGridContainer",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
},
	"grid-template": {
	syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: [
		"grid-template-columns",
		"grid-template-rows"
	],
	groups: [
		"CSS Grid Layout"
	],
	initial: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	appliesto: "gridContainers",
	computed: [
		"grid-template-columns",
		"grid-template-rows",
		"grid-template-areas"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
},
	"grid-template-areas": {
	syntax: "none | <string>+",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
},
	"grid-template-columns": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
},
	"grid-template-rows": {
	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpcDifferenceLpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Grid Layout"
	],
	initial: "none",
	appliesto: "gridContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
},
	"hanging-punctuation": {
	syntax: "none | [ first || [ force-end | allow-end ] || last ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
},
	height: height,
	hyphens: hyphens,
	"image-orientation": {
	syntax: "from-image | <angle> | [ <angle>? flip ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "from-image",
	appliesto: "allElements",
	computed: "angleRoundedToNextQuarter",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
},
	"image-rendering": {
	syntax: "auto | crisp-edges | pixelated",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
},
	"image-resolution": {
	syntax: "[ from-image || <resolution> ] && snap?",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "1dppx",
	appliesto: "allElements",
	computed: "asSpecifiedWithExceptionOfResolution",
	order: "uniqueOrder",
	status: "experimental"
},
	"ime-mode": {
	syntax: "auto | normal | active | inactive | disabled",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "textFields",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
},
	"initial-letter": {
	syntax: "normal | [ <number> <integer>? ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "normal",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
},
	"initial-letter-align": {
	syntax: "[ auto | alphabetic | hanging | ideographic ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Inline"
	],
	initial: "auto",
	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
},
	"inline-size": {
	syntax: "<'width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsWidthAndHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
},
	inset: inset,
	"inset-block": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
},
	"inset-block-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
},
	"inset-block-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalHeightOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
},
	"inset-inline": {
	syntax: "<'top'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
},
	"inset-inline-end": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
},
	"inset-inline-start": {
	syntax: "<'top'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "sameAsBoxOffsets",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
},
	isolation: isolation,
	"justify-content": {
	syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "flexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
},
	"justify-items": {
	syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "legacy",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
},
	"justify-self": {
	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "auto",
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
},
	"justify-tracks": {
	syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "normal",
	appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
},
	left: left,
	"letter-spacing": {
	syntax: "normal | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "optimumValueOfAbsoluteLengthOrNormal",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
},
	"line-break": {
	syntax: "auto | loose | normal | strict | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
},
	"line-clamp": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"line-height": {
	syntax: "normal | <number> | <length> | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "numberOrLength",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Fonts"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "absoluteLengthOrAsSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
},
	"line-height-step": {
	syntax: "<length>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Fonts"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "absoluteLength",
	order: "perGrammar",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
},
	"list-style": {
	syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: [
		"list-style-type",
		"list-style-position",
		"list-style-image"
	],
	appliesto: "listItems",
	computed: [
		"list-style-image",
		"list-style-position",
		"list-style-type"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
},
	"list-style-image": {
	syntax: "<url> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "none",
	appliesto: "listItems",
	computed: "noneOrImageWithAbsoluteURI",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
},
	"list-style-position": {
	syntax: "inside | outside",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "outside",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
},
	"list-style-type": {
	syntax: "<counter-style> | <string> | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Lists and Counters"
	],
	initial: "disc",
	appliesto: "listItems",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
},
	margin: margin,
	"margin-block": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
},
	"margin-block-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
},
	"margin-block-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
},
	"margin-bottom": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
},
	"margin-inline": {
	syntax: "<'margin-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
},
	"margin-inline-end": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
},
	"margin-inline-start": {
	syntax: "<'margin-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "dependsOnLayoutModel",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsMargin",
	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
},
	"margin-left": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
},
	"margin-right": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
},
	"margin-top": {
	syntax: "<length> | <percentage> | auto",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
},
	"margin-trim": {
	syntax: "none | in-flow | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "blockContainersAndMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
},
	mask: mask,
	"mask-border": {
	syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
	media: "visual",
	inherited: false,
	animationType: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	percentages: [
		"mask-border-slice",
		"mask-border-width"
	],
	groups: [
		"CSS Masking"
	],
	initial: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	appliesto: "allElementsSVGContainerElements",
	computed: [
		"mask-border-mode",
		"mask-border-outset",
		"mask-border-repeat",
		"mask-border-slice",
		"mask-border-source",
		"mask-border-width"
	],
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
},
	"mask-border-mode": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "alpha",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
},
	"mask-border-outset": {
	syntax: "[ <length> | <number> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
},
	"mask-border-repeat": {
	syntax: "[ stretch | repeat | round | space ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "stretch",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
},
	"mask-border-slice": {
	syntax: "<number-percentage>{1,4} fill?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "referToSizeOfMaskBorderImage",
	groups: [
		"CSS Masking"
	],
	initial: "0",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
},
	"mask-border-source": {
	syntax: "none | <image>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
},
	"mask-border-width": {
	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToMaskBorderImageArea",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
},
	"mask-clip": {
	syntax: "[ <geometry-box> | no-clip ]#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
},
	"mask-composite": {
	syntax: "<compositing-operator>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "add",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
},
	"mask-image": {
	syntax: "<mask-reference>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "none",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedURLsAbsolute",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
},
	"mask-mode": {
	syntax: "<masking-mode>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "match-source",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
},
	"mask-origin": {
	syntax: "<geometry-box>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "border-box",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
},
	"mask-position": {
	syntax: "<position>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToSizeOfMaskPaintingArea",
	groups: [
		"CSS Masking"
	],
	initial: "center",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoKeywordsForOriginAndOffsets",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
},
	"mask-repeat": {
	syntax: "<repeat-style>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "no-repeat",
	appliesto: "allElementsSVGContainerElements",
	computed: "consistsOfTwoDimensionKeywords",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
},
	"mask-size": {
	syntax: "<bg-size>#",
	media: "visual",
	inherited: false,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "auto",
	appliesto: "allElementsSVGContainerElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
},
	"mask-type": {
	syntax: "luminance | alpha",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Masking"
	],
	initial: "luminance",
	appliesto: "maskElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
},
	"masonry-auto-flow": {
	syntax: "[ pack | next ] || [ definite-first | ordered ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Grid Layout"
	],
	initial: "pack",
	appliesto: "gridContainersWithMasonryLayout",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
},
	"math-style": {
	syntax: "normal | compact",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"MathML"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
},
	"max-block-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
},
	"max-height": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
},
	"max-inline-size": {
	syntax: "<'max-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMaxWidthAndMaxHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
},
	"max-lines": {
	syntax: "none | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "none",
	appliesto: "blockContainersExceptMultiColumnContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "experimental"
},
	"max-width": {
	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "none",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
},
	"min-block-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "blockSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
},
	"min-height": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableColumns",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
},
	"min-inline-size": {
	syntax: "<'min-width'>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "inlineSizeOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "sameAsWidthAndHeight",
	computed: "sameAsMinWidthAndMinHeight",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
},
	"min-width": {
	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "allElementsButNonReplacedAndTableRows",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
},
	"mix-blend-mode": {
	syntax: "<blend-mode>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Compositing and Blending"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
},
	"object-fit": {
	syntax: "fill | contain | cover | none | scale-down",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Images"
	],
	initial: "fill",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
},
	"object-position": {
	syntax: "<position>",
	media: "visual",
	inherited: true,
	animationType: "repeatableListOfSimpleListOfLpc",
	percentages: "referToWidthAndHeightOfElement",
	groups: [
		"CSS Images"
	],
	initial: "50% 50%",
	appliesto: "replacedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
},
	offset: offset,
	"offset-anchor": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "relativeToWidthAndHeight",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard"
},
	"offset-distance": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToTotalPathLength",
	groups: [
		"CSS Motion Path"
	],
	initial: "0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
},
	"offset-path": {
	syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "none",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
},
	"offset-position": {
	syntax: "auto | <position>",
	media: "visual",
	inherited: false,
	animationType: "position",
	percentages: "referToSizeOfContainingBlock",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "perGrammar",
	status: "experimental"
},
	"offset-rotate": {
	syntax: "[ auto | reverse ] || <angle>",
	media: "visual",
	inherited: false,
	animationType: "angleOrBasicShapeOrPath",
	percentages: "no",
	groups: [
		"CSS Motion Path"
	],
	initial: "auto",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
},
	opacity: opacity,
	order: order,
	orphans: orphans,
	outline: outline,
	"outline-color": {
	syntax: "<color> | invert",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "invertOrCurrentColor",
	appliesto: "allElements",
	computed: "invertForTranslucentColorRGBAOtherwiseRGB",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
},
	"outline-offset": {
	syntax: "<length>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
},
	"outline-style": {
	syntax: "auto | <'border-style'>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
},
	"outline-width": {
	syntax: "<line-width>",
	media: [
		"visual",
		"interactive"
	],
	inherited: false,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "medium",
	appliesto: "allElements",
	computed: "absoluteLength0ForNone",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
},
	overflow: overflow,
	"overflow-anchor": {
	syntax: "auto | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Anchoring"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard"
},
	"overflow-block": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-clip-box": {
	syntax: "padding-box | content-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Mozilla Extensions"
	],
	initial: "padding-box",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
},
	"overflow-inline": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "perGrammar",
	status: "standard"
},
	"overflow-wrap": {
	syntax: "normal | break-word | anywhere",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"overflow-x": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
},
	"overflow-y": {
	syntax: "visible | hidden | clip | scroll | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "visible",
	appliesto: "blockContainersFlexContainersGridContainers",
	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
},
	"overscroll-behavior": {
	syntax: "[ contain | none | auto ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
},
	"overscroll-behavior-block": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
},
	"overscroll-behavior-inline": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
},
	"overscroll-behavior-x": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
},
	"overscroll-behavior-y": {
	syntax: "contain | none | auto",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Model"
	],
	initial: "auto",
	appliesto: "nonReplacedBlockAndInlineBlockElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
},
	padding: padding,
	"padding-block": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
},
	"padding-block-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
},
	"padding-block-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
},
	"padding-bottom": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
},
	"padding-inline": {
	syntax: "<'padding-left'>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
},
	"padding-inline-end": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
},
	"padding-inline-start": {
	syntax: "<'padding-left'>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "logicalWidthOfContainingBlock",
	groups: [
		"CSS Logical Properties"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
},
	"padding-left": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
},
	"padding-right": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
},
	"padding-top": {
	syntax: "<length> | <percentage>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Box Model"
	],
	initial: "0",
	appliesto: "allElementsExceptInternalTableDisplayTypes",
	computed: "percentageAsSpecifiedOrAbsoluteLength",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
},
	"page-break-after": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
},
	"page-break-before": {
	syntax: "auto | always | avoid | left | right | recto | verso",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
},
	"page-break-inside": {
	syntax: "auto | avoid",
	media: [
		"visual",
		"paged"
	],
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Pages"
	],
	initial: "auto",
	appliesto: "blockElementsInNormalFlow",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
},
	"paint-order": {
	syntax: "normal | [ fill || stroke || markers ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
},
	perspective: perspective,
	"perspective-origin": {
	syntax: "<position>",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50%",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
},
	"place-content": {
	syntax: "<'align-content'> <'justify-content'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multilineFlexContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
},
	"place-items": {
	syntax: "<'align-items'> <'justify-items'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-items",
		"justify-items"
	],
	appliesto: "allElements",
	computed: [
		"align-items",
		"justify-items"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
},
	"place-self": {
	syntax: "<'align-self'> <'justify-self'>?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Box Alignment"
	],
	initial: [
		"align-self",
		"justify-self"
	],
	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
	computed: [
		"align-self",
		"justify-self"
	],
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
},
	"pointer-events": {
	syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Pointer Events"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
},
	position: position$1,
	quotes: quotes,
	resize: resize,
	right: right,
	rotate: rotate,
	"row-gap": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToDimensionOfContentArea",
	groups: [
		"CSS Box Alignment"
	],
	initial: "normal",
	appliesto: "multiColumnElementsFlexContainersGridContainers",
	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
},
	"ruby-align": {
	syntax: "start | center | space-between | space-around",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "space-around",
	appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
},
	"ruby-merge": {
	syntax: "separate | collapse | auto",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "separate",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental"
},
	"ruby-position": {
	syntax: "over | under | inter-character",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Ruby"
	],
	initial: "over",
	appliesto: "rubyAnnotationsContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
},
	scale: scale,
	"scrollbar-color": {
	syntax: "auto | dark | light | <color>{2}",
	media: "visual",
	inherited: true,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
},
	"scrollbar-gutter": {
	syntax: "auto | [ stable | always ] && both? && force?",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Overflow"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
},
	"scrollbar-width": {
	syntax: "auto | thin | none",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scrollbars"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
},
	"scroll-behavior": {
	syntax: "auto | smooth",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSSOM View"
	],
	initial: "auto",
	appliesto: "scrollingBoxes",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
},
	"scroll-margin": {
	syntax: "<length>{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
},
	"scroll-margin-block": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
},
	"scroll-margin-block-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
},
	"scroll-margin-block-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
},
	"scroll-margin-bottom": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
},
	"scroll-margin-inline": {
	syntax: "<length>{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
},
	"scroll-margin-inline-start": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
},
	"scroll-margin-inline-end": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
},
	"scroll-margin-left": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
},
	"scroll-margin-right": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
},
	"scroll-margin-top": {
	syntax: "<length>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
},
	"scroll-padding": {
	syntax: "[ auto | <length-percentage> ]{1,4}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
},
	"scroll-padding-block": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
},
	"scroll-padding-block-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
},
	"scroll-padding-block-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
},
	"scroll-padding-bottom": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
},
	"scroll-padding-inline": {
	syntax: "[ auto | <length-percentage> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
},
	"scroll-padding-inline-start": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
},
	"scroll-padding-inline-end": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
},
	"scroll-padding-left": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
},
	"scroll-padding-right": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
},
	"scroll-padding-top": {
	syntax: "auto | <length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "relativeToTheScrollContainersScrollport",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "auto",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
},
	"scroll-snap-align": {
	syntax: "[ none | start | end | center ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
},
	"scroll-snap-coordinate": {
	syntax: "none | <position>#",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "referToBorderBox",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
},
	"scroll-snap-destination": {
	syntax: "<position>",
	media: "interactive",
	inherited: false,
	animationType: "position",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "0px 0px",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
},
	"scroll-snap-points-x": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
},
	"scroll-snap-points-y": {
	syntax: "none | repeat( <length-percentage> )",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "relativeToScrollContainerPaddingBoxAxis",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
},
	"scroll-snap-stop": {
	syntax: "normal | always",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
},
	"scroll-snap-type": {
	syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
},
	"scroll-snap-type-x": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
},
	"scroll-snap-type-y": {
	syntax: "none | mandatory | proximity",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Scroll Snap"
	],
	initial: "none",
	appliesto: "scrollContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "obsolete",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
},
	"shape-image-threshold": {
	syntax: "<alpha-value>",
	media: "visual",
	inherited: false,
	animationType: "number",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "0.0",
	appliesto: "floats",
	computed: "specifiedValueNumberClipped0To1",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
},
	"shape-margin": {
	syntax: "<length-percentage>",
	media: "visual",
	inherited: false,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Shapes"
	],
	initial: "0",
	appliesto: "floats",
	computed: "asSpecifiedRelativeToAbsoluteLengths",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
},
	"shape-outside": {
	syntax: "none | <shape-box> || <basic-shape> | <image>",
	media: "visual",
	inherited: false,
	animationType: "basicShapeOtherwiseNo",
	percentages: "no",
	groups: [
		"CSS Shapes"
	],
	initial: "none",
	appliesto: "floats",
	computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
},
	"tab-size": {
	syntax: "<integer> | <length>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "8",
	appliesto: "blockContainers",
	computed: "specifiedIntegerOrAbsoluteLength",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
},
	"table-layout": {
	syntax: "auto | fixed",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Table"
	],
	initial: "auto",
	appliesto: "tableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
},
	"text-align": {
	syntax: "start | end | left | right | center | justify | match-parent",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "startOrNamelessValueIfLTRRightIfRTL",
	appliesto: "blockContainers",
	computed: "asSpecifiedExceptMatchParent",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
},
	"text-align-last": {
	syntax: "auto | start | end | left | right | center | justify",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "blockContainers",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
},
	"text-combine-upright": {
	syntax: "none | all | [ digits <integer>? ]",
	media: "visual",
	inherited: true,
	animationType: "notAnimatable",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "none",
	appliesto: "nonReplacedInlineElements",
	computed: "keywordPlusIntegerIfDigits",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
},
	"text-decoration": {
	syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line",
		"text-decoration-thickness"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-decoration-color",
		"text-decoration-style",
		"text-decoration-line"
	],
	appliesto: "allElements",
	computed: [
		"text-decoration-line",
		"text-decoration-style",
		"text-decoration-color",
		"text-decoration-thickness"
	],
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
},
	"text-decoration-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
},
	"text-decoration-line": {
	syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
},
	"text-decoration-skip": {
	syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "objects",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
},
	"text-decoration-skip-ink": {
	syntax: "auto | all | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
},
	"text-decoration-style": {
	syntax: "solid | double | dotted | dashed | wavy",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "solid",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
},
	"text-decoration-thickness": {
	syntax: "auto | from-font | <length> | <percentage> ",
	media: "visual",
	inherited: false,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
},
	"text-emphasis": {
	syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
	media: "visual",
	inherited: false,
	animationType: [
		"text-emphasis-color",
		"text-emphasis-style"
	],
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	appliesto: "allElements",
	computed: [
		"text-emphasis-style",
		"text-emphasis-color"
	],
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
},
	"text-emphasis-color": {
	syntax: "<color>",
	media: "visual",
	inherited: false,
	animationType: "color",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "currentcolor",
	appliesto: "allElements",
	computed: "computedColor",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
},
	"text-emphasis-position": {
	syntax: "[ over | under ] && [ right | left ]",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "over right",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
},
	"text-emphasis-style": {
	syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
},
	"text-indent": {
	syntax: "<length-percentage> && hanging? && each-line?",
	media: "visual",
	inherited: true,
	animationType: "lpc",
	percentages: "referToWidthOfContainingBlock",
	groups: [
		"CSS Text"
	],
	initial: "0",
	appliesto: "blockContainers",
	computed: "percentageOrAbsoluteLengthPlusKeywords",
	order: "lengthOrPercentageBeforeKeywords",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
},
	"text-justify": {
	syntax: "auto | inter-character | inter-word | none",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "auto",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
},
	"text-orientation": {
	syntax: "mixed | upright | sideways",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "mixed",
	appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
},
	"text-overflow": {
	syntax: "[ clip | ellipsis | <string> ]{1,2}",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "clip",
	appliesto: "blockContainerElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
},
	"text-rendering": {
	syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Miscellaneous"
	],
	initial: "auto",
	appliesto: "textElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
},
	"text-shadow": {
	syntax: "none | <shadow-t>#",
	media: "visual",
	inherited: true,
	animationType: "shadowList",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "colorPlusThreeAbsoluteLengths",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
},
	"text-size-adjust": {
	syntax: "none | auto | <percentage>",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "referToSizeOfFont",
	groups: [
		"CSS Text"
	],
	initial: "autoForSmartphoneBrowsersSupportingInflation",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "experimental",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
},
	"text-transform": {
	syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "none",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
},
	"text-underline-offset": {
	syntax: "auto | <length> | <percentage> ",
	media: "visual",
	inherited: true,
	animationType: "byComputedValueType",
	percentages: "referToElementFontSize",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
},
	"text-underline-position": {
	syntax: "auto | from-font | [ under || [ left | right ] ]",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text Decoration"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "orderOfAppearance",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
},
	top: top,
	"touch-action": {
	syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"Pointer Events"
	],
	initial: "auto",
	appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
},
	transform: transform,
	"transform-box": {
	syntax: "content-box | border-box | fill-box | stroke-box | view-box",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "view-box",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "perGrammar",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
},
	"transform-origin": {
	syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
	media: "visual",
	inherited: false,
	animationType: "simpleListOfLpc",
	percentages: "referToSizeOfBoundingBox",
	groups: [
		"CSS Transforms"
	],
	initial: "50% 50% 0",
	appliesto: "transformableElements",
	computed: "forLengthAbsoluteValueOtherwisePercentage",
	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
},
	"transform-style": {
	syntax: "flat | preserve-3d",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transforms"
	],
	initial: "flat",
	appliesto: "transformableElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
},
	transition: transition,
	"transition-delay": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
},
	"transition-duration": {
	syntax: "<time>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "0s",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
},
	"transition-property": {
	syntax: "none | <single-transition-property>#",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "all",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
},
	"transition-timing-function": {
	syntax: "<timing-function>#",
	media: "interactive",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Transitions"
	],
	initial: "ease",
	appliesto: "allElementsAndPseudos",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
},
	translate: translate,
	"unicode-bidi": {
	syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "normal",
	appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
},
	"user-select": {
	syntax: "auto | text | none | contain | all",
	media: "visual",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Basic User Interface"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "nonstandard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
},
	"vertical-align": {
	syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
	media: "visual",
	inherited: false,
	animationType: "length",
	percentages: "referToLineHeight",
	groups: [
		"CSS Table"
	],
	initial: "baseline",
	appliesto: "inlineLevelAndTableCellElements",
	computed: "absoluteLengthOrKeyword",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
},
	visibility: visibility,
	"white-space": {
	syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
},
	widows: widows,
	width: width,
	"will-change": {
	syntax: "auto | <animateable-feature>#",
	media: "all",
	inherited: false,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Will Change"
	],
	initial: "auto",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
},
	"word-break": {
	syntax: "normal | break-all | keep-all | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
},
	"word-spacing": {
	syntax: "normal | <length-percentage>",
	media: "visual",
	inherited: true,
	animationType: "length",
	percentages: "referToWidthOfAffectedGlyph",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "allElements",
	computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
	order: "uniqueOrder",
	alsoAppliesTo: [
		"::first-letter",
		"::first-line",
		"::placeholder"
	],
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
},
	"word-wrap": {
	syntax: "normal | break-word",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Text"
	],
	initial: "normal",
	appliesto: "nonReplacedInlineElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
},
	"writing-mode": {
	syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
	media: "visual",
	inherited: true,
	animationType: "discrete",
	percentages: "no",
	groups: [
		"CSS Writing Modes"
	],
	initial: "horizontal-tb",
	appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
	computed: "asSpecified",
	order: "uniqueOrder",
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
},
	"z-index": {
	syntax: "auto | <integer>",
	media: "visual",
	inherited: false,
	animationType: "integer",
	percentages: "no",
	groups: [
		"CSS Positioning"
	],
	initial: "auto",
	appliesto: "positionedElements",
	computed: "asSpecified",
	order: "uniqueOrder",
	stacking: true,
	status: "standard",
	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
},
	zoom: zoom
};

var attachment = {
	syntax: "scroll | fixed | local"
};
var box = {
	syntax: "border-box | padding-box | content-box"
};
var color$1 = {
	syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
};
var combinator = {
	syntax: "'>' | '+' | '~' | [ '||' ]"
};
var gradient = {
	syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
};
var hue = {
	syntax: "<number> | <angle>"
};
var image = {
	syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
};
var nth$1 = {
	syntax: "<an-plus-b> | even | odd"
};
var position = {
	syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
};
var quote = {
	syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
};
var shadow = {
	syntax: "inset? && <length>{2,4} && <color>?"
};
var shape$1 = {
	syntax: "rect(<top>, <right>, <bottom>, <left>)"
};
var size = {
	syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
};
var symbol = {
	syntax: "<string> | <image> | <custom-ident>"
};
var target = {
	syntax: "<target-counter()> | <target-counters()> | <target-text()>"
};
var require$$2$1 = {
	"absolute-size": {
	syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
},
	"alpha-value": {
	syntax: "<number> | <percentage>"
},
	"angle-percentage": {
	syntax: "<angle> | <percentage>"
},
	"angular-color-hint": {
	syntax: "<angle-percentage>"
},
	"angular-color-stop": {
	syntax: "<color> && <color-stop-angle>?"
},
	"angular-color-stop-list": {
	syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
},
	"animateable-feature": {
	syntax: "scroll-position | contents | <custom-ident>"
},
	attachment: attachment,
	"attr()": {
	syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
},
	"attr-matcher": {
	syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
},
	"attr-modifier": {
	syntax: "i | s"
},
	"attribute-selector": {
	syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
},
	"auto-repeat": {
	syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"auto-track-list": {
	syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
},
	"baseline-position": {
	syntax: "[ first | last ]? baseline"
},
	"basic-shape": {
	syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
},
	"bg-image": {
	syntax: "none | <image>"
},
	"bg-layer": {
	syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"bg-position": {
	syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
},
	"bg-size": {
	syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
},
	"blur()": {
	syntax: "blur( <length> )"
},
	"blend-mode": {
	syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
},
	box: box,
	"brightness()": {
	syntax: "brightness( <number-percentage> )"
},
	"calc()": {
	syntax: "calc( <calc-sum> )"
},
	"calc-sum": {
	syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
},
	"calc-product": {
	syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
},
	"calc-value": {
	syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
},
	"cf-final-image": {
	syntax: "<image> | <color>"
},
	"cf-mixing-image": {
	syntax: "<percentage>? && <image>"
},
	"circle()": {
	syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
},
	"clamp()": {
	syntax: "clamp( <calc-sum>#{3} )"
},
	"class-selector": {
	syntax: "'.' <ident-token>"
},
	"clip-source": {
	syntax: "<url>"
},
	color: color$1,
	"color-stop": {
	syntax: "<color-stop-length> | <color-stop-angle>"
},
	"color-stop-angle": {
	syntax: "<angle-percentage>{1,2}"
},
	"color-stop-length": {
	syntax: "<length-percentage>{1,2}"
},
	"color-stop-list": {
	syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
},
	combinator: combinator,
	"common-lig-values": {
	syntax: "[ common-ligatures | no-common-ligatures ]"
},
	"compat-auto": {
	syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
},
	"composite-style": {
	syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
},
	"compositing-operator": {
	syntax: "add | subtract | intersect | exclude"
},
	"compound-selector": {
	syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
},
	"compound-selector-list": {
	syntax: "<compound-selector>#"
},
	"complex-selector": {
	syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
},
	"complex-selector-list": {
	syntax: "<complex-selector>#"
},
	"conic-gradient()": {
	syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
},
	"contextual-alt-values": {
	syntax: "[ contextual | no-contextual ]"
},
	"content-distribution": {
	syntax: "space-between | space-around | space-evenly | stretch"
},
	"content-list": {
	syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
},
	"content-position": {
	syntax: "center | start | end | flex-start | flex-end"
},
	"content-replacement": {
	syntax: "<image>"
},
	"contrast()": {
	syntax: "contrast( [ <number-percentage> ] )"
},
	"counter()": {
	syntax: "counter( <custom-ident>, <counter-style>? )"
},
	"counter-style": {
	syntax: "<counter-style-name> | symbols()"
},
	"counter-style-name": {
	syntax: "<custom-ident>"
},
	"counters()": {
	syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
},
	"cross-fade()": {
	syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
},
	"cubic-bezier-timing-function": {
	syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
},
	"deprecated-system-color": {
	syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
},
	"discretionary-lig-values": {
	syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
},
	"display-box": {
	syntax: "contents | none"
},
	"display-inside": {
	syntax: "flow | flow-root | table | flex | grid | ruby"
},
	"display-internal": {
	syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
},
	"display-legacy": {
	syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
},
	"display-listitem": {
	syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
},
	"display-outside": {
	syntax: "block | inline | run-in"
},
	"drop-shadow()": {
	syntax: "drop-shadow( <length>{2,3} <color>? )"
},
	"east-asian-variant-values": {
	syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
},
	"east-asian-width-values": {
	syntax: "[ full-width | proportional-width ]"
},
	"element()": {
	syntax: "element( <id-selector> )"
},
	"ellipse()": {
	syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
},
	"ending-shape": {
	syntax: "circle | ellipse"
},
	"env()": {
	syntax: "env( <custom-ident> , <declaration-value>? )"
},
	"explicit-track-list": {
	syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
},
	"family-name": {
	syntax: "<string> | <custom-ident>+"
},
	"feature-tag-value": {
	syntax: "<string> [ <integer> | on | off ]?"
},
	"feature-type": {
	syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
},
	"feature-value-block": {
	syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
},
	"feature-value-block-list": {
	syntax: "<feature-value-block>+"
},
	"feature-value-declaration": {
	syntax: "<custom-ident>: <integer>+;"
},
	"feature-value-declaration-list": {
	syntax: "<feature-value-declaration>"
},
	"feature-value-name": {
	syntax: "<custom-ident>"
},
	"fill-rule": {
	syntax: "nonzero | evenodd"
},
	"filter-function": {
	syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
},
	"filter-function-list": {
	syntax: "[ <filter-function> | <url> ]+"
},
	"final-bg-layer": {
	syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
},
	"fit-content()": {
	syntax: "fit-content( [ <length> | <percentage> ] )"
},
	"fixed-breadth": {
	syntax: "<length-percentage>"
},
	"fixed-repeat": {
	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
},
	"fixed-size": {
	syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
},
	"font-stretch-absolute": {
	syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
},
	"font-variant-css21": {
	syntax: "[ normal | small-caps ]"
},
	"font-weight-absolute": {
	syntax: "normal | bold | <number [1,1000]>"
},
	"frequency-percentage": {
	syntax: "<frequency> | <percentage>"
},
	"general-enclosed": {
	syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
},
	"generic-family": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"generic-name": {
	syntax: "serif | sans-serif | cursive | fantasy | monospace"
},
	"geometry-box": {
	syntax: "<shape-box> | fill-box | stroke-box | view-box"
},
	gradient: gradient,
	"grayscale()": {
	syntax: "grayscale( <number-percentage> )"
},
	"grid-line": {
	syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
},
	"historical-lig-values": {
	syntax: "[ historical-ligatures | no-historical-ligatures ]"
},
	"hsl()": {
	syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	"hsla()": {
	syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
},
	hue: hue,
	"hue-rotate()": {
	syntax: "hue-rotate( <angle> )"
},
	"id-selector": {
	syntax: "<hash-token>"
},
	image: image,
	"image()": {
	syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
},
	"image-set()": {
	syntax: "image-set( <image-set-option># )"
},
	"image-set-option": {
	syntax: "[ <image> | <string> ] <resolution>"
},
	"image-src": {
	syntax: "<url> | <string>"
},
	"image-tags": {
	syntax: "ltr | rtl"
},
	"inflexible-breadth": {
	syntax: "<length> | <percentage> | min-content | max-content | auto"
},
	"inset()": {
	syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
},
	"invert()": {
	syntax: "invert( <number-percentage> )"
},
	"keyframes-name": {
	syntax: "<custom-ident> | <string>"
},
	"keyframe-block": {
	syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
},
	"keyframe-block-list": {
	syntax: "<keyframe-block>+"
},
	"keyframe-selector": {
	syntax: "from | to | <percentage>"
},
	"leader()": {
	syntax: "leader( <leader-type> )"
},
	"leader-type": {
	syntax: "dotted | solid | space | <string>"
},
	"length-percentage": {
	syntax: "<length> | <percentage>"
},
	"line-names": {
	syntax: "'[' <custom-ident>* ']'"
},
	"line-name-list": {
	syntax: "[ <line-names> | <name-repeat> ]+"
},
	"line-style": {
	syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
},
	"line-width": {
	syntax: "<length> | thin | medium | thick"
},
	"linear-color-hint": {
	syntax: "<length-percentage>"
},
	"linear-color-stop": {
	syntax: "<color> <color-stop-length>?"
},
	"linear-gradient()": {
	syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"mask-layer": {
	syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
},
	"mask-position": {
	syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
},
	"mask-reference": {
	syntax: "none | <image> | <mask-source>"
},
	"mask-source": {
	syntax: "<url>"
},
	"masking-mode": {
	syntax: "alpha | luminance | match-source"
},
	"matrix()": {
	syntax: "matrix( <number>#{6} )"
},
	"matrix3d()": {
	syntax: "matrix3d( <number>#{16} )"
},
	"max()": {
	syntax: "max( <calc-sum># )"
},
	"media-and": {
	syntax: "<media-in-parens> [ and <media-in-parens> ]+"
},
	"media-condition": {
	syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
},
	"media-condition-without-or": {
	syntax: "<media-not> | <media-and> | <media-in-parens>"
},
	"media-feature": {
	syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
},
	"media-in-parens": {
	syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
},
	"media-not": {
	syntax: "not <media-in-parens>"
},
	"media-or": {
	syntax: "<media-in-parens> [ or <media-in-parens> ]+"
},
	"media-query": {
	syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
},
	"media-query-list": {
	syntax: "<media-query>#"
},
	"media-type": {
	syntax: "<ident>"
},
	"mf-boolean": {
	syntax: "<mf-name>"
},
	"mf-name": {
	syntax: "<ident>"
},
	"mf-plain": {
	syntax: "<mf-name> : <mf-value>"
},
	"mf-range": {
	syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
},
	"mf-value": {
	syntax: "<number> | <dimension> | <ident> | <ratio>"
},
	"min()": {
	syntax: "min( <calc-sum># )"
},
	"minmax()": {
	syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
},
	"named-color": {
	syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
},
	"namespace-prefix": {
	syntax: "<ident>"
},
	"ns-prefix": {
	syntax: "[ <ident-token> | '*' ]? '|'"
},
	"number-percentage": {
	syntax: "<number> | <percentage>"
},
	"numeric-figure-values": {
	syntax: "[ lining-nums | oldstyle-nums ]"
},
	"numeric-fraction-values": {
	syntax: "[ diagonal-fractions | stacked-fractions ]"
},
	"numeric-spacing-values": {
	syntax: "[ proportional-nums | tabular-nums ]"
},
	nth: nth$1,
	"opacity()": {
	syntax: "opacity( [ <number-percentage> ] )"
},
	"overflow-position": {
	syntax: "unsafe | safe"
},
	"outline-radius": {
	syntax: "<length> | <percentage>"
},
	"page-body": {
	syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
},
	"page-margin-box": {
	syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
},
	"page-margin-box-type": {
	syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
},
	"page-selector-list": {
	syntax: "[ <page-selector># ]?"
},
	"page-selector": {
	syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
},
	"path()": {
	syntax: "path( [ <fill-rule>, ]? <string> )"
},
	"paint()": {
	syntax: "paint( <ident>, <declaration-value>? )"
},
	"perspective()": {
	syntax: "perspective( <length> )"
},
	"polygon()": {
	syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
},
	position: position,
	"pseudo-class-selector": {
	syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
},
	"pseudo-element-selector": {
	syntax: "':' <pseudo-class-selector>"
},
	"pseudo-page": {
	syntax: ": [ left | right | first | blank ]"
},
	quote: quote,
	"radial-gradient()": {
	syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	"relative-selector": {
	syntax: "<combinator>? <complex-selector>"
},
	"relative-selector-list": {
	syntax: "<relative-selector>#"
},
	"relative-size": {
	syntax: "larger | smaller"
},
	"repeat-style": {
	syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
},
	"repeating-linear-gradient()": {
	syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
},
	"repeating-radial-gradient()": {
	syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
},
	"rgb()": {
	syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
},
	"rgba()": {
	syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
},
	"rotate()": {
	syntax: "rotate( [ <angle> | <zero> ] )"
},
	"rotate3d()": {
	syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
},
	"rotateX()": {
	syntax: "rotateX( [ <angle> | <zero> ] )"
},
	"rotateY()": {
	syntax: "rotateY( [ <angle> | <zero> ] )"
},
	"rotateZ()": {
	syntax: "rotateZ( [ <angle> | <zero> ] )"
},
	"saturate()": {
	syntax: "saturate( <number-percentage> )"
},
	"scale()": {
	syntax: "scale( <number> , <number>? )"
},
	"scale3d()": {
	syntax: "scale3d( <number> , <number> , <number> )"
},
	"scaleX()": {
	syntax: "scaleX( <number> )"
},
	"scaleY()": {
	syntax: "scaleY( <number> )"
},
	"scaleZ()": {
	syntax: "scaleZ( <number> )"
},
	"self-position": {
	syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
},
	"shape-radius": {
	syntax: "<length-percentage> | closest-side | farthest-side"
},
	"skew()": {
	syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
},
	"skewX()": {
	syntax: "skewX( [ <angle> | <zero> ] )"
},
	"skewY()": {
	syntax: "skewY( [ <angle> | <zero> ] )"
},
	"sepia()": {
	syntax: "sepia( <number-percentage> )"
},
	shadow: shadow,
	"shadow-t": {
	syntax: "[ <length>{2,3} && <color>? ]"
},
	shape: shape$1,
	"shape-box": {
	syntax: "<box> | margin-box"
},
	"side-or-corner": {
	syntax: "[ left | right ] || [ top | bottom ]"
},
	"single-animation": {
	syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
},
	"single-animation-direction": {
	syntax: "normal | reverse | alternate | alternate-reverse"
},
	"single-animation-fill-mode": {
	syntax: "none | forwards | backwards | both"
},
	"single-animation-iteration-count": {
	syntax: "infinite | <number>"
},
	"single-animation-play-state": {
	syntax: "running | paused"
},
	"single-transition": {
	syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
},
	"single-transition-property": {
	syntax: "all | <custom-ident>"
},
	size: size,
	"step-position": {
	syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
},
	"step-timing-function": {
	syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
},
	"subclass-selector": {
	syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
},
	"supports-condition": {
	syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
},
	"supports-in-parens": {
	syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
},
	"supports-feature": {
	syntax: "<supports-decl> | <supports-selector-fn>"
},
	"supports-decl": {
	syntax: "( <declaration> )"
},
	"supports-selector-fn": {
	syntax: "selector( <complex-selector> )"
},
	symbol: symbol,
	target: target,
	"target-counter()": {
	syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
},
	"target-counters()": {
	syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
},
	"target-text()": {
	syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
},
	"time-percentage": {
	syntax: "<time> | <percentage>"
},
	"timing-function": {
	syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
},
	"track-breadth": {
	syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
},
	"track-list": {
	syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
},
	"track-repeat": {
	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
},
	"track-size": {
	syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
},
	"transform-function": {
	syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
},
	"transform-list": {
	syntax: "<transform-function>+"
},
	"translate()": {
	syntax: "translate( <length-percentage> , <length-percentage>? )"
},
	"translate3d()": {
	syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
},
	"translateX()": {
	syntax: "translateX( <length-percentage> )"
},
	"translateY()": {
	syntax: "translateY( <length-percentage> )"
},
	"translateZ()": {
	syntax: "translateZ( <length> )"
},
	"type-or-unit": {
	syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
},
	"type-selector": {
	syntax: "<wq-name> | <ns-prefix>? '*'"
},
	"var()": {
	syntax: "var( <custom-property-name> , <declaration-value>? )"
},
	"viewport-length": {
	syntax: "auto | <length-percentage>"
},
	"wq-name": {
	syntax: "<ns-prefix>? <ident-token>"
}
};

var atrules = {
	charset: {
		prelude: "<string>"
	},
	"font-face": {
		descriptors: {
			"unicode-range": {
				comment: "replaces <unicode-range>, an old production name",
				syntax: "<urange>#"
			}
		}
	}
};
var properties = {
	"-moz-background-clip": {
		comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "padding | border"
	},
	"-moz-border-radius-bottomleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
		syntax: "<'border-bottom-left-radius'>"
	},
	"-moz-border-radius-bottomright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-border-radius-topleft": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
		syntax: "<'border-top-left-radius'>"
	},
	"-moz-border-radius-topright": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
		syntax: "<'border-bottom-right-radius'>"
	},
	"-moz-control-character-visibility": {
		comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
		syntax: "visible | hidden"
	},
	"-moz-osx-font-smoothing": {
		comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | grayscale"
	},
	"-moz-user-select": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "none | text | all | -moz-none"
	},
	"-ms-flex-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "start | end | center | baseline | stretch"
	},
	"-ms-flex-item-align": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
		syntax: "auto | start | end | center | baseline | stretch"
	},
	"-ms-flex-line-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
		syntax: "start | end | center | justify | distribute | stretch"
	},
	"-ms-flex-negative": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-shrink'>"
	},
	"-ms-flex-pack": {
		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
		syntax: "start | end | center | justify | distribute"
	},
	"-ms-flex-order": {
		comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
		syntax: "<integer>"
	},
	"-ms-flex-positive": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-grow'>"
	},
	"-ms-flex-preferred-size": {
		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
		syntax: "<'flex-basis'>"
	},
	"-ms-interpolation-mode": {
		comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
		syntax: "nearest-neighbor | bicubic"
	},
	"-ms-grid-column-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-grid-row-align": {
		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
		syntax: "start | end | center | stretch"
	},
	"-ms-hyphenate-limit-last": {
		comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
		syntax: "none | always | column | page | spread"
	},
	"-webkit-appearance": {
		comment: "webkit specific keywords",
		references: [
			"http://css-infos.net/property/-webkit-appearance"
		],
		syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
	},
	"-webkit-background-clip": {
		comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
		syntax: "[ <box> | border | padding | content | text ]#"
	},
	"-webkit-column-break-after": {
		comment: "added, http://help.dottoro.com/lcrthhhv.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-before": {
		comment: "added, http://help.dottoro.com/lcxquvkf.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-column-break-inside": {
		comment: "added, http://help.dottoro.com/lclhnthl.php",
		syntax: "always | auto | avoid"
	},
	"-webkit-font-smoothing": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
		syntax: "auto | none | antialiased | subpixel-antialiased"
	},
	"-webkit-mask-box-image": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
	},
	"-webkit-print-color-adjust": {
		comment: "missed",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
		],
		syntax: "economy | exact"
	},
	"-webkit-text-security": {
		comment: "missed; http://help.dottoro.com/lcbkewgt.php",
		syntax: "none | circle | disc | square"
	},
	"-webkit-user-drag": {
		comment: "missed; http://help.dottoro.com/lcbixvwm.php",
		syntax: "none | element | auto"
	},
	"-webkit-user-select": {
		comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
		syntax: "auto | none | text | all"
	},
	"alignment-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
		],
		syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
	},
	"baseline-shift": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
		],
		syntax: "baseline | sub | super | <svg-length>"
	},
	behavior: {
		comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
		syntax: "<url>+"
	},
	"clip-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
		],
		syntax: "nonzero | evenodd"
	},
	cue: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'cue-before'> <'cue-after'>?"
	},
	"cue-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	"cue-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<url> <decibel>? | none"
	},
	cursor: {
		comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
		references: [
			"https://www.sitepoint.com/css3-cursor-styles/"
		],
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
	},
	display: {
		comment: "extended with -ms-flexbox",
		syntax: "| <-non-standard-display>"
	},
	position: {
		comment: "extended with -webkit-sticky",
		syntax: "| -webkit-sticky"
	},
	"dominant-baseline": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
		],
		syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
	},
	"image-rendering": {
		comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
			"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
		],
		syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
	},
	fill: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<paint>"
	},
	"fill-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "<number-zero-one>"
	},
	"fill-rule": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
		],
		syntax: "nonzero | evenodd"
	},
	filter: {
		comment: "extend with IE legacy syntaxes",
		syntax: "| <-ms-filter-function-list>"
	},
	"glyph-orientation-horizontal": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
		],
		syntax: "<angle>"
	},
	"glyph-orientation-vertical": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
		],
		syntax: "<angle>"
	},
	kerning: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#KerningProperty"
		],
		syntax: "auto | <svg-length>"
	},
	"letter-spacing": {
		comment: "fix syntax <length> -> <length-percentage>",
		references: [
			"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
		],
		syntax: "normal | <length-percentage>"
	},
	marker: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-end": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-mid": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"marker-start": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
		],
		syntax: "none | <url>"
	},
	"max-width": {
		comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
		syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
	},
	width: {
		comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
		syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
	},
	"min-width": {
		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
	},
	overflow: {
		comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "| <-non-standard-overflow>"
	},
	pause: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'pause-before'> <'pause-after'>?"
	},
	"pause-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"pause-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	rest: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<'rest-before'> <'rest-after'>?"
	},
	"rest-after": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"rest-before": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
	},
	"shape-rendering": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
		],
		syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
	},
	src: {
		comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
		syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
	},
	speak: {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | none | normal"
	},
	"speak-as": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
	},
	stroke: {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<paint>"
	},
	"stroke-dasharray": {
		comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "none | [ <svg-length>+ ]#"
	},
	"stroke-dashoffset": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"stroke-linecap": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "butt | round | square"
	},
	"stroke-linejoin": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "miter | round | bevel"
	},
	"stroke-miterlimit": {
		comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-one-or-greater>"
	},
	"stroke-opacity": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<number-zero-one>"
	},
	"stroke-width": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
		],
		syntax: "<svg-length>"
	},
	"text-anchor": {
		comment: "added SVG property",
		references: [
			"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
		],
		syntax: "start | middle | end"
	},
	"unicode-bidi": {
		comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
		syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
	},
	"unicode-range": {
		comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
		syntax: "<urange>#"
	},
	"voice-balance": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<number> | left | center | right | leftwards | rightwards"
	},
	"voice-duration": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "auto | <time>"
	},
	"voice-family": {
		comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
	},
	"voice-pitch": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-range": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
	},
	"voice-rate": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
	},
	"voice-stress": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "normal | strong | moderate | none | reduced"
	},
	"voice-volume": {
		comment: "https://www.w3.org/TR/css3-speech/#property-index",
		syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
	},
	"writing-mode": {
		comment: "extend with SVG keywords",
		syntax: "| <svg-writing-mode>"
	}
};
var syntaxes = {
	"-legacy-gradient": {
		comment: "added collection of legacy gradient syntaxes",
		syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
	},
	"-legacy-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-repeating-linear-gradient": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
	},
	"-legacy-linear-gradient-arguments": {
		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
		syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
	},
	"-legacy-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-repeating-radial-gradient": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
	},
	"-legacy-radial-gradient-arguments": {
		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
		syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
	},
	"-legacy-radial-gradient-size": {
		comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
		syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
	},
	"-legacy-radial-gradient-shape": {
		comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
		syntax: "circle | ellipse"
	},
	"-non-standard-font": {
		comment: "non standard fonts",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
	},
	"-non-standard-color": {
		comment: "non standard colors",
		references: [
			"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
			"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
		],
		syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
	},
	"-non-standard-image-rendering": {
		comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
		syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
	},
	"-non-standard-overflow": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
		syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
	},
	"-non-standard-width": {
		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
		syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
	},
	"-webkit-gradient()": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
		syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
	},
	"-webkit-gradient-color-stop": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
	},
	"-webkit-gradient-point": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
	},
	"-webkit-gradient-radius": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "<length> | <percentage>"
	},
	"-webkit-gradient-type": {
		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
		syntax: "linear | radial"
	},
	"-webkit-mask-box-repeat": {
		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
		syntax: "repeat | stretch | round"
	},
	"-webkit-mask-clip-style": {
		comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
		syntax: "border | border-box | padding | padding-box | content | content-box | text"
	},
	"-ms-filter-function-list": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function>+"
	},
	"-ms-filter-function": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
	},
	"-ms-filter-function-progid": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
	},
	"-ms-filter-function-legacy": {
		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
		syntax: "<ident-token> | <function-token> <any-value>? )"
	},
	"-ms-filter": {
		syntax: "<string>"
	},
	age: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "child | young | old"
	},
	"attr-name": {
		syntax: "<wq-name>"
	},
	"attr-fallback": {
		syntax: "<any-value>"
	},
	"border-radius": {
		comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
		syntax: "<length-percentage>{1,2}"
	},
	bottom: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"content-list": {
		comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
	},
	"element()": {
		comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
		syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
	},
	"generic-voice": {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "[ <age>? <gender> <integer>? ]"
	},
	gender: {
		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
		syntax: "male | female | neutral"
	},
	"generic-family": {
		comment: "added -apple-system",
		references: [
			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
		],
		syntax: "| -apple-system"
	},
	gradient: {
		comment: "added legacy syntaxes support",
		syntax: "| <-legacy-gradient>"
	},
	left: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"mask-image": {
		comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
		syntax: "<mask-reference>#"
	},
	"name-repeat": {
		comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
		syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
	},
	"named-color": {
		comment: "added non standard color names",
		syntax: "| <-non-standard-color>"
	},
	paint: {
		comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
		syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
	},
	"page-size": {
		comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
		syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
	},
	ratio: {
		comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
		syntax: "<integer> / <integer>"
	},
	right: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	shape: {
		comment: "missed spaces in function body and add backwards compatible syntax",
		syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
	},
	"svg-length": {
		comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
		references: [
			"https://www.w3.org/TR/SVG11/coords.html#Units"
		],
		syntax: "<percentage> | <length> | <number>"
	},
	"svg-writing-mode": {
		comment: "SVG specific keywords (deprecated for CSS)",
		references: [
			"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
			"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
		],
		syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
	},
	top: {
		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
		syntax: "<length> | auto"
	},
	"track-group": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
	},
	"track-list-v0": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "[ <string>* <track-group> <string>* ]+ | none"
	},
	"track-minmax": {
		comment: "used by old grid-columns and grid-rows syntax v0",
		syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
	},
	x: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	y: {
		comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
		syntax: "<number>"
	},
	declaration: {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
	},
	"declaration-list": {
		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
		syntax: "[ <declaration>? ';' ]* <declaration>?"
	},
	url: {
		comment: "https://drafts.csswg.org/css-values-4/#urls",
		syntax: "url( <string> <url-modifier>* ) | <url-token>"
	},
	"url-modifier": {
		comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
		syntax: "<ident> | <function-token> <any-value> )"
	},
	"number-zero-one": {
		syntax: "<number [0,1]>"
	},
	"number-one-or-greater": {
		syntax: "<number [1,∞]>"
	},
	"positive-integer": {
		syntax: "<integer [0,∞]>"
	},
	"-non-standard-display": {
		syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
	}
};
var require$$3 = {
	atrules: atrules,
	properties: properties,
	syntaxes: syntaxes
};

const mdnAtrules = require$$0;
const mdnProperties = require$$1;
const mdnSyntaxes = require$$2$1;
const patch = require$$3;
const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (const descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function patchDictionary(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
    }

    // apply a patch
    for (const key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = extendSyntax.test(patchDict[key].syntax)
                    ? result[key] + ' ' + patchDict[key].syntax.trim()
                    : patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
            }
        }
    }

    return result;
}

function unpackSyntaxes(dict) {
    const result = {};

    for (const key in dict) {
        result[key] = dict[key].syntax;
    }

    return result;
}

function patchAtrules(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;

        result[key] = {
            prelude: key in patchDict && 'prelude' in patchDict[key]
                ? patchDict[key].prelude
                : dict[key].prelude || null,
            descriptors: dict[key].descriptors
                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
                : patchDescriptors && unpackSyntaxes(patchDescriptors)
        };
    }

    // apply a patch
    for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
                prelude: patchDict[key].prelude || null,
                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
            };
        }
    }

    return result;
}

var data$1 = {
    types: patchDictionary(mdnSyntaxes, patch.syntaxes),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
    properties: patchDictionary(mdnProperties, patch.properties)
};

var cmpChar$2 = tokenizer$3.cmpChar;
var isDigit$2 = tokenizer$3.isDigit;
var TYPE$y = tokenizer$3.TYPE;

var WHITESPACE$8 = TYPE$y.WhiteSpace;
var COMMENT$6 = TYPE$y.Comment;
var IDENT$f = TYPE$y.Ident;
var NUMBER$6 = TYPE$y.Number;
var DIMENSION$5 = TYPE$y.Dimension;
var PLUSSIGN$5 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    var pos = this.scanner.tokenStart + offset;
    var code = this.scanner.source.charCodeAt(pos);

    if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit$2(this.scanner.source.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!cmpChar$2(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS$2:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.scanner.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    var offset = 0;
    var sign = 0;
    var type = this.scanner.tokenType;

    while (type === WHITESPACE$8 || type === COMMENT$6) {
        type = this.scanner.lookupType(++offset);
    }

    if (type !== NUMBER$6) {
        if (this.scanner.isDelim(PLUSSIGN$5, offset) ||
            this.scanner.isDelim(HYPHENMINUS$2, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

            do {
                type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE$8 || type === COMMENT$6);

            if (type !== NUMBER$6) {
                this.scanner.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.scanner.skip(offset);
    }

    if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$2 ? '-' + this.consume(NUMBER$6) : this.consume(NUMBER$6);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var AnPlusB = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        /* eslint-disable brace-style*/
        var start = this.scanner.tokenStart;
        var a = null;
        var b = null;

        // <integer>
        if (this.scanner.tokenType === NUMBER$6) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER$6);
        }

        // -n
        // -n <signed-integer>
        // -n ['+' | '-'] <signless-integer>
        // -n- <signless-integer>
        // <dashndashdigit-ident>
        else if (this.scanner.tokenType === IDENT$f && cmpChar$2(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$2)) {
            a = '-1';

            expectCharCode.call(this, 1, N);

            switch (this.scanner.getTokenLength()) {
                // -n
                // -n <signed-integer>
                // -n ['+' | '-'] <signless-integer>
                case 2:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // -n- <signless-integer>
                case 3:
                    expectCharCode.call(this, 2, HYPHENMINUS$2);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER$6);
                    break;

                // <dashndashdigit-ident>
                default:
                    expectCharCode.call(this, 2, HYPHENMINUS$2);
                    checkInteger.call(this, 3, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + 2);
            }
        }

        // '+'? n
        // '+'? n <signed-integer>
        // '+'? n ['+' | '-'] <signless-integer>
        // '+'? n- <signless-integer>
        // '+'? <ndashdigit-ident>
        else if (this.scanner.tokenType === IDENT$f || (this.scanner.isDelim(PLUSSIGN$5) && this.scanner.lookupType(1) === IDENT$f)) {
            var sign = 0;
            a = '1';

            // just ignore a plus
            if (this.scanner.isDelim(PLUSSIGN$5)) {
                sign = 1;
                this.scanner.next();
            }

            expectCharCode.call(this, 0, N);

            switch (this.scanner.getTokenLength()) {
                // '+'? n
                // '+'? n <signed-integer>
                // '+'? n ['+' | '-'] <signless-integer>
                case 1:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // '+'? n- <signless-integer>
                case 2:
                    expectCharCode.call(this, 1, HYPHENMINUS$2);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER$6);
                    break;

                // '+'? <ndashdigit-ident>
                default:
                    expectCharCode.call(this, 1, HYPHENMINUS$2);
                    checkInteger.call(this, 2, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + sign + 1);
            }
        }

        // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.scanner.tokenType === DIMENSION$5) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;

            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
                if (!isDigit$2(this.scanner.source.charCodeAt(i))) {
                    break;
                }
            }

            if (i === this.scanner.tokenStart + sign) {
                this.error('Integer is expected', this.scanner.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);

            // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>
            if (i + 1 === this.scanner.tokenEnd) {
                this.scanner.next();
                b = consumeB.call(this);
            } else {
                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$2);

                // <ndash-dimension> <signless-integer>
                if (i + 2 === this.scanner.tokenEnd) {
                    this.scanner.next();
                    this.scanner.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = '-' + this.consume(NUMBER$6);
                }
                // <ndashdigit-dimension>
                else {
                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                    this.scanner.next();
                    b = this.scanner.substrToCursor(i + 1);
                }
            }
        } else {
            this.error();
        }

        if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
            a = a.substr(1);
        }

        if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
            b = b.substr(1);
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, this.scanner.tokenStart),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};

var tokenizer = tokenizer$3;
var TYPE$x = tokenizer.TYPE;

var WhiteSpace$2 = TYPE$x.WhiteSpace;
var Semicolon = TYPE$x.Semicolon;
var LeftCurlyBracket = TYPE$x.LeftCurlyBracket;
var Delim = TYPE$x.Delim;
var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)

function getOffsetExcludeWS() {
    if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace$2) {
            return this.scanner.tokenIndex > 1
                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
                : this.scanner.firstCharOffset;
        }
    }

    return this.scanner.tokenStart;
}

// 0, 0, false
function balanceEnd() {
    return 0;
}

// LEFTCURLYBRACKET, 0, false
function leftCurlyBracket(tokenType) {
    return tokenType === LeftCurlyBracket ? 1 : 0;
}

// LEFTCURLYBRACKET, SEMICOLON, false
function leftCurlyBracketOrSemicolon(tokenType) {
    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
}

// EXCLAMATIONMARK, SEMICOLON, false
function exclamationMarkOrSemicolon(tokenType, source, offset) {
    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$2) {
        return 1;
    }

    return tokenType === Semicolon ? 1 : 0;
}

// 0, SEMICOLON, true
function semicolonIncluded(tokenType) {
    return tokenType === Semicolon ? 2 : 0;
}

var Raw$1 = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd)
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    },

    mode: {
        default: balanceEnd,
        leftCurlyBracket: leftCurlyBracket,
        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
        semicolonIncluded: semicolonIncluded
    }
};

var TYPE$w = tokenizer$3.TYPE;
var rawMode$5 = Raw$1.mode;

var ATKEYWORD$2 = TYPE$w.AtKeyword;
var SEMICOLON$4 = TYPE$w.Semicolon;
var LEFTCURLYBRACKET$3 = TYPE$w.LeftCurlyBracket;
var RIGHTCURLYBRACKET$1 = TYPE$w.RightCurlyBracket;

function consumeRaw$5(startToken) {
    return this.Raw(startToken, rawMode$5.leftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET$1) {
            return true;
        }

        if (type === LEFTCURLYBRACKET$3 ||
            type === ATKEYWORD$2) {
            return false;
        }
    }

    return false;
}

var Atrule$2 = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.eat(ATKEYWORD$2);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
            this.scanner.tokenType !== SEMICOLON$4) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw$5);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw$5.call(this, this.scanner.tokenIndex);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON$4:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET$3:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};

var TYPE$v = tokenizer$3.TYPE;

var SEMICOLON$3 = TYPE$v.Semicolon;
var LEFTCURLYBRACKET$2 = TYPE$v.LeftCurlyBracket;

var AtrulePrelude = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
            this.scanner.tokenType !== SEMICOLON$3) {
            this.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};

var TYPE$u = tokenizer$3.TYPE;

var IDENT$e = TYPE$u.Ident;
var STRING$3 = TYPE$u.String;
var COLON$6 = TYPE$u.Colon;
var LEFTSQUAREBRACKET$3 = TYPE$u.LeftSquareBracket;
var RIGHTSQUAREBRACKET$1 = TYPE$u.RightSquareBracket;
var DOLLARSIGN$1 = 0x0024;       // U+0024 DOLLAR SIGN ($)
var ASTERISK$5 = 0x002A;         // U+002A ASTERISK (*)
var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
var VERTICALLINE$2 = 0x007C;     // U+007C VERTICAL LINE (|)
var TILDE$2 = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.scanner.eof) {
        this.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdent = false;
    var checkColon = true;

    if (this.scanner.isDelim(ASTERISK$5)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
    } else if (!this.scanner.isDelim(VERTICALLINE$2)) {
        this.eat(IDENT$e);
    }

    if (this.scanner.isDelim(VERTICALLINE$2)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT$e);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON$6) {
        this.scanner.next();
        this.eat(IDENT$e);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var code = this.scanner.source.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE$2 &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN$1 &&        // $=
        code !== ASTERISK$5 &&          // *=
        code !== VERTICALLINE$2         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.scanner.next();

    if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.scanner.next();
    }

    return this.scanner.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
var AttributeSelector$1 = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.eat(LEFTSQUAREBRACKET$3);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENT$e) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING$3
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENT$e) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.eat(RIGHTSQUAREBRACKET$1);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};

var TYPE$t = tokenizer$3.TYPE;
var rawMode$4 = Raw$1.mode;

var WHITESPACE$7 = TYPE$t.WhiteSpace;
var COMMENT$5 = TYPE$t.Comment;
var SEMICOLON$2 = TYPE$t.Semicolon;
var ATKEYWORD$1 = TYPE$t.AtKeyword;
var LEFTCURLYBRACKET$1 = TYPE$t.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE$t.RightCurlyBracket;

function consumeRaw$4(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, rawMode$4.semicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON$2) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON$2) {
        this.scanner.next();
    }

    return node;
}

var Block = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.eat(LEFTCURLYBRACKET$1);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE$7:
                case COMMENT$5:
                    this.scanner.next();
                    break;

                case ATKEYWORD$1:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$4));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};

var TYPE$s = tokenizer$3.TYPE;

var LEFTSQUAREBRACKET$2 = TYPE$s.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE$s.RightSquareBracket;

var Brackets = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTSQUAREBRACKET$2);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};

var CDC$1 = tokenizer$3.TYPE.CDC;

var CDC_1 = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDC$1); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};

var CDO$1 = tokenizer$3.TYPE.CDO;

var CDO_1 = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDO$1); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};

var TYPE$r = tokenizer$3.TYPE;

var IDENT$d = TYPE$r.Ident;
var FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)

// '.' ident
var ClassSelector = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        if (!this.scanner.isDelim(FULLSTOP$2)) {
            this.error('Full stop is expected');
        }

        this.scanner.next();

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT$d)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};

var TYPE$q = tokenizer$3.TYPE;

var IDENT$c = TYPE$q.Ident;
var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
var TILDE$1 = 0x007E;           // U+007E TILDE (~)

// + | > | ~ | /deep/
var Combinator = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

        switch (code) {
            case GREATERTHANSIGN$1:
            case PLUSSIGN$4:
            case TILDE$1:
                this.scanner.next();
                break;

            case SOLIDUS$5:
                this.scanner.next();

                if (this.scanner.tokenType !== IDENT$c || this.scanner.lookupValue(0, 'deep') === false) {
                    this.error('Identifier `deep` is expected');
                }

                this.scanner.next();

                if (!this.scanner.isDelim(SOLIDUS$5)) {
                    this.error('Solidus is expected');
                }

                this.scanner.next();
                break;

            default:
                this.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var TYPE$p = tokenizer$3.TYPE;

var COMMENT$4 = TYPE$p.Comment;
var ASTERISK$4 = 0x002A;        // U+002A ASTERISK (*)
var SOLIDUS$4 = 0x002F;         // U+002F SOLIDUS (/)

// '/*' .* '*/'
var Comment$1 = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        this.eat(COMMENT$4);

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK$4 &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$4) {
            end -= 2;
        }

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};

var isCustomProperty = names$2.isCustomProperty;
var TYPE$o = tokenizer$3.TYPE;
var rawMode$3 = Raw$1.mode;

var IDENT$b = TYPE$o.Ident;
var HASH$4 = TYPE$o.Hash;
var COLON$5 = TYPE$o.Colon;
var SEMICOLON$1 = TYPE$o.Semicolon;
var DELIM$4 = TYPE$o.Delim;
var WHITESPACE$6 = TYPE$o.WhiteSpace;
var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN$3 = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS$3 = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, false);
}

function consumeValue() {
    var startValueToken = this.scanner.tokenIndex;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON$1 &&
        this.scanner.isDelim(EXCLAMATIONMARK$1) === false &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

var Declaration$1 = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.eat(COLON$5);

        const valueStart = this.scanner.tokenIndex;

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
        }

        if (customProperty && value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE$6) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        if (this.scanner.isDelim(EXCLAMATIONMARK$1)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON$1 &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;

    // hacks
    if (this.scanner.tokenType === DELIM$4) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK$3:
            case DOLLARSIGN:
            case PLUSSIGN$3:
            case NUMBERSIGN$2:
            case AMPERSAND:
                this.scanner.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS$3:
                this.scanner.next();
                if (this.scanner.isDelim(SOLIDUS$3)) {
                    this.scanner.next();
                }
                break;
        }
    }

    if (this.scanner.tokenType === HASH$4) {
        this.eat(HASH$4);
    } else {
        this.eat(IDENT$b);
    }

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(DELIM$4);
    this.scanner.skipSC();

    var important = this.consume(IDENT$b);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

var TYPE$n = tokenizer$3.TYPE;
var rawMode$2 = Raw$1.mode;

var WHITESPACE$5 = TYPE$n.WhiteSpace;
var COMMENT$3 = TYPE$n.Comment;
var SEMICOLON = TYPE$n.Semicolon;

function consumeRaw$3(startToken) {
    return this.Raw(startToken, rawMode$2.semicolonIncluded, true);
}

var DeclarationList = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$5:
                case COMMENT$3:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};

var consumeNumber$2 = utils$7.consumeNumber;
var TYPE$m = tokenizer$3.TYPE;

var DIMENSION$4 = TYPE$m.Dimension;

var Dimension$1 = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber$2(this.scanner.source, start);

        this.eat(DIMENSION$4);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};

var TYPE$l = tokenizer$3.TYPE;

var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

// <function-token> <sequence> )
var _Function = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS$5);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};

var TYPE$k = tokenizer$3.TYPE;

var HASH$3 = TYPE$k.Hash;

// '#' ident
var Hash = {
    name: 'Hash',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(HASH$3);

        return {
            type: 'Hash',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};

var TYPE$j = tokenizer$3.TYPE;

var IDENT$a = TYPE$j.Ident;

var Identifier = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT$a)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var TYPE$i = tokenizer$3.TYPE;

var HASH$2 = TYPE$i.Hash;

// <hash-token>
var IdSelector = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // TODO: check value is an ident
        this.eat(HASH$2);

        return {
            type: 'IdSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};

var TYPE$h = tokenizer$3.TYPE;

var IDENT$9 = TYPE$h.Ident;
var NUMBER$5 = TYPE$h.Number;
var DIMENSION$3 = TYPE$h.Dimension;
var LEFTPARENTHESIS$5 = TYPE$h.LeftParenthesis;
var RIGHTPARENTHESIS$4 = TYPE$h.RightParenthesis;
var COLON$4 = TYPE$h.Colon;
var DELIM$3 = TYPE$h.Delim;

var MediaFeature = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.eat(LEFTPARENTHESIS$5);
        this.scanner.skipSC();

        name = this.consume(IDENT$9);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
            this.eat(COLON$4);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER$5:
                    if (this.lookupNonWSType(1) === DELIM$3) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case DIMENSION$3:
                    value = this.Dimension();
                    break;

                case IDENT$9:
                    value = this.Identifier();

                    break;

                default:
                    this.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.eat(RIGHTPARENTHESIS$4);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};

var TYPE$g = tokenizer$3.TYPE;

var WHITESPACE$4 = TYPE$g.WhiteSpace;
var COMMENT$2 = TYPE$g.Comment;
var IDENT$8 = TYPE$g.Ident;
var LEFTPARENTHESIS$4 = TYPE$g.LeftParenthesis;

var MediaQuery = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT$2:
                    this.scanner.next();
                    continue;

                case WHITESPACE$4:
                    space = this.WhiteSpace();
                    continue;

                case IDENT$8:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS$4:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var COMMA$3 = tokenizer$3.TYPE.Comma;

var MediaQueryList = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA$3) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};

var Nth = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};

var NUMBER$4 = tokenizer$3.TYPE.Number;

var _Number$1 = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER$4)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

// '/' | '*' | ',' | ':' | '+' | '-'
var Operator = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var TYPE$f = tokenizer$3.TYPE;

var LEFTPARENTHESIS$3 = TYPE$f.LeftParenthesis;
var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

var Parentheses = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTPARENTHESIS$3);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS$3);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};

var consumeNumber$1 = utils$7.consumeNumber;
var TYPE$e = tokenizer$3.TYPE;

var PERCENTAGE$2 = TYPE$e.Percentage;

var Percentage$1 = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber$1(this.scanner.source, start);

        this.eat(PERCENTAGE$2);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};

var TYPE$d = tokenizer$3.TYPE;

var IDENT$7 = TYPE$d.Ident;
var FUNCTION$5 = TYPE$d.Function;
var COLON$3 = TYPE$d.Colon;
var RIGHTPARENTHESIS$2 = TYPE$d.RightParenthesis;

// : [ <ident> | <function-token> <any-value>? ) ]
var PseudoClassSelector = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON$3);

        if (this.scanner.tokenType === FUNCTION$5) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS$2);
        } else {
            name = this.consume(IDENT$7);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

var TYPE$c = tokenizer$3.TYPE;

var IDENT$6 = TYPE$c.Ident;
var FUNCTION$4 = TYPE$c.Function;
var COLON$2 = TYPE$c.Colon;
var RIGHTPARENTHESIS$1 = TYPE$c.RightParenthesis;

// :: [ <ident> | <function-token> <any-value>? ) ]
var PseudoElementSelector = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON$2);
        this.eat(COLON$2);

        if (this.scanner.tokenType === FUNCTION$4) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS$1);
        } else {
            name = this.consume(IDENT$6);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

var isDigit$1 = tokenizer$3.isDigit;
var TYPE$b = tokenizer$3.TYPE;

var NUMBER$3 = TYPE$b.Number;
var DELIM$2 = TYPE$b.Delim;
var SOLIDUS$2 = 0x002F;  // U+002F SOLIDUS (/)
var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.scanner.skipWS();

    var value = this.consume(NUMBER$3);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isDigit$1(code) && code !== FULLSTOP$1) {
            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
var Ratio = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;

        this.scanner.skipWS();

        if (!this.scanner.isDelim(SOLIDUS$2)) {
            this.error('Solidus is expected');
        }
        this.eat(DELIM$2);
        right = consumeNumber.call(this);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};

var TYPE$a = tokenizer$3.TYPE;
var rawMode$1 = Raw$1.mode;

var LEFTCURLYBRACKET = TYPE$a.LeftCurlyBracket;

function consumeRaw$2(startToken) {
    return this.Raw(startToken, rawMode$1.leftCurlyBracket, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
    }

    return prelude;
}

var Rule$1 = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
        } else {
            prelude = consumeRaw$2.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};

var Selector = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var TYPE$9 = tokenizer$3.TYPE;

var COMMA$2 = TYPE$9.Comma;

var SelectorList = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA$2) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};

var STRING$2 = tokenizer$3.TYPE.String;

var _String$1 = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING$2)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var TYPE$8 = tokenizer$3.TYPE;

var WHITESPACE$3 = TYPE$8.WhiteSpace;
var COMMENT$1 = TYPE$8.Comment;
var ATKEYWORD = TYPE$8.AtKeyword;
var CDO = TYPE$8.CDO;
var CDC = TYPE$8.CDC;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$1(startToken) {
    return this.Raw(startToken, null, false);
}

var StyleSheet = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$3:
                    this.scanner.next();
                    continue;

                case COMMENT$1:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // §2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATKEYWORD:
                    child = this.parseWithFallback(this.Atrule, consumeRaw$1);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw$1);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};

var TYPE$7 = tokenizer$3.TYPE;

var IDENT$5 = TYPE$7.Ident;
var ASTERISK$2 = 0x002A;     // U+002A ASTERISK (*)
var VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENT$5 &&
        this.scanner.isDelim(ASTERISK$2) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
var TypeSelector$1 = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.isDelim(VERTICALLINE$1)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.isDelim(VERTICALLINE$1)) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

var isHexDigit = tokenizer$3.isHexDigit;
var cmpChar$1 = tokenizer$3.cmpChar;
var TYPE$6 = tokenizer$3.TYPE;
var NAME = tokenizer$3.NAME;

var IDENT$4 = TYPE$6.Ident;
var NUMBER$2 = TYPE$6.Number;
var DIMENSION$2 = TYPE$6.Dimension;
var PLUSSIGN$2 = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS$1 = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function eatHexSequence(offset, allowDash) {
    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);

        if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
                this.error();
            }

            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        }    }

    this.scanner.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    var count = 0;

    while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.scanner.next();
    }
}

function startsWith(code) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    var hexLength = 0;

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (this.scanner.isDelim(PLUSSIGN$2)) {
        this.scanner.next();

        if (this.scanner.tokenType === IDENT$4) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
        }

        if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
        }

        this.error('Hex digit or question mark is expected');
        return;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (this.scanner.tokenType === NUMBER$2) {
        startsWith.call(this, PLUSSIGN$2);
        hexLength = eatHexSequence.call(this, 1, true);

        if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
        }

        if (this.scanner.tokenType === DIMENSION$2 ||
            this.scanner.tokenType === NUMBER$2) {
            startsWith.call(this, HYPHENMINUS$1);
            eatHexSequence.call(this, 1, false);
            return;
        }

        return;
    }

    // u <dimension-token> '?'*
    if (this.scanner.tokenType === DIMENSION$2) {
        startsWith.call(this, PLUSSIGN$2);
        hexLength = eatHexSequence.call(this, 1, true);

        if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
        }

        return;
    }

    this.error();
}

var UnicodeRange = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // U or u
        if (!cmpChar$1(this.scanner.source, start, U$1)) {
            this.error('U is expected');
        }

        if (!cmpChar$1(this.scanner.source, start + 1, PLUSSIGN$2)) {
            this.error('Plus sign is expected');
        }

        this.scanner.next();
        scanUnicodeRange.call(this);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var isWhiteSpace = tokenizer$3.isWhiteSpace;
var cmpStr$1 = tokenizer$3.cmpStr;
var TYPE$5 = tokenizer$3.TYPE;

var FUNCTION$3 = TYPE$5.Function;
var URL$2 = TYPE$5.Url;
var RIGHTPARENTHESIS = TYPE$5.RightParenthesis;

// <url-token> | <function-token> <string> )
var Url$1 = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        switch (this.scanner.tokenType) {
            case URL$2:
                var rawStart = start + 4;
                var rawEnd = this.scanner.tokenEnd - 1;

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
                    rawStart++;
                }

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
                    rawEnd--;
                }

                value = {
                    type: 'Raw',
                    loc: this.getLocation(rawStart, rawEnd),
                    value: this.scanner.source.substring(rawStart, rawEnd)
                };

                this.eat(URL$2);
                break;

            case FUNCTION$3:
                if (!cmpStr$1(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
                    this.error('Function name must be `url`');
                }

                this.eat(FUNCTION$3);
                this.scanner.skipSC();
                value = this.String();
                this.scanner.skipSC();
                this.eat(RIGHTPARENTHESIS);
                break;

            default:
                this.error('Url or Function is expected');
        }

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};

var Value$1 = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

var WHITESPACE$2 = tokenizer$3.TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

var WhiteSpace$1 = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.eat(WHITESPACE$2);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

var node = {
    AnPlusB: AnPlusB,
    Atrule: Atrule$2,
    AtrulePrelude: AtrulePrelude,
    AttributeSelector: AttributeSelector$1,
    Block: Block,
    Brackets: Brackets,
    CDC: CDC_1,
    CDO: CDO_1,
    ClassSelector: ClassSelector,
    Combinator: Combinator,
    Comment: Comment$1,
    Declaration: Declaration$1,
    DeclarationList: DeclarationList,
    Dimension: Dimension$1,
    Function: _Function,
    Hash: Hash,
    Identifier: Identifier,
    IdSelector: IdSelector,
    MediaFeature: MediaFeature,
    MediaQuery: MediaQuery,
    MediaQueryList: MediaQueryList,
    Nth: Nth,
    Number: _Number$1,
    Operator: Operator,
    Parentheses: Parentheses,
    Percentage: Percentage$1,
    PseudoClassSelector: PseudoClassSelector,
    PseudoElementSelector: PseudoElementSelector,
    Ratio: Ratio,
    Raw: Raw$1,
    Rule: Rule$1,
    Selector: Selector,
    SelectorList: SelectorList,
    String: _String$1,
    StyleSheet: StyleSheet,
    TypeSelector: TypeSelector$1,
    UnicodeRange: UnicodeRange,
    Url: Url$1,
    Value: Value$1,
    WhiteSpace: WhiteSpace$1
};

var data = data$1;

var lexer$2 = {
    generic: true,
    types: data.types,
    atrules: data.atrules,
    properties: data.properties,
    node: node
};

var cmpChar = tokenizer$3.cmpChar;
var cmpStr = tokenizer$3.cmpStr;
var TYPE$4 = tokenizer$3.TYPE;

var IDENT$3 = TYPE$4.Ident;
var STRING$1 = TYPE$4.String;
var NUMBER$1 = TYPE$4.Number;
var FUNCTION$2 = TYPE$4.Function;
var URL$1 = TYPE$4.Url;
var HASH$1 = TYPE$4.Hash;
var DIMENSION$1 = TYPE$4.Dimension;
var PERCENTAGE$1 = TYPE$4.Percentage;
var LEFTPARENTHESIS$2 = TYPE$4.LeftParenthesis;
var LEFTSQUAREBRACKET$1 = TYPE$4.LeftSquareBracket;
var COMMA$1 = TYPE$4.Comma;
var DELIM$1 = TYPE$4.Delim;
var NUMBERSIGN$1 = 0x0023;  // U+0023 NUMBER SIGN (#)
var ASTERISK$1 = 0x002A;    // U+002A ASTERISK (*)
var PLUSSIGN$1 = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var SOLIDUS$1 = 0x002F;     // U+002F SOLIDUS (/)
var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

var _default = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case HASH$1:
            return this.Hash();

        case COMMA$1:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case LEFTPARENTHESIS$2:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET$1:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING$1:
            return this.String();

        case DIMENSION$1:
            return this.Dimension();

        case PERCENTAGE$1:
            return this.Percentage();

        case NUMBER$1:
            return this.Number();

        case FUNCTION$2:
            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case URL$1:
            return this.Url();

        case IDENT$3:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$1)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case DELIM$1:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            if (code === SOLIDUS$1 ||
                code === ASTERISK$1 ||
                code === PLUSSIGN$1 ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN$1) {
                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
            }

            break;
    }
};

var atrulePrelude = {
    getNode: _default
};

var TYPE$3 = tokenizer$3.TYPE;

var DELIM = TYPE$3.Delim;
var IDENT$2 = TYPE$3.Ident;
var DIMENSION = TYPE$3.Dimension;
var PERCENTAGE = TYPE$3.Percentage;
var NUMBER = TYPE$3.Number;
var HASH = TYPE$3.Hash;
var COLON$1 = TYPE$3.Colon;
var LEFTSQUAREBRACKET = TYPE$3.LeftSquareBracket;
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;           // U+007E TILDE (~)

function getNode(context) {
    switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case HASH:
            return this.IdSelector();

        case COLON$1:
            if (this.scanner.lookupType(1) === COLON$1) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENT$2:
            return this.TypeSelector();

        case NUMBER:
        case PERCENTAGE:
            return this.Percentage();

        case DIMENSION:
            // throws when .123ident
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.scanner.tokenStart + 1);
            }
            break;

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                    context.space = null;
                    context.ignoreWSAfter = true;
                    return this.Combinator();

                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();
            }

            break;
    }
}
var selector = {
    getNode: getNode
};

// legacy IE function
// expression( <any-value> )
var expression = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
};

var TYPE$2 = tokenizer$3.TYPE;
var rawMode = Raw$1.mode;

var COMMA = TYPE$2.Comma;
var WHITESPACE$1 = TYPE$2.WhiteSpace;

// var( <ident> , <value>? )
var _var = function() {
    var children = this.createList();

    this.scanner.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());

        const startIndex = this.scanner.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE$1) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
};

var value = {
    getNode: _default,
    'expression': expression,
    'var': _var
};

var scope = {
    AtrulePrelude: atrulePrelude,
    Selector: selector,
    Value: value
};

var fontFace = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};

var TYPE$1 = tokenizer$3.TYPE;

var STRING = TYPE$1.String;
var IDENT$1 = TYPE$1.Ident;
var URL = TYPE$1.Url;
var FUNCTION$1 = TYPE$1.Function;
var LEFTPARENTHESIS$1 = TYPE$1.LeftParenthesis;

var _import = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL:
                case FUNCTION$1:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === IDENT$1 ||
                this.lookupNonWSType(0) === LEFTPARENTHESIS$1) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

var media = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};

var page = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};

var TYPE = tokenizer$3.TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
}

function parentheses() {
    this.scanner.skipSC();

    if (this.scanner.tokenType === IDENT &&
        this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENT:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

var supports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};

var atrule = {
    'font-face': fontFace,
    'import': _import,
    'media': media,
    'page': page,
    'supports': supports
};

var dir = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

var has = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

var lang = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

var selectorList = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

var matches = selectorList;

var not = selectorList;

var ALLOW_OF_CLAUSE = true;

var nthWithOfClause = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};

var nthChild = nthWithOfClause;

var nthLastChild = nthWithOfClause;

var DISALLOW_OF_CLAUSE = false;

var nth = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};

var nthLastOfType = nth;

var nthOfType = nth;

var slotted = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

var pseudo = {
    'dir': dir,
    'has': has,
    'lang': lang,
    'matches': matches,
    'not': not,
    'nth-child': nthChild,
    'nth-last-child': nthLastChild,
    'nth-last-of-type': nthLastOfType,
    'nth-of-type': nthOfType,
    'slotted': slotted
};

var parser = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: scope,
    atrule: atrule,
    pseudo: pseudo,
    node: node
};

var walker = {
    node: node
};

var name$1 = "css-tree";
var version$1 = "1.1.3";
var description$1 = "A tool set for CSS: fast detailed parser (CSS → AST), walker (AST traversal), generator (AST → CSS) and lexer (validation and matching) based on specs and browser implementations";
var author$1 = "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)";
var license$1 = "MIT";
var repository$1 = "csstree/csstree";
var keywords$1 = [
	"css",
	"ast",
	"tokenizer",
	"parser",
	"walker",
	"lexer",
	"generator",
	"utils",
	"syntax",
	"validation"
];
var main$1 = "lib/index.js";
var unpkg = "dist/csstree.min.js";
var jsdelivr = "dist/csstree.min.js";
var scripts$1 = {
	build: "rollup --config",
	lint: "eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
	"lint-and-test": "npm run lint && npm test",
	"update:docs": "node scripts/update-docs",
	"review:syntax-patch": "node scripts/review-syntax-patch",
	test: "mocha --reporter progress",
	coverage: "nyc npm test",
	travis: "nyc npm run lint-and-test && npm run coveralls",
	coveralls: "nyc report --reporter=text-lcov | coveralls",
	prepublishOnly: "npm run build",
	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
};
var dependencies$1 = {
	"mdn-data": "2.0.14",
	"source-map": "^0.6.1"
};
var devDependencies$1 = {
	"@rollup/plugin-commonjs": "^11.0.2",
	"@rollup/plugin-json": "^4.0.2",
	"@rollup/plugin-node-resolve": "^7.1.1",
	coveralls: "^3.0.9",
	eslint: "^6.8.0",
	"json-to-ast": "^2.1.0",
	mocha: "^6.2.3",
	nyc: "^14.1.1",
	rollup: "^1.32.1",
	"rollup-plugin-terser": "^5.3.0"
};
var engines$1 = {
	node: ">=8.0.0"
};
var files$1 = [
	"data",
	"dist",
	"lib"
];
var require$$4 = {
	name: name$1,
	version: version$1,
	description: description$1,
	author: author$1,
	license: license$1,
	repository: repository$1,
	keywords: keywords$1,
	main: main$1,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	scripts: scripts$1,
	dependencies: dependencies$1,
	devDependencies: devDependencies$1,
	engines: engines$1,
	files: files$1
};

function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

syntax.exports = create$4.create(
    merge(
        lexer$2,
        parser,
        walker
    )
);
syntax.exports.version = require$$4.version;

var lib$1 = syntax.exports;

var specificity$3 = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.children.each(function walk(node) {
        switch (node.type) {
            case 'SelectorList':
            case 'Selector':
                node.children.each(walk);
                break;

            case 'IdSelector':
                A++;
                break;

            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    case 'not':
                        node.children.each(walk);
                        break;

                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()
                    default:
                        B++;
                }
                break;

            case 'PseudoElementSelector':
                C++;
                break;

            case 'TypeSelector':
                // ignore universal selector
                if (node.name.charAt(node.name.length - 1) !== '*') {
                    C++;
                }
                break;

        }
    });

    return [A, B, C];
};

var cssTools$1 = {};

var csstree$5 = lib$1,
  List$6 = csstree$5.List,
  stable$1 = stable$2.exports,
  specificity$2 = specificity$3;

/**
 * Flatten a CSS AST to a selectors list.
 *
 * @param {import('css-tree').CssNode} cssAst css-tree AST to flatten
 * @return {Array} selectors
 */
function flattenToSelectors(cssAst) {
  var selectors = [];

  csstree$5.walk(cssAst, {
    visit: 'Rule',
    enter: function (node) {
      if (node.type !== 'Rule') {
        return;
      }

      var atrule = this.atrule;
      var rule = node;

      node.prelude.children.each(function (selectorNode, selectorItem) {
        var selector = {
          item: selectorItem,
          atrule: atrule,
          rule: rule,
          pseudos: /** @type {{item: any; list: any[]}[]} */ ([]),
        };

        selectorNode.children.each(function (
          selectorChildNode,
          selectorChildItem,
          selectorChildList
        ) {
          if (
            selectorChildNode.type === 'PseudoClassSelector' ||
            selectorChildNode.type === 'PseudoElementSelector'
          ) {
            selector.pseudos.push({
              item: selectorChildItem,
              list: selectorChildList,
            });
          }
        });

        selectors.push(selector);
      });
    },
  });

  return selectors;
}

/**
 * Filter selectors by Media Query.
 *
 * @param {Array} selectors to filter
 * @param {Array} useMqs Array with strings of media queries that should pass (<name> <expression>)
 * @return {Array} Filtered selectors that match the passed media queries
 */
function filterByMqs(selectors, useMqs) {
  return selectors.filter(function (selector) {
    if (selector.atrule === null) {
      return ~useMqs.indexOf('');
    }

    var mqName = selector.atrule.name;
    var mqStr = mqName;
    if (
      selector.atrule.expression &&
      selector.atrule.expression.children.first().type === 'MediaQueryList'
    ) {
      var mqExpr = csstree$5.generate(selector.atrule.expression);
      mqStr = [mqName, mqExpr].join(' ');
    }

    return ~useMqs.indexOf(mqStr);
  });
}

/**
 * Filter selectors by the pseudo-elements and/or -classes they contain.
 *
 * @param {Array} selectors to filter
 * @param {Array} usePseudos Array with strings of single or sequence of pseudo-elements and/or -classes that should pass
 * @return {Array} Filtered selectors that match the passed pseudo-elements and/or -classes
 */
function filterByPseudos(selectors, usePseudos) {
  return selectors.filter(function (selector) {
    var pseudoSelectorsStr = csstree$5.generate({
      type: 'Selector',
      children: new List$6().fromArray(
        selector.pseudos.map(function (pseudo) {
          return pseudo.item.data;
        })
      ),
    });
    return ~usePseudos.indexOf(pseudoSelectorsStr);
  });
}

/**
 * Remove pseudo-elements and/or -classes from the selectors for proper matching.
 *
 * @param {Array} selectors to clean
 * @return {void}
 */
function cleanPseudos(selectors) {
  selectors.forEach(function (selector) {
    selector.pseudos.forEach(function (pseudo) {
      pseudo.list.remove(pseudo.item);
    });
  });
}

/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @param {Array} aSpecificity Specificity of selector A
 * @param {Array} bSpecificity Specificity of selector B
 * @return {number} Score of selector specificity A compared to selector specificity B
 */
function compareSpecificity$1(aSpecificity, bSpecificity) {
  for (var i = 0; i < 4; i += 1) {
    if (aSpecificity[i] < bSpecificity[i]) {
      return -1;
    } else if (aSpecificity[i] > bSpecificity[i]) {
      return 1;
    }
  }

  return 0;
}

/**
 * Compare two simple selectors.
 *
 * @param {Object} aSimpleSelectorNode Simple selector A
 * @param {Object} bSimpleSelectorNode Simple selector B
 * @return {number} Score of selector A compared to selector B
 */
function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
  var aSpecificity = specificity$2(aSimpleSelectorNode),
    bSpecificity = specificity$2(bSimpleSelectorNode);
  return compareSpecificity$1(aSpecificity, bSpecificity);
}

function _bySelectorSpecificity(selectorA, selectorB) {
  return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
}

/**
 * Sort selectors stably by their specificity.
 *
 * @param {Array} selectors to be sorted
 * @return {Array} Stable sorted selectors
 */
function sortSelectors(selectors) {
  return stable$1(selectors, _bySelectorSpecificity);
}

/**
 * Convert a css-tree AST style declaration to CSSStyleDeclaration property.
 *
 * @param {import('css-tree').CssNode} declaration css-tree style declaration
 * @return {Object} CSSStyleDeclaration property
 */
function csstreeToStyleDeclaration(declaration) {
  var propertyName = declaration.property,
    propertyValue = csstree$5.generate(declaration.value),
    propertyPriority = declaration.important ? 'important' : '';
  return {
    name: propertyName,
    value: propertyValue,
    priority: propertyPriority,
  };
}

/**
 * Gets the CSS string of a style element
 *
 * @param {Object} elem style element
 * @return {string} CSS string or empty array if no styles are set
 */
function getCssStr(elem) {
  if (
    elem.children.length > 0 &&
    (elem.children[0].type === 'text' || elem.children[0].type === 'cdata')
  ) {
    return elem.children[0].value;
  }
  return '';
}

/**
 * Sets the CSS string of a style element
 *
 * @param {Object} elem style element
 * @param {string} css string to be set
 * @return {string} reference to field with CSS
 */
function setCssStr(elem, css) {
  if (elem.children.length === 0) {
    elem.children.push({
      type: 'text',
      value: '',
    });
  }

  if (elem.children[0].type !== 'text' && elem.children[0].type !== 'cdata') {
    return css;
  }

  elem.children[0].value = css;

  return css;
}

cssTools$1.flattenToSelectors = flattenToSelectors;

cssTools$1.filterByMqs = filterByMqs;
cssTools$1.filterByPseudos = filterByPseudos;
cssTools$1.cleanPseudos = cleanPseudos;

cssTools$1.compareSpecificity = compareSpecificity$1;
cssTools$1.compareSimpleSelectorNode = compareSimpleSelectorNode;

cssTools$1.sortSelectors = sortSelectors;

cssTools$1.csstreeToStyleDeclaration = csstreeToStyleDeclaration;

cssTools$1.getCssStr = getCssStr;
cssTools$1.setCssStr = setCssStr;

const stable = stable$2.exports;
const csstree$4 = lib$1;
const specificity$1 = specificity$3;
const { selectAll: selectAll$1, is: is$1 } = lib$9;
const svgoCssSelectAdapter$1 = cssSelectAdapter;
const { compareSpecificity } = cssTools$1;
const {
  attrsGroups: attrsGroups$3,
  inheritableAttrs: inheritableAttrs$2,
  presentationNonInheritableGroupAttrs: presentationNonInheritableGroupAttrs$1,
} = _collections;

const cssSelectOptions = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter$1,
};

const parseRule = (ruleNode, dynamic) => {
  let selectors;
  let selectorsSpecificity;
  const declarations = [];
  csstree$4.walk(ruleNode, (cssNode) => {
    if (cssNode.type === 'SelectorList') {
      // compute specificity from original node to consider pseudo classes
      selectorsSpecificity = specificity$1(cssNode);
      const newSelectorsNode = csstree$4.clone(cssNode);
      csstree$4.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
        if (pseudoClassNode.type === 'PseudoClassSelector') {
          dynamic = true;
          list.remove(item);
        }
      });
      selectors = csstree$4.generate(newSelectorsNode);
      return csstree$4.walk.skip;
    }
    if (cssNode.type === 'Declaration') {
      declarations.push({
        name: cssNode.property,
        value: csstree$4.generate(cssNode.value),
        important: cssNode.important,
      });
      return csstree$4.walk.skip;
    }
  });
  return {
    dynamic,
    selectors,
    specificity: selectorsSpecificity,
    declarations,
  };
};

const parseStylesheet = (css, dynamic) => {
  const rules = [];
  const ast = csstree$4.parse(css);
  csstree$4.walk(ast, (cssNode) => {
    if (cssNode.type === 'Rule') {
      rules.push(parseRule(cssNode, dynamic || false));
      return csstree$4.walk.skip;
    }
    if (cssNode.type === 'Atrule') {
      if (cssNode.name === 'keyframes') {
        return csstree$4.walk.skip;
      }
      csstree$4.walk(cssNode, (ruleNode) => {
        if (ruleNode.type === 'Rule') {
          rules.push(parseRule(ruleNode, dynamic || true));
          return csstree$4.walk.skip;
        }
      });
      return csstree$4.walk.skip;
    }
  });
  return rules;
};

const computeOwnStyle = (node, stylesheet) => {
  const computedStyle = {};
  const importantStyles = new Map();

  // collect attributes
  for (const [name, value] of Object.entries(node.attributes)) {
    if (attrsGroups$3.presentation.includes(name)) {
      computedStyle[name] = { type: 'static', inherited: false, value };
      importantStyles.set(name, false);
    }
  }

  // collect matching rules
  for (const { selectors, declarations, dynamic } of stylesheet) {
    if (is$1(node, selectors, cssSelectOptions)) {
      for (const { name, value, important } of declarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === 'dynamic') {
          continue;
        }
        if (dynamic) {
          computedStyle[name] = { type: 'dynamic', inherited: false };
          continue;
        }
        if (
          computed == null ||
          important === true ||
          importantStyles.get(name) === false
        ) {
          computedStyle[name] = { type: 'static', inherited: false, value };
          importantStyles.set(name, important);
        }
      }
    }
  }

  // collect inline styles
  for (const [name, { value, priority }] of node.style.properties) {
    const computed = computedStyle[name];
    const important = priority === 'important';
    if (computed && computed.type === 'dynamic') {
      continue;
    }
    if (
      computed == null ||
      important === true ||
      importantStyles.get(name) === false
    ) {
      computedStyle[name] = { type: 'static', inherited: false, value };
      importantStyles.set(name, important);
    }
  }

  return computedStyle;
};

const computeStyle$3 = (node) => {
  // find root
  let root = node;
  while (root.parentNode) {
    root = root.parentNode;
  }
  // find all styles
  const styleNodes = selectAll$1('style', root, cssSelectOptions);
  // parse all styles
  const stylesheet = [];
  for (const styleNode of styleNodes) {
    const dynamic =
      styleNode.attributes.media != null &&
      styleNode.attributes.media !== 'all';
    if (
      styleNode.attributes.type == null ||
      styleNode.attributes.type === '' ||
      styleNode.attributes.type === 'text/css'
    ) {
      const children = styleNode.children;
      for (const child of children) {
        if (child.type === 'text' || child.type === 'cdata') {
          stylesheet.push(...parseStylesheet(child.value, dynamic));
        }
      }
    }
  }
  // sort by selectors specificity
  stable.inplace(stylesheet, (a, b) =>
    compareSpecificity(a.specificity, b.specificity)
  );

  // collect inherited styles
  const computedStyles = computeOwnStyle(node, stylesheet);
  let parent = node;
  while (parent.parentNode && parent.parentNode.type !== 'root') {
    const inheritedStyles = computeOwnStyle(parent.parentNode, stylesheet);
    for (const [name, computed] of Object.entries(inheritedStyles)) {
      if (
        computedStyles[name] == null &&
        // ignore not inheritable styles
        inheritableAttrs$2.includes(name) === true &&
        presentationNonInheritableGroupAttrs$1.includes(name) === false
      ) {
        computedStyles[name] = { ...computed, inherited: true };
      }
    }
    parent = parent.parentNode;
  }

  return computedStyles;
};
style.computeStyle = computeStyle$3;

var _path$1 = {};

var path = {};

// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF

const argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7,
};

/**
 * @param {string} c
 */
const isCommand = (c) => {
  return c in argsCountPerCommand;
};

/**
 * @param {string} c
 */
const isWsp = (c) => {
  const codePoint = c.codePointAt(0);
  return (
    codePoint === 0x20 ||
    codePoint === 0x9 ||
    codePoint === 0xd ||
    codePoint === 0xa
  );
};

/**
 * @param {string} c
 */
const isDigit = (c) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};

/**
 * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState
 */

/**
 * @param {string} string
 * @param {number} cursor
 * @return {[number, number | null]}
 */
const readNumber = (string, cursor) => {
  let i = cursor;
  let value = '';
  let state = /** @type {ReadNumberState} */ ('none');
  for (; i < string.length; i += 1) {
    const c = string[i];
    if (c === '+' || c === '-') {
      if (state === 'none') {
        state = 'sign';
        value += c;
        continue;
      }
      if (state === 'e') {
        state = 'exponent_sign';
        value += c;
        continue;
      }
    }
    if (isDigit(c)) {
      if (state === 'none' || state === 'sign' || state === 'whole') {
        state = 'whole';
        value += c;
        continue;
      }
      if (state === 'decimal_point' || state === 'decimal') {
        state = 'decimal';
        value += c;
        continue;
      }
      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {
        state = 'exponent';
        value += c;
        continue;
      }
    }
    if (c === '.') {
      if (state === 'none' || state === 'sign' || state === 'whole') {
        state = 'decimal_point';
        value += c;
        continue;
      }
    }
    if (c === 'E' || c == 'e') {
      if (
        state === 'whole' ||
        state === 'decimal_point' ||
        state === 'decimal'
      ) {
        state = 'e';
        value += c;
        continue;
      }
    }
    break;
  }
  const number = Number.parseFloat(value);
  if (Number.isNaN(number)) {
    return [cursor, null];
  } else {
    // step back to delegate iteration to parent loop
    return [i - 1, number];
  }
};

/**
 * @param {string} string
 */
const parsePathData$2 = (string) => {
  const pathData = [];
  let command = null;
  let args = /** @type {number[]} */ ([]);
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i = 0; i < string.length; i += 1) {
    const c = string.charAt(i);
    if (isWsp(c)) {
      continue;
    }
    // allow comma only between arguments
    if (canHaveComma && c === ',') {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        // moveto should be leading command
        if (c !== 'M' && c !== 'm') {
          return pathData;
        }
      } else {
        // stop if previous command arguments are not flushed
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      // flush command without arguments
      if (argsCount === 0) {
        pathData.push({ command, args });
      }
      continue;
    }
    // avoid parsing arguments if no command detected
    if (command == null) {
      return pathData;
    }
    // read next argument
    let newCursor = i;
    let number = null;
    if (command === 'A' || command === 'a') {
      const position = args.length;
      if (position === 0 || position === 1) {
        // allow only positive number without sign as first two arguments
        if (c !== '+' && c !== '-') {
          [newCursor, number] = readNumber(string, i);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number] = readNumber(string, i);
      }
      if (position === 3 || position === 4) {
        // read flags
        if (c === '0') {
          number = 0;
        }
        if (c === '1') {
          number = 1;
        }
      }
    } else {
      [newCursor, number] = readNumber(string, i);
    }
    if (number == null) {
      return pathData;
    }
    args.push(number);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    // flush arguments when necessary count is reached
    if (args.length === argsCount) {
      pathData.push({ command, args });
      // subsequent moveto coordinates are threated as implicit lineto commands
      if (command === 'M') {
        command = 'L';
      }
      if (command === 'm') {
        command = 'l';
      }
      args = [];
    }
  }
  return pathData;
};
path.parsePathData = parsePathData$2;

/**
 * @typedef {{
 *   number: number;
 *   precision?: number;
 * }} StringifyNumberOptions
 */
/**
 * @param {StringifyNumberOptions} param
 */
const stringifyNumber = ({ number, precision }) => {
  if (precision != null) {
    const ratio = 10 ** precision;
    number = Math.round(number * ratio) / ratio;
  }
  // remove zero whole from decimal number
  return number.toString().replace(/^0\./, '.').replace(/^-0\./, '-.');
};

/**
 * @typedef {{
 *   command: string;
 *   args: number[];
 *   precision?: number;
 *   disableSpaceAfterFlags?: boolean;
 * }} StringifyArgsOptions
 */
/**
 *
 * Elliptical arc large-arc and sweep flags are rendered with spaces
 * because many non-browser environments are not able to parse such paths
 *
 * @param {StringifyArgsOptions} param
 */
const stringifyArgs = ({
  command,
  args,
  precision,
  disableSpaceAfterFlags,
}) => {
  let result = '';
  let prev = '';
  for (let i = 0; i < args.length; i += 1) {
    const number = args[i];
    const numberString = stringifyNumber({ number, precision });
    if (
      disableSpaceAfterFlags &&
      (command === 'A' || command === 'a') &&
      (i === 4 || i === 5)
    ) {
      result += numberString;
    } else if (i === 0 || numberString.startsWith('-')) {
      // avoid space before first and negative numbers
      result += numberString;
    } else if (prev.includes('.') && numberString.startsWith('.')) {
      // remove space before decimal with zero whole
      // only when previous number is also decimal
      result += numberString;
    } else {
      result += ` ${numberString}`;
    }
    prev = numberString;
  }
  return result;
};

/**
 *
 * @typedef {{
 *   command: string;
 *   args: number[];
 * }} Command
 */
/**
 * @typedef {{
 *   pathData: Command[];
 *   precision?: number;
 *   disableSpaceAfterFlags?: boolean;
 * }} StringifyPathDataOptions
 */
/**
 * @param {StringifyPathDataOptions} param
 */
const stringifyPathData$2 = ({ pathData, precision, disableSpaceAfterFlags }) => {
  // combine sequence of the same commands
  let combined = [];
  for (let i = 0; i < pathData.length; i += 1) {
    const { command, args } = pathData[i];
    if (i === 0) {
      combined.push({ command, args });
    } else {
      const last = combined[combined.length - 1];
      // match leading moveto with following lineto
      if (i === 1) {
        if (command === 'L') {
          last.command = 'M';
        }
        if (command === 'l') {
          last.command = 'm';
        }
      }
      if (
        (last.command === command &&
          last.command !== 'M' &&
          last.command !== 'm') ||
        // combine matching moveto and lineto sequences
        (last.command === 'M' && command === 'L') ||
        (last.command === 'm' && command === 'l')
      ) {
        last.args = [...last.args, ...args];
      } else {
        combined.push({ command, args });
      }
    }
  }
  let result = '';
  for (const { command, args } of combined) {
    result +=
      command +
      stringifyArgs({ command, args, precision, disableSpaceAfterFlags });
  }
  return result;
};
path.stringifyPathData = stringifyPathData$2;

const { parsePathData: parsePathData$1, stringifyPathData: stringifyPathData$1 } = path;

var prevCtrlPoint;

/**
 * Convert path string to JS representation.
 *
 * @param {String} pathString input string
 * @param {Object} params plugin params
 * @return {Array} output array
 */
_path$1.path2js = function (path) {
  if (path.pathJS) return path.pathJS;
  const pathData = []; // JS representation of the path data
  const newPathData = parsePathData$1(path.attributes.d);
  for (const { command, args } of newPathData) {
    if (command === 'Z' || command === 'z') {
      pathData.push({ instruction: 'z' });
    } else {
      pathData.push({ instruction: command, data: args });
    }
  }
  // First moveto is actually absolute. Subsequent coordinates were separated above.
  if (pathData.length && pathData[0].instruction == 'm') {
    pathData[0].instruction = 'M';
  }
  path.pathJS = pathData;
  return pathData;
};

/**
 * Convert relative Path data to absolute.
 *
 * @param {Array} data input data
 * @return {Array} output data
 */
var relative2absolute = (_path$1.relative2absolute = function (data) {
  var currentPoint = [0, 0],
    subpathPoint = [0, 0],
    i;

  return data.map(function (item) {
    var instruction = item.instruction,
      itemData = item.data && item.data.slice();

    if (instruction == 'M') {
      set(currentPoint, itemData);
      set(subpathPoint, itemData);
    } else if ('mlcsqt'.indexOf(instruction) > -1) {
      for (i = 0; i < itemData.length; i++) {
        itemData[i] += currentPoint[i % 2];
      }
      set(currentPoint, itemData);

      if (instruction == 'm') {
        set(subpathPoint, itemData);
      }
    } else if (instruction == 'a') {
      itemData[5] += currentPoint[0];
      itemData[6] += currentPoint[1];
      set(currentPoint, itemData);
    } else if (instruction == 'h') {
      itemData[0] += currentPoint[0];
      currentPoint[0] = itemData[0];
    } else if (instruction == 'v') {
      itemData[0] += currentPoint[1];
      currentPoint[1] = itemData[0];
    } else if ('MZLCSQTA'.indexOf(instruction) > -1) {
      set(currentPoint, itemData);
    } else if (instruction == 'H') {
      currentPoint[0] = itemData[0];
    } else if (instruction == 'V') {
      currentPoint[1] = itemData[0];
    } else if (instruction == 'z') {
      set(currentPoint, subpathPoint);
    }

    return instruction == 'z'
      ? { instruction: 'z' }
      : {
          instruction: instruction.toUpperCase(),
          data: itemData,
        };
  });
});

/**
 * Compute Cubic Bézie bounding box.
 *
 * @see https://pomax.github.io/bezierinfo/
 *
 * @param {Float} xa
 * @param {Float} ya
 * @param {Float} xb
 * @param {Float} yb
 * @param {Float} xc
 * @param {Float} yc
 * @param {Float} xd
 * @param {Float} yd
 *
 * @return {Object}
 */
_path$1.computeCubicBoundingBox = function (xa, ya, xb, yb, xc, yc, xd, yd) {
  var minx = Number.POSITIVE_INFINITY,
    miny = Number.POSITIVE_INFINITY,
    maxx = Number.NEGATIVE_INFINITY,
    maxy = Number.NEGATIVE_INFINITY,
    ts,
    t,
    x,
    y,
    i;

  // X
  if (xa < minx) {
    minx = xa;
  }
  if (xa > maxx) {
    maxx = xa;
  }
  if (xd < minx) {
    minx = xd;
  }
  if (xd > maxx) {
    maxx = xd;
  }

  ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);

  for (i = 0; i < ts.length; i++) {
    t = ts[i];

    if (t >= 0 && t <= 1) {
      x = computeCubicBaseValue(t, xa, xb, xc, xd);
      // y = computeCubicBaseValue(t, ya, yb, yc, yd);

      if (x < minx) {
        minx = x;
      }
      if (x > maxx) {
        maxx = x;
      }
    }
  }

  // Y
  if (ya < miny) {
    miny = ya;
  }
  if (ya > maxy) {
    maxy = ya;
  }
  if (yd < miny) {
    miny = yd;
  }
  if (yd > maxy) {
    maxy = yd;
  }

  ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);

  for (i = 0; i < ts.length; i++) {
    t = ts[i];

    if (t >= 0 && t <= 1) {
      // x = computeCubicBaseValue(t, xa, xb, xc, xd);
      y = computeCubicBaseValue(t, ya, yb, yc, yd);

      if (y < miny) {
        miny = y;
      }
      if (y > maxy) {
        maxy = y;
      }
    }
  }

  return {
    minx: minx,
    miny: miny,
    maxx: maxx,
    maxy: maxy,
  };
};

// compute the value for the cubic bezier function at time=t
function computeCubicBaseValue(t, a, b, c, d) {
  var mt = 1 - t;

  return (
    mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d
  );
}

// compute the value for the first derivative of the cubic bezier function at time=t
function computeCubicFirstDerivativeRoots(a, b, c, d) {
  var result = [-1, -1],
    tl = -a + 2 * b - c,
    tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),
    dn = -a + 3 * b - 3 * c + d;

  if (dn !== 0) {
    result[0] = (tl + tr) / dn;
    result[1] = (tl - tr) / dn;
  }

  return result;
}

/**
 * Compute Quadratic Bézier bounding box.
 *
 * @see https://pomax.github.io/bezierinfo/
 *
 * @param {Float} xa
 * @param {Float} ya
 * @param {Float} xb
 * @param {Float} yb
 * @param {Float} xc
 * @param {Float} yc
 *
 * @return {Object}
 */
_path$1.computeQuadraticBoundingBox = function (xa, ya, xb, yb, xc, yc) {
  var minx = Number.POSITIVE_INFINITY,
    miny = Number.POSITIVE_INFINITY,
    maxx = Number.NEGATIVE_INFINITY,
    maxy = Number.NEGATIVE_INFINITY,
    t,
    x,
    y;

  // X
  if (xa < minx) {
    minx = xa;
  }
  if (xa > maxx) {
    maxx = xa;
  }
  if (xc < minx) {
    minx = xc;
  }
  if (xc > maxx) {
    maxx = xc;
  }

  t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);

  if (t >= 0 && t <= 1) {
    x = computeQuadraticBaseValue(t, xa, xb, xc);
    // y = computeQuadraticBaseValue(t, ya, yb, yc);

    if (x < minx) {
      minx = x;
    }
    if (x > maxx) {
      maxx = x;
    }
  }

  // Y
  if (ya < miny) {
    miny = ya;
  }
  if (ya > maxy) {
    maxy = ya;
  }
  if (yc < miny) {
    miny = yc;
  }
  if (yc > maxy) {
    maxy = yc;
  }

  t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);

  if (t >= 0 && t <= 1) {
    // x = computeQuadraticBaseValue(t, xa, xb, xc);
    y = computeQuadraticBaseValue(t, ya, yb, yc);

    if (y < miny) {
      miny = y;
    }
    if (y > maxy) {
      maxy = y;
    }
  }

  return {
    minx: minx,
    miny: miny,
    maxx: maxx,
    maxy: maxy,
  };
};

// compute the value for the quadratic bezier function at time=t
function computeQuadraticBaseValue(t, a, b, c) {
  var mt = 1 - t;

  return mt * mt * a + 2 * mt * t * b + t * t * c;
}

// compute the value for the first derivative of the quadratic bezier function at time=t
function computeQuadraticFirstDerivativeRoot(a, b, c) {
  var t = -1,
    denominator = a - 2 * b + c;

  if (denominator !== 0) {
    t = (a - b) / denominator;
  }

  return t;
}

/**
 * Convert path array to string.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {String} output path string
 */
_path$1.js2path = function (path, data, params) {
  path.pathJS = data;

  const pathData = [];
  for (const item of data) {
    // remove moveto commands which are followed by moveto commands
    if (
      pathData.length !== 0 &&
      (item.instruction === 'M' || item.instruction === 'm')
    ) {
      const last = pathData[pathData.length - 1];
      if (last.command === 'M' || last.command === 'm') {
        pathData.pop();
      }
    }
    pathData.push({
      command: item.instruction,
      args: item.data || [],
    });
  }

  path.attributes.d = stringifyPathData$1({
    pathData,
    precision: params.floatPrecision,
    disableSpaceAfterFlags: params.noSpaceAfterFlags,
  });
};

function set(dest, source) {
  dest[0] = source[source.length - 2];
  dest[1] = source[source.length - 1];
  return dest;
}

/**
 * Checks if two paths have an intersection by checking convex hulls
 * collision using Gilbert-Johnson-Keerthi distance algorithm
 * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/
 *
 * @param {Array} path1 JS path representation
 * @param {Array} path2 JS path representation
 * @return {Boolean}
 */
_path$1.intersects = function (path1, path2) {
  // Collect points of every subpath.
  var points1 = relative2absolute(path1).reduce(gatherPoints, []),
    points2 = relative2absolute(path2).reduce(gatherPoints, []);

  // Axis-aligned bounding box check.
  if (
    points1.maxX <= points2.minX ||
    points2.maxX <= points1.minX ||
    points1.maxY <= points2.minY ||
    points2.maxY <= points1.minY ||
    points1.every(function (set1) {
      return points2.every(function (set2) {
        return (
          set1[set1.maxX][0] <= set2[set2.minX][0] ||
          set2[set2.maxX][0] <= set1[set1.minX][0] ||
          set1[set1.maxY][1] <= set2[set2.minY][1] ||
          set2[set2.maxY][1] <= set1[set1.minY][1]
        );
      });
    })
  )
    return false;

  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).
  var hullNest1 = points1.map(convexHull),
    hullNest2 = points2.map(convexHull);

  // Check intersection of every subpath of the first path with every subpath of the second.
  return hullNest1.some(function (hull1) {
    if (hull1.length < 3) return false;

    return hullNest2.some(function (hull2) {
      if (hull2.length < 3) return false;

      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex
        direction = minus(simplex[0]); // set the direction to point towards the origin

      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough
      // eslint-disable-next-line no-constant-condition
      while (true) {
        // eslint-disable-next-line no-constant-condition
        if (iterations-- == 0) {
          console.error(
            'Error: infinite loop while processing mergePaths plugin.'
          );
          return true; // true is the safe value that means “do nothing with paths”
        }
        // add a new point
        simplex.push(getSupport(hull1, hull2, direction));
        // see if the new point was on the correct side of the origin
        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
        // process the simplex
        if (processSimplex(simplex, direction)) return true;
      }
    });
  });

  function getSupport(a, b, direction) {
    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
  }

  // Computes farthest polygon point in particular direction.
  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.
  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.
  function supportPoint(polygon, direction) {
    var index =
        direction[1] >= 0
          ? direction[0] < 0
            ? polygon.maxY
            : polygon.maxX
          : direction[0] < 0
          ? polygon.minX
          : polygon.minY,
      max = -Infinity,
      value;
    while ((value = dot(polygon[index], direction)) > max) {
      max = value;
      index = ++index % polygon.length;
    }
    return polygon[(index || polygon.length) - 1];
  }
};

function processSimplex(simplex, direction) {
  // we only need to handle to 1-simplex and 2-simplex
  if (simplex.length == 2) {
    // 1-simplex
    let a = simplex[1],
      b = simplex[0],
      AO = minus(simplex[1]),
      AB = sub(b, a);
    // AO is in the same direction as AB
    if (dot(AO, AB) > 0) {
      // get the vector perpendicular to AB facing O
      set(direction, orth(AB, a));
    } else {
      set(direction, AO);
      // only A remains in the simplex
      simplex.shift();
    }
  } else {
    // 2-simplex
    let a = simplex[2], // [a, b, c] = simplex
      b = simplex[1],
      c = simplex[0],
      AB = sub(b, a),
      AC = sub(c, a),
      AO = minus(a),
      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C
      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B

    if (dot(ACB, AO) > 0) {
      if (dot(AB, AO) > 0) {
        // region 4
        set(direction, ACB);
        simplex.shift(); // simplex = [b, a]
      } else {
        // region 5
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } else if (dot(ABC, AO) > 0) {
      if (dot(AC, AO) > 0) {
        // region 6
        set(direction, ABC);
        simplex.splice(1, 1); // simplex = [c, a]
      } else {
        // region 5 (again)
        set(direction, AO);
        simplex.splice(0, 2); // simplex = [a]
      }
    } // region 7
    else return true;
  }
  return false;
}

function minus(v) {
  return [-v[0], -v[1]];
}

function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}

function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}

function orth(v, from) {
  var o = [-v[1], v[0]];
  return dot(o, minus(from)) < 0 ? minus(o) : o;
}

function gatherPoints(points, item, index, path) {
  var subPath = points.length && points[points.length - 1],
    prev = index && path[index - 1],
    basePoint = subPath.length && subPath[subPath.length - 1],
    data = item.data,
    ctrlPoint = basePoint;

  switch (item.instruction) {
    case 'M':
      points.push((subPath = []));
      break;
    case 'H':
      addPoint(subPath, [data[0], basePoint[1]]);
      break;
    case 'V':
      addPoint(subPath, [basePoint[0], data[0]]);
      break;
    case 'Q':
      addPoint(subPath, data.slice(0, 2));
      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand
      break;
    case 'T':
      if (prev.instruction == 'Q' || prev.instruction == 'T') {
        ctrlPoint = [
          basePoint[0] + prevCtrlPoint[0],
          basePoint[1] + prevCtrlPoint[1],
        ];
        addPoint(subPath, ctrlPoint);
        prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
      }
      break;
    case 'C':
      // Approximate quibic Bezier curve with middle points between control points
      addPoint(subPath, [
        0.5 * (basePoint[0] + data[0]),
        0.5 * (basePoint[1] + data[1]),
      ]);
      addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);
      addPoint(subPath, [0.5 * (data[2] + data[4]), 0.5 * (data[3] + data[5])]);
      prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand
      break;
    case 'S':
      if (prev.instruction == 'C' || prev.instruction == 'S') {
        addPoint(subPath, [
          basePoint[0] + 0.5 * prevCtrlPoint[0],
          basePoint[1] + 0.5 * prevCtrlPoint[1],
        ]);
        ctrlPoint = [
          basePoint[0] + prevCtrlPoint[0],
          basePoint[1] + prevCtrlPoint[1],
        ];
      }
      addPoint(subPath, [
        0.5 * (ctrlPoint[0] + data[0]),
        0.5 * (ctrlPoint[1] + data[1]),
      ]);
      addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);
      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
      break;
    case 'A':
      // Convert the arc to bezier curves and use the same approximation
      var curves = a2c.apply(0, basePoint.concat(data));
      for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
        addPoint(subPath, [
          0.5 * (basePoint[0] + cData[0]),
          0.5 * (basePoint[1] + cData[1]),
        ]);
        addPoint(subPath, [
          0.5 * (cData[0] + cData[2]),
          0.5 * (cData[1] + cData[3]),
        ]);
        addPoint(subPath, [
          0.5 * (cData[2] + cData[4]),
          0.5 * (cData[3] + cData[5]),
        ]);
        if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));
      }
      break;
  }
  // Save final command coordinates
  if (data && data.length >= 2) addPoint(subPath, data.slice(-2));
  return points;

  function toAbsolute(n, i) {
    return n + basePoint[i % 2];
  }

  // Writes data about the extreme points on each axle
  function addPoint(path, point) {
    if (!path.length || point[1] > path[path.maxY][1]) {
      path.maxY = path.length;
      points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];
    }
    if (!path.length || point[0] > path[path.maxX][0]) {
      path.maxX = path.length;
      points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];
    }
    if (!path.length || point[1] < path[path.minY][1]) {
      path.minY = path.length;
      points.minY = points.length ? Math.min(point[1], points.minY) : point[1];
    }
    if (!path.length || point[0] < path[path.minX][0]) {
      path.minX = path.length;
      points.minX = points.length ? Math.min(point[0], points.minX) : point[0];
    }
    path.push(point);
  }
}

/**
 * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.
 * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
 *
 * @param points An array of [X, Y] coordinates
 */
function convexHull(points) {
  points.sort(function (a, b) {
    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
  });

  var lower = [],
    minY = 0,
    bottom = 0;
  for (let i = 0; i < points.length; i++) {
    while (
      lower.length >= 2 &&
      cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0
    ) {
      lower.pop();
    }
    if (points[i][1] < points[minY][1]) {
      minY = i;
      bottom = lower.length;
    }
    lower.push(points[i]);
  }

  var upper = [],
    maxY = points.length - 1,
    top = 0;
  for (let i = points.length; i--; ) {
    while (
      upper.length >= 2 &&
      cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0
    ) {
      upper.pop();
    }
    if (points[i][1] > points[maxY][1]) {
      maxY = i;
      top = upper.length;
    }
    upper.push(points[i]);
  }

  // last points are equal to starting points of the other part
  upper.pop();
  lower.pop();

  var hull = lower.concat(upper);

  hull.minX = 0; // by sorting
  hull.maxX = lower.length;
  hull.minY = bottom;
  hull.maxY = (lower.length + top) % hull.length;

  return hull;
}

function cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/
 * Thanks to Dmitry Baranovskiy for his great work!
 */

function a2c(
  x1,
  y1,
  rx,
  ry,
  angle,
  large_arc_flag,
  sweep_flag,
  x2,
  y2,
  recursive
) {
  // for more information of where this Math came from visit:
  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  var _120 = (Math.PI * 120) / 180,
    rad = (Math.PI / 180) * (+angle || 0),
    res = [],
    rotateX = function (x, y, rad) {
      return x * Math.cos(rad) - y * Math.sin(rad);
    },
    rotateY = function (x, y, rad) {
      return x * Math.sin(rad) + y * Math.cos(rad);
    };
  if (!recursive) {
    x1 = rotateX(x1, y1, -rad);
    y1 = rotateY(x1, y1, -rad);
    x2 = rotateX(x2, y2, -rad);
    y2 = rotateY(x2, y2, -rad);
    var x = (x1 - x2) / 2,
      y = (y1 - y2) / 2;
    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx,
      ry2 = ry * ry,
      k =
        (large_arc_flag == sweep_flag ? -1 : 1) *
        Math.sqrt(
          Math.abs(
            (rx2 * ry2 - rx2 * y * y - ry2 * x * x) /
              (rx2 * y * y + ry2 * x * x)
          )
        ),
      cx = (k * rx * y) / ry + (x1 + x2) / 2,
      cy = (k * -ry * x) / rx + (y1 + y2) / 2,
      f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),
      f2 = Math.asin(((y2 - cy) / ry).toFixed(9));

    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2,
      x2old = x2,
      y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy,
    ]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1),
    s1 = Math.sin(f1),
    c2 = Math.cos(f2),
    s2 = Math.sin(f2),
    t = Math.tan(df / 4),
    hx = (4 / 3) * rx * t,
    hy = (4 / 3) * ry * t,
    m = [
      -hx * s1,
      hy * c1,
      x2 + hx * s2 - x1,
      y2 - hy * c2 - y1,
      x2 - x1,
      y2 - y1,
    ];
  if (recursive) {
    return m.concat(res);
  } else {
    res = m.concat(res);
    var newres = [];
    for (var i = 0, n = res.length; i < n; i++) {
      newres[i] =
        i % 2
          ? rotateY(res[i - 1], res[i], rad)
          : rotateX(res[i], res[i + 1], rad);
    }
    return newres;
  }
}

var _applyTransforms = {};

var _transforms = {};

var regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,
  regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/,
  regNumericValues$1 = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Convert transform string to JS representation.
 *
 * @param {String} transformString input string
 * @param {Object} params plugin params
 * @return {Array} output array
 */
_transforms.transform2js = function (transformString) {
  // JS representation of the transform data
  var transforms = [],
    // current transform context
    current;

  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']
  transformString.split(regTransformSplit).forEach(function (item) {
    var num;

    if (item) {
      // if item is a translate function
      if (regTransformTypes.test(item)) {
        // then collect it and change current context
        transforms.push((current = { name: item }));
        // else if item is data
      } else {
        // then split it into [10, 50] and collect as context.data
        // eslint-disable-next-line no-cond-assign
        while ((num = regNumericValues$1.exec(item))) {
          num = Number(num);
          if (current.data) current.data.push(num);
          else current.data = [num];
        }
      }
    }
  });

  // return empty array if broken transform (no data)
  return current && current.data ? transforms : [];
};

/**
 * Multiply transforms into one.
 *
 * @param {Array} input transforms array
 * @return {Array} output matrix array
 */
_transforms.transformsMultiply = function (transforms) {
  // convert transforms objects to the matrices
  transforms = transforms.map(function (transform) {
    if (transform.name === 'matrix') {
      return transform.data;
    }
    return transformToMatrix(transform);
  });

  // multiply all matrices into one
  transforms = {
    name: 'matrix',
    data:
      transforms.length > 0 ? transforms.reduce(multiplyTransformMatrices) : [],
  };

  return transforms;
};

/**
 * Do math like a schoolgirl.
 *
 * @type {Object}
 */
var mth = (_transforms.mth = {
  rad: function (deg) {
    return (deg * Math.PI) / 180;
  },

  deg: function (rad) {
    return (rad * 180) / Math.PI;
  },

  cos: function (deg) {
    return Math.cos(this.rad(deg));
  },

  acos: function (val, floatPrecision) {
    return +this.deg(Math.acos(val)).toFixed(floatPrecision);
  },

  sin: function (deg) {
    return Math.sin(this.rad(deg));
  },

  asin: function (val, floatPrecision) {
    return +this.deg(Math.asin(val)).toFixed(floatPrecision);
  },

  tan: function (deg) {
    return Math.tan(this.rad(deg));
  },

  atan: function (val, floatPrecision) {
    return +this.deg(Math.atan(val)).toFixed(floatPrecision);
  },
});

/**
 * Decompose matrix into simple transforms. See
 * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html
 *
 * @param {Object} data matrix transform object
 * @return {Object|Array} transforms array or original transform object
 */
_transforms.matrixToTransform = function (transform, params) {
  var floatPrecision = params.floatPrecision,
    data = transform.data,
    transforms = [],
    sx = +Math.hypot(data[0], data[1]).toFixed(params.transformPrecision),
    sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
      params.transformPrecision
    ),
    colsSum = data[0] * data[2] + data[1] * data[3],
    rowsSum = data[0] * data[1] + data[2] * data[3],
    scaleBefore = rowsSum != 0 || sx == sy;

  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)
  if (data[4] || data[5]) {
    transforms.push({
      name: 'translate',
      data: data.slice(4, data[5] ? 6 : 5),
    });
  }

  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)
  if (!data[1] && data[2]) {
    transforms.push({
      name: 'skewX',
      data: [mth.atan(data[2] / sy, floatPrecision)],
    });

    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)
  } else if (data[1] && !data[2]) {
    transforms.push({
      name: 'skewY',
      data: [mth.atan(data[1] / data[0], floatPrecision)],
    });
    sx = data[0];
    sy = data[3];

    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or
    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)
  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {
    if (!scaleBefore) {
      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
      transforms.push({ name: 'scale', data: [sx, sy] });
    }
    var angle = Math.min(Math.max(-1, data[0] / sx), 1),
      rotate = [
        mth.acos(angle, floatPrecision) *
          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
      ];

    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });

    if (rowsSum && colsSum)
      transforms.push({
        name: 'skewX',
        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
      });

    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)
    if (rotate[0] && (data[4] || data[5])) {
      transforms.shift();
      var cos = data[0] / sx,
        sin = data[1] / (scaleBefore ? sx : sy),
        x = data[4] * (scaleBefore || sy),
        y = data[5] * (scaleBefore || sx),
        denom =
          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);
      rotate.push(((1 - cos) * x - sin * y) / denom);
      rotate.push(((1 - cos) * y + sin * x) / denom);
    }

    // Too many transformations, return original matrix if it isn't just a scale/translate
  } else if (data[1] || data[2]) {
    return transform;
  }

  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)
    transforms.push({
      name: 'scale',
      data: sx == sy ? [sx] : [sx, sy],
    });

  return transforms;
};

/**
 * Convert transform to the matrix data.
 *
 * @param {Object} transform transform object
 * @return {Array} matrix data
 */
function transformToMatrix(transform) {
  if (transform.name === 'matrix') return transform.data;

  var matrix;

  switch (transform.name) {
    case 'translate':
      // [1, 0, 0, 1, tx, ty]
      matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
      break;
    case 'scale':
      // [sx, 0, 0, sy, 0, 0]
      matrix = [
        transform.data[0],
        0,
        0,
        transform.data[1] || transform.data[0],
        0,
        0,
      ];
      break;
    case 'rotate':
      // [cos(a), sin(a), -sin(a), cos(a), x, y]
      var cos = mth.cos(transform.data[0]),
        sin = mth.sin(transform.data[0]),
        cx = transform.data[1] || 0,
        cy = transform.data[2] || 0;

      matrix = [
        cos,
        sin,
        -sin,
        cos,
        (1 - cos) * cx + sin * cy,
        (1 - cos) * cy - sin * cx,
      ];
      break;
    case 'skewX':
      // [1, 0, tan(a), 1, 0, 0]
      matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
      break;
    case 'skewY':
      // [1, tan(a), 0, 1, 0, 0]
      matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
      break;
  }

  return matrix;
}

/**
 * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it
 * by the transformation matrix and use a singular value decomposition to represent in a form
 * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.
 * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})
 *
 * @param {Array} cursor [x, y]
 * @param {Array} arc [a, b, rotation in deg]
 * @param {Array} transform transformation matrix
 * @return {Array} arc transformed input arc
 */
_transforms.transformArc = function (cursor, arc, transform) {
  const x = arc[5] - cursor[0];
  const y = arc[6] - cursor[1];
  var a = arc[0],
    b = arc[1],
    rot = (arc[2] * Math.PI) / 180,
    cos = Math.cos(rot),
    sin = Math.sin(rot),
    h =
      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
      Math.pow(y * cos - x * sin, 2) / (4 * b * b);
  if (h > 1) {
    h = Math.sqrt(h);
    a *= h;
    b *= h;
  }
  var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],
    m = multiplyTransformMatrices(transform, ellipse),
    // Decompose the new ellipse matrix
    lastCol = m[2] * m[2] + m[3] * m[3],
    squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,
    root =
      Math.hypot(m[0] - m[3], m[1] + m[2]) *
      Math.hypot(m[0] + m[3], m[1] - m[2]);

  if (!root) {
    // circle
    arc[0] = arc[1] = Math.sqrt(squareSum / 2);
    arc[2] = 0;
  } else {
    var majorAxisSqr = (squareSum + root) / 2,
      minorAxisSqr = (squareSum - root) / 2,
      major = Math.abs(majorAxisSqr - lastCol) > 1e-6,
      sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,
      rowsSum = m[0] * m[2] + m[1] * m[3],
      term1 = m[0] * sub + m[2] * rowsSum,
      term2 = m[1] * sub + m[3] * rowsSum;
    arc[0] = Math.sqrt(majorAxisSqr);
    arc[1] = Math.sqrt(minorAxisSqr);
    arc[2] =
      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
        180) /
      Math.PI;
  }

  if (transform[0] < 0 !== transform[3] < 0) {
    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically
    arc[4] = 1 - arc[4];
  }

  return arc;
};

/**
 * Multiply transformation matrices.
 *
 * @param {Array} a matrix A data
 * @param {Array} b matrix B data
 * @return {Array} result
 */
function multiplyTransformMatrices(a, b) {
  return [
    a[0] * b[0] + a[2] * b[1],
    a[1] * b[0] + a[3] * b[1],
    a[0] * b[2] + a[2] * b[3],
    a[1] * b[2] + a[3] * b[3],
    a[0] * b[4] + a[2] * b[5] + a[4],
    a[1] * b[4] + a[3] * b[5] + a[5],
  ];
}

// TODO implement as separate plugin

const {
  transformsMultiply: transformsMultiply$1,
  transform2js: transform2js$1,
  transformArc,
} = _transforms;
const { removeLeadingZero } = tools;
const { referencesProps: referencesProps$2, attrsGroupsDefaults: attrsGroupsDefaults$1 } = _collections;

const regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
const defaultStrokeWidth = attrsGroupsDefaults$1.presentation['stroke-width'];

/**
 * Apply transformation(s) to the Path data.
 *
 * @param {Object} elem current element
 * @param {Array} path input path data
 * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)
 * @return {Array} output path data
 */
const applyTransforms$1 = (elem, pathData, params) => {
  // if there are no 'stroke' attr and references to other objects such as
  // gradiends or clip-path which are also subjects to transform.
  if (
    elem.attributes.transform == null ||
    elem.attributes.transform === '' ||
    // styles are not considered when applying transform
    // can be fixed properly with new style engine
    elem.attributes.style != null ||
    Object.entries(elem.attributes).some(
      ([name, value]) =>
        referencesProps$2.includes(name) && value.includes('url(')
    )
  ) {
    return;
  }

  const matrix = transformsMultiply$1(transform2js$1(elem.attributes.transform));
  const stroke = elem.computedAttr('stroke');
  const id = elem.computedAttr('id');
  const transformPrecision = params.transformPrecision;

  if (stroke && stroke != 'none') {
    if (
      !params.applyTransformsStroked ||
      ((matrix.data[0] != matrix.data[3] ||
        matrix.data[1] != -matrix.data[2]) &&
        (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
    )
      return;

    // "stroke-width" should be inside the part with ID, otherwise it can be overrided in <use>
    if (id) {
      let idElem = elem;
      let hasStrokeWidth = false;

      do {
        if (idElem.attributes['stroke-width']) {
          hasStrokeWidth = true;
        }
      } while (
        idElem.attributes.id !== id &&
        !hasStrokeWidth &&
        (idElem = idElem.parentNode)
      );

      if (!hasStrokeWidth) return;
    }

    const scale = +Math.sqrt(
      matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
    ).toFixed(transformPrecision);

    if (scale !== 1) {
      const strokeWidth =
        elem.computedAttr('stroke-width') || defaultStrokeWidth;

      if (
        elem.attributes['vector-effect'] == null ||
        elem.attributes['vector-effect'] !== 'non-scaling-stroke'
      ) {
        if (elem.attributes['stroke-width'] != null) {
          elem.attributes['stroke-width'] = elem.attributes['stroke-width']
            .trim()
            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
        } else {
          elem.attributes[
            'stroke-width'
          ] = strokeWidth.replace(regNumericValues, (num) =>
            removeLeadingZero(num * scale)
          );
        }

        if (elem.attributes['stroke-dashoffset'] != null) {
          elem.attributes['stroke-dashoffset'] = elem.attributes[
            'stroke-dashoffset'
          ]
            .trim()
            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
        }

        if (elem.attributes['stroke-dasharray'] != null) {
          elem.attributes['stroke-dasharray'] = elem.attributes[
            'stroke-dasharray'
          ]
            .trim()
            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
        }
      }
    }
  } else if (id) {
    // Stroke and stroke-width can be redefined with <use>
    return;
  }

  applyMatrixToPathData(pathData, matrix.data);

  // remove transform attr
  delete elem.attributes.transform;

  return;
};
_applyTransforms.applyTransforms = applyTransforms$1;

const transformAbsolutePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y + matrix[4];
  const newY = matrix[1] * x + matrix[3] * y + matrix[5];
  return [newX, newY];
};

const transformRelativePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y;
  const newY = matrix[1] * x + matrix[3] * y;
  return [newX, newY];
};

const applyMatrixToPathData = (pathData, matrix) => {
  let cursor = [0, 0];

  for (const pathItem of pathData) {
    let { instruction: command, data: args } = pathItem;
    // moveto (x y)
    if (command === 'M') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 'm') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // horizontal lineto (x)
    // convert to lineto to handle two-dimentional transforms
    if (command === 'H') {
      command = 'L';
      args = [args[0], cursor[1]];
    }
    if (command === 'h') {
      command = 'l';
      args = [args[0], 0];
    }

    // vertical lineto (y)
    // convert to lineto to handle two-dimentional transforms
    if (command === 'V') {
      command = 'L';
      args = [cursor[0], args[0]];
    }
    if (command === 'v') {
      command = 'l';
      args = [0, args[0]];
    }

    // lineto (x y)
    if (command === 'L') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 'l') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'C') {
      cursor[0] = args[4];
      cursor[1] = args[5];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }
    if (command === 'c') {
      cursor[0] += args[4];
      cursor[1] += args[5];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }

    // smooth curveto (x2 y2 x y)
    if (command === 'S') {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }
    if (command === 's') {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }

    // quadratic Bézier curveto (x1 y1 x y)
    if (command === 'Q') {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }
    if (command === 'q') {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }

    // smooth quadratic Bézier curveto (x y)
    if (command === 'T') {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === 't') {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'A') {
      transformArc(cursor, args, matrix);
      cursor[0] = args[5];
      cursor[1] = args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }
    if (command === 'a') {
      transformArc([0, 0], args, matrix);
      cursor[0] += args[5];
      cursor[1] += args[6];
      // reduce number of digits in rotation angle
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }

    pathItem.instruction = command;
    pathItem.data = args;
  }
};

const { computeStyle: computeStyle$2 } = style;
const { pathElems: pathElems$2 } = _collections;
const { path2js: path2js$2, js2path: js2path$1 } = _path$1;
const { applyTransforms } = _applyTransforms;
const { cleanupOutData: cleanupOutData$1 } = tools;

convertPathData.type = 'visitor';
convertPathData.active = true;
convertPathData.description =
  'optimizes path data: writes in shorter form, applies transformations';

convertPathData.params = {
  applyTransforms: true,
  applyTransformsStroked: true,
  makeArcs: {
    threshold: 2.5, // coefficient of rounding error
    tolerance: 0.5, // percentage of radius
  },
  straightCurves: true,
  lineShorthands: true,
  curveSmoothShorthands: true,
  floatPrecision: 3,
  transformPrecision: 5,
  removeUseless: true,
  collapseRepeated: true,
  utilizeAbsolute: true,
  leadingZero: true,
  negativeExtraSpace: true,
  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20
  forceAbsolutePath: false,
};

let roundData;
let precision;
let error;
let arcThreshold;
let arcTolerance;

/**
 * Convert absolute Path to relative,
 * collapse repeated instructions,
 * detect and convert Lineto shorthands,
 * remove useless instructions like "l0,0",
 * trim useless delimiters and leading zeros,
 * decrease accuracy of floating-point numbers.
 *
 * @see https://www.w3.org/TR/SVG11/paths.html#PathData
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertPathData.fn = (root, params) => {
  return {
    element: {
      enter: (node) => {
        if (pathElems$2.includes(node.name) && node.attributes.d != null) {
          const computedStyle = computeStyle$2(node);
          precision = params.floatPrecision;
          error =
            precision !== false
              ? +Math.pow(0.1, precision).toFixed(precision)
              : 1e-2;
          roundData = precision > 0 && precision < 20 ? strongRound : round$1;
          if (params.makeArcs) {
            arcThreshold = params.makeArcs.threshold;
            arcTolerance = params.makeArcs.tolerance;
          }
          const hasMarkerMid = computedStyle['marker-mid'] != null;

          const maybeHasStroke =
            computedStyle.stroke &&
            (computedStyle.stroke.type === 'dynamic' ||
              computedStyle.stroke.value !== 'none');
          const maybeHasLinecap =
            computedStyle['stroke-linecap'] &&
            (computedStyle['stroke-linecap'].type === 'dynamic' ||
              computedStyle['stroke-linecap'].value !== 'butt');
          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;

          var data = path2js$2(node);

          // TODO: get rid of functions returns
          if (data.length) {
            if (params.applyTransforms) {
              applyTransforms(node, data, params);
            }

            convertToRelative(data);

            data = filters(data, params, {
              maybeHasStrokeAndLinecap,
              hasMarkerMid,
            });

            if (params.utilizeAbsolute) {
              data = convertToMixed(data, params);
            }

            js2path$1(node, data, params);
          }
        }
      },
    },
  };
};

/**
 * Convert absolute path data coordinates to relative.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
const convertToRelative = (pathData) => {
  let start = [0, 0];
  let cursor = [0, 0];
  let prevCoords = [0, 0];

  for (let i = 0; i < pathData.length; i += 1) {
    const pathItem = pathData[i];
    let { instruction: command, data: args } = pathItem;

    // moveto (x y)
    if (command === 'm') {
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === 'M') {
      // M → m
      // skip first moveto
      if (i !== 0) {
        command = 'm';
      }
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // lineto (x y)
    if (command === 'l') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'L') {
      // L → l
      command = 'l';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // horizontal lineto (x)
    if (command === 'h') {
      cursor[0] += args[0];
    }
    if (command === 'H') {
      // H → h
      command = 'h';
      args[0] -= cursor[0];
      cursor[0] += args[0];
    }

    // vertical lineto (y)
    if (command === 'v') {
      cursor[1] += args[0];
    }
    if (command === 'V') {
      // V → v
      command = 'v';
      args[0] -= cursor[1];
      cursor[1] += args[0];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'c') {
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === 'C') {
      // C → c
      command = 'c';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      args[4] -= cursor[0];
      args[5] -= cursor[1];
      cursor[0] += args[4];
      cursor[1] += args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === 's') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'S') {
      // S → s
      command = 's';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // quadratic Bézier curveto (x1 y1 x y)
    if (command === 'q') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'Q') {
      // Q → q
      command = 'q';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // smooth quadratic Bézier curveto (x y)
    if (command === 't') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'T') {
      // T → t
      command = 't';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'a') {
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === 'A') {
      // A → a
      command = 'a';
      args[5] -= cursor[0];
      args[6] -= cursor[1];
      cursor[0] += args[5];
      cursor[1] += args[6];
    }

    // closepath
    if (command === 'Z' || command === 'z') {
      // reset cursor
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.instruction = command;
    pathItem.data = args;
    // store absolute coordinates for later use
    // base should preserve reference from other element
    pathItem.base = prevCoords;
    pathItem.coords = [cursor[0], cursor[1]];
    prevCoords = pathItem.coords;
  }

  return pathData;
};

/**
 * Main filters loop.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
  var stringify = data2Path.bind(null, params),
    relSubpoint = [0, 0],
    pathBase = [0, 0],
    prev = {};

  path = path.filter(function (item, index, path) {
    var instruction = item.instruction,
      data = item.data,
      next = path[index + 1];

    if (data) {
      var sdata = data,
        circle;

      if (instruction === 's') {
        sdata = [0, 0].concat(data);

        if ('cs'.indexOf(prev.instruction) > -1) {
          var pdata = prev.data,
            n = pdata.length;

          // (-x, -y) of the prev tangent point relative to the current point
          sdata[0] = pdata[n - 2] - pdata[n - 4];
          sdata[1] = pdata[n - 1] - pdata[n - 3];
        }
      }

      // convert curves to arcs if possible
      if (
        params.makeArcs &&
        (instruction == 'c' || instruction == 's') &&
        isConvex(sdata) &&
        (circle = findCircle(sdata))
      ) {
        var r = roundData([circle.radius])[0],
          angle = findArcAngle(sdata, circle),
          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
          arc = {
            instruction: 'a',
            data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
            coords: item.coords.slice(),
            base: item.base,
          },
          output = [arc],
          // relative coordinates to adjust the found circle
          relCenter = [
            circle.center[0] - sdata[4],
            circle.center[1] - sdata[5],
          ],
          relCircle = { center: relCenter, radius: circle.radius },
          arcCurves = [item],
          hasPrev = 0,
          suffix = '',
          nextLonghand;

        if (
          (prev.instruction == 'c' &&
            isConvex(prev.data) &&
            isArcPrev(prev.data, circle)) ||
          (prev.instruction == 'a' &&
            prev.sdata &&
            isArcPrev(prev.sdata, circle))
        ) {
          arcCurves.unshift(prev);
          arc.base = prev.base;
          arc.data[5] = arc.coords[0] - arc.base[0];
          arc.data[6] = arc.coords[1] - arc.base[1];
          var prevData = prev.instruction == 'a' ? prev.sdata : prev.data;
          var prevAngle = findArcAngle(prevData, {
            center: [
              prevData[4] + circle.center[0],
              prevData[5] + circle.center[1],
            ],
            radius: circle.radius,
          });
          angle += prevAngle;
          if (angle > Math.PI) arc.data[3] = 1;
          hasPrev = 1;
        }

        // check if next curves are fitting the arc
        for (
          var j = index;
          (next = path[++j]) && ~'cs'.indexOf(next.instruction);

        ) {
          var nextData = next.data;
          if (next.instruction == 's') {
            nextLonghand = makeLonghand(
              { instruction: 's', data: next.data.slice() },
              path[j - 1].data
            );
            nextData = nextLonghand.data;
            nextLonghand.data = nextData.slice(0, 2);
            suffix = stringify([nextLonghand]);
          }
          if (isConvex(nextData) && isArc(nextData, relCircle)) {
            angle += findArcAngle(nextData, relCircle);
            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°
            if (angle > Math.PI) arc.data[3] = 1;
            arcCurves.push(next);
            if (2 * Math.PI - angle > 1e-3) {
              // less than 360°
              arc.coords = next.coords;
              arc.data[5] = arc.coords[0] - arc.base[0];
              arc.data[6] = arc.coords[1] - arc.base[1];
            } else {
              // full circle, make a half-circle arc and add a second one
              arc.data[5] = 2 * (relCircle.center[0] - nextData[4]);
              arc.data[6] = 2 * (relCircle.center[1] - nextData[5]);
              arc.coords = [
                arc.base[0] + arc.data[5],
                arc.base[1] + arc.data[6],
              ];
              arc = {
                instruction: 'a',
                data: [
                  r,
                  r,
                  0,
                  0,
                  sweep,
                  next.coords[0] - arc.coords[0],
                  next.coords[1] - arc.coords[1],
                ],
                coords: next.coords,
                base: arc.coords,
              };
              output.push(arc);
              j++;
              break;
            }
            relCenter[0] -= nextData[4];
            relCenter[1] -= nextData[5];
          } else break;
        }

        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
          if (path[j] && path[j].instruction == 's') {
            makeLonghand(path[j], path[j - 1].data);
          }
          if (hasPrev) {
            var prevArc = output.shift();
            roundData(prevArc.data);
            relSubpoint[0] += prevArc.data[5] - prev.data[prev.data.length - 2];
            relSubpoint[1] += prevArc.data[6] - prev.data[prev.data.length - 1];
            prev.instruction = 'a';
            prev.data = prevArc.data;
            item.base = prev.coords = prevArc.coords;
          }
          arc = output.shift();
          if (arcCurves.length == 1) {
            item.sdata = sdata.slice(); // preserve curve data for future checks
          } else if (arcCurves.length - 1 - hasPrev > 0) {
            // filter out consumed next items
            path.splice.apply(
              path,
              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
            );
          }
          if (!arc) return false;
          instruction = 'a';
          data = arc.data;
          item.coords = arc.coords;
        }
      }

      // Rounding relative coordinates, taking in account accummulating error
      // to get closer to absolute coordinates. Sum of rounded value remains same:
      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
      if (precision !== false) {
        if ('mltqsc'.indexOf(instruction) > -1) {
          for (var i = data.length; i--; ) {
            data[i] += item.base[i % 2] - relSubpoint[i % 2];
          }
        } else if (instruction == 'h') {
          data[0] += item.base[0] - relSubpoint[0];
        } else if (instruction == 'v') {
          data[0] += item.base[1] - relSubpoint[1];
        } else if (instruction == 'a') {
          data[5] += item.base[0] - relSubpoint[0];
          data[6] += item.base[1] - relSubpoint[1];
        }
        roundData(data);

        if (instruction == 'h') relSubpoint[0] += data[0];
        else if (instruction == 'v') relSubpoint[1] += data[0];
        else {
          relSubpoint[0] += data[data.length - 2];
          relSubpoint[1] += data[data.length - 1];
        }
        roundData(relSubpoint);

        if (instruction.toLowerCase() == 'm') {
          pathBase[0] = relSubpoint[0];
          pathBase[1] = relSubpoint[1];
        }
      }

      // convert straight curves into lines segments
      if (params.straightCurves) {
        if (
          (instruction === 'c' && isCurveStraightLine(data)) ||
          (instruction === 's' && isCurveStraightLine(sdata))
        ) {
          if (next && next.instruction == 's') makeLonghand(next, data); // fix up next curve
          instruction = 'l';
          data = data.slice(-2);
        } else if (instruction === 'q' && isCurveStraightLine(data)) {
          if (next && next.instruction == 't') makeLonghand(next, data); // fix up next curve
          instruction = 'l';
          data = data.slice(-2);
        } else if (
          instruction === 't' &&
          prev.instruction !== 'q' &&
          prev.instruction !== 't'
        ) {
          instruction = 'l';
          data = data.slice(-2);
        } else if (instruction === 'a' && (data[0] === 0 || data[1] === 0)) {
          instruction = 'l';
          data = data.slice(-2);
        }
      }

      // horizontal and vertical line shorthands
      // l 50 0 → h 50
      // l 0 50 → v 50
      if (params.lineShorthands && instruction === 'l') {
        if (data[1] === 0) {
          instruction = 'h';
          data.pop();
        } else if (data[0] === 0) {
          instruction = 'v';
          data.shift();
        }
      }

      // collapse repeated commands
      // h 20 h 30 -> h 50
      if (
        params.collapseRepeated &&
        hasMarkerMid === false &&
        'mhv'.indexOf(instruction) > -1 &&
        prev.instruction &&
        instruction == prev.instruction.toLowerCase() &&
        ((instruction != 'h' && instruction != 'v') ||
          prev.data[0] >= 0 == data[0] >= 0)
      ) {
        prev.data[0] += data[0];
        if (instruction != 'h' && instruction != 'v') {
          prev.data[1] += data[1];
        }
        prev.coords = item.coords;
        path[index] = prev;
        return false;
      }

      // convert curves into smooth shorthands
      if (params.curveSmoothShorthands && prev.instruction) {
        // curveto
        if (instruction === 'c') {
          // c + c → c + s
          if (
            prev.instruction === 'c' &&
            data[0] === -(prev.data[2] - prev.data[4]) &&
            data[1] === -(prev.data[3] - prev.data[5])
          ) {
            instruction = 's';
            data = data.slice(2);
          }

          // s + c → s + s
          else if (
            prev.instruction === 's' &&
            data[0] === -(prev.data[0] - prev.data[2]) &&
            data[1] === -(prev.data[1] - prev.data[3])
          ) {
            instruction = 's';
            data = data.slice(2);
          }

          // [^cs] + c → [^cs] + s
          else if (
            'cs'.indexOf(prev.instruction) === -1 &&
            data[0] === 0 &&
            data[1] === 0
          ) {
            instruction = 's';
            data = data.slice(2);
          }
        }

        // quadratic Bézier curveto
        else if (instruction === 'q') {
          // q + q → q + t
          if (
            prev.instruction === 'q' &&
            data[0] === prev.data[2] - prev.data[0] &&
            data[1] === prev.data[3] - prev.data[1]
          ) {
            instruction = 't';
            data = data.slice(2);
          }

          // t + q → t + t
          else if (
            prev.instruction === 't' &&
            data[2] === prev.data[0] &&
            data[3] === prev.data[1]
          ) {
            instruction = 't';
            data = data.slice(2);
          }
        }
      }

      // remove useless non-first path segments
      if (params.removeUseless && !maybeHasStrokeAndLinecap) {
        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0
        if (
          'lhvqtcs'.indexOf(instruction) > -1 &&
          data.every(function (i) {
            return i === 0;
          })
        ) {
          path[index] = prev;
          return false;
        }

        // a 25,25 -30 0,1 0,0
        if (instruction === 'a' && data[5] === 0 && data[6] === 0) {
          path[index] = prev;
          return false;
        }
      }

      item.instruction = instruction;
      item.data = data;

      prev = item;
    } else {
      // z resets coordinates
      relSubpoint[0] = pathBase[0];
      relSubpoint[1] = pathBase[1];
      if (prev.instruction == 'z') return false;
      prev = item;
    }

    return true;
  });

  return path;
}

/**
 * Writes data in shortest form using absolute or relative coordinates.
 *
 * @param {Array} data input path data
 * @return {Boolean} output
 */
function convertToMixed(path, params) {
  var prev = path[0];

  path = path.filter(function (item, index) {
    if (index == 0) return true;
    if (!item.data) {
      prev = item;
      return true;
    }

    var instruction = item.instruction,
      data = item.data,
      adata = data && data.slice(0);

    if ('mltqsc'.indexOf(instruction) > -1) {
      for (var i = adata.length; i--; ) {
        adata[i] += item.base[i % 2];
      }
    } else if (instruction == 'h') {
      adata[0] += item.base[0];
    } else if (instruction == 'v') {
      adata[0] += item.base[1];
    } else if (instruction == 'a') {
      adata[5] += item.base[0];
      adata[6] += item.base[1];
    }

    roundData(adata);

    var absoluteDataStr = cleanupOutData$1(adata, params),
      relativeDataStr = cleanupOutData$1(data, params);

    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.
    // v-20 -> V0
    // Don't convert if it fits following previous instruction.
    // l20 30-10-50 instead of l20 30L20 30
    if (
      params.forceAbsolutePath ||
      (absoluteDataStr.length < relativeDataStr.length &&
        !(
          params.negativeExtraSpace &&
          instruction == prev.instruction &&
          prev.instruction.charCodeAt(0) > 96 &&
          absoluteDataStr.length == relativeDataStr.length - 1 &&
          (data[0] < 0 ||
            (/^0\./.test(data[0]) && prev.data[prev.data.length - 1] % 1))
        ))
    ) {
      item.instruction = instruction.toUpperCase();
      item.data = adata;
    }

    prev = item;

    return true;
  });

  return path;
}

/**
 * Checks if curve is convex. Control points of such a curve must form
 * a convex quadrilateral with diagonals crosspoint inside of it.
 *
 * @param {Array} data input path data
 * @return {Boolean} output
 */
function isConvex(data) {
  var center = getIntersection([
    0,
    0,
    data[2],
    data[3],
    data[0],
    data[1],
    data[4],
    data[5],
  ]);

  return (
    center &&
    data[2] < center[0] == center[0] < 0 &&
    data[3] < center[1] == center[1] < 0 &&
    data[4] < center[0] == center[0] < data[0] &&
    data[5] < center[1] == center[1] < data[1]
  );
}

/**
 * Computes lines equations by two points and returns their intersection point.
 *
 * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)
 * @return {Array|undefined} output coordinate of lines' crosspoint
 */
function getIntersection(coords) {
  // Prev line equation parameters.
  var a1 = coords[1] - coords[3], // y1 - y2
    b1 = coords[2] - coords[0], // x2 - x1
    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1
    // Next line equation parameters
    a2 = coords[5] - coords[7], // y1 - y2
    b2 = coords[6] - coords[4], // x2 - x1
    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1
    denom = a1 * b2 - a2 * b1;

  if (!denom) return; // parallel lines havn't an intersection

  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
  if (
    !isNaN(cross[0]) &&
    !isNaN(cross[1]) &&
    isFinite(cross[0]) &&
    isFinite(cross[1])
  ) {
    return cross;
  }
}

/**
 * Decrease accuracy of floating-point numbers
 * in path data keeping a specified number of decimals.
 * Smart rounds values like 2.3491 to 2.35 instead of 2.349.
 * Doesn't apply "smartness" if the number precision fits already.
 *
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function strongRound(data) {
  for (var i = data.length; i-- > 0; ) {
    if (data[i].toFixed(precision) != data[i]) {
      var rounded = +data[i].toFixed(precision - 1);
      data[i] =
        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error
          ? +data[i].toFixed(precision)
          : rounded;
    }
  }
  return data;
}

/**
 * Simple rounding function if precision is 0.
 *
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function round$1(data) {
  for (var i = data.length; i-- > 0; ) {
    data[i] = Math.round(data[i]);
  }
  return data;
}

/**
 * Checks if a curve is a straight line by measuring distance
 * from middle points to the line formed by end points.
 *
 * @param {Array} xs array of curve points x-coordinates
 * @param {Array} ys array of curve points y-coordinates
 * @return {Boolean}
 */

function isCurveStraightLine(data) {
  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.
  var i = data.length - 2,
    a = -data[i + 1], // y1 − y2 (y1 = 0)
    b = data[i], // x2 − x1 (x1 = 0)
    d = 1 / (a * a + b * b); // same part for all points

  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case

  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))
  while ((i -= 2) >= 0) {
    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
      return false;
  }

  return true;
}

/**
 * Converts next curve from shorthand to full form using the current curve data.
 *
 * @param {Object} item curve to convert
 * @param {Array} data current curve data
 */

function makeLonghand(item, data) {
  switch (item.instruction) {
    case 's':
      item.instruction = 'c';
      break;
    case 't':
      item.instruction = 'q';
      break;
  }
  item.data.unshift(
    data[data.length - 2] - data[data.length - 4],
    data[data.length - 1] - data[data.length - 3]
  );
  return item;
}

/**
 * Returns distance between two points
 *
 * @param {Array} point1 first point coordinates
 * @param {Array} point2 second point coordinates
 * @return {Number} distance
 */

function getDistance(point1, point2) {
  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
}

/**
 * Returns coordinates of the curve point corresponding to the certain t
 * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,
 * where pN are control points and p1 is zero due to relative coordinates.
 *
 * @param {Array} curve array of curve points coordinates
 * @param {Number} t parametric position from 0 to 1
 * @return {Array} Point coordinates
 */

function getCubicBezierPoint(curve, t) {
  var sqrT = t * t,
    cubT = sqrT * t,
    mt = 1 - t,
    sqrMt = mt * mt;

  return [
    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
  ];
}

/**
 * Finds circle by 3 points of the curve and checks if the curve fits the found circle.
 *
 * @param {Array} curve
 * @return {Object|undefined} circle
 */

function findCircle(curve) {
  var midPoint = getCubicBezierPoint(curve, 1 / 2),
    m1 = [midPoint[0] / 2, midPoint[1] / 2],
    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
    center = getIntersection([
      m1[0],
      m1[1],
      m1[0] + m1[1],
      m1[1] - m1[0],
      m2[0],
      m2[1],
      m2[0] + (m2[1] - midPoint[1]),
      m2[1] - (m2[0] - midPoint[0]),
    ]),
    radius = center && getDistance([0, 0], center),
    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);

  if (
    center &&
    radius < 1e15 &&
    [1 / 4, 3 / 4].every(function (point) {
      return (
        Math.abs(
          getDistance(getCubicBezierPoint(curve, point), center) - radius
        ) <= tolerance
      );
    })
  )
    return { center: center, radius: radius };
}

/**
 * Checks if a curve fits the given circle.
 *
 * @param {Object} circle
 * @param {Array} curve
 * @return {Boolean}
 */

function isArc(curve, circle) {
  var tolerance = Math.min(
    arcThreshold * error,
    (arcTolerance * circle.radius) / 100
  );

  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
    return (
      Math.abs(
        getDistance(getCubicBezierPoint(curve, point), circle.center) -
          circle.radius
      ) <= tolerance
    );
  });
}

/**
 * Checks if a previous curve fits the given circle.
 *
 * @param {Object} circle
 * @param {Array} curve
 * @return {Boolean}
 */

function isArcPrev(curve, circle) {
  return isArc(curve, {
    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
    radius: circle.radius,
  });
}

/**
 * Finds angle of a curve fitting the given arc.

 * @param {Array} curve
 * @param {Object} relCircle
 * @return {Number} angle
 */

function findArcAngle(curve, relCircle) {
  var x1 = -relCircle.center[0],
    y1 = -relCircle.center[1],
    x2 = curve[4] - relCircle.center[0],
    y2 = curve[5] - relCircle.center[1];

  return Math.acos(
    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
  );
}

/**
 * Converts given path data to string.
 *
 * @param {Object} params
 * @param {Array} pathData
 * @return {String}
 */

function data2Path(params, pathData) {
  return pathData.reduce(function (pathString, item) {
    var strData = '';
    if (item.data) {
      strData = cleanupOutData$1(roundData(item.data.slice()), params);
    }
    return pathString + item.instruction + strData;
  }, '');
}

var convertShapeToPath = {};

const { stringifyPathData } = path;

convertShapeToPath.type = 'perItem';

convertShapeToPath.active = true;

convertShapeToPath.description = 'converts basic shapes to more compact path form';

convertShapeToPath.params = {
  convertArcs: false,
  floatPrecision: null,
};

const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

/**
 * Converts basic shape to more compact path.
 * It also allows further optimizations like
 * combining paths with similar attributes.
 *
 * @see https://www.w3.org/TR/SVG11/shapes.html
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Lev Solntsev
 */
convertShapeToPath.fn = function (item, params) {
  const precision = params ? params.floatPrecision : null;
  const convertArcs = params && params.convertArcs;

  if (
    item.isElem('rect') &&
    item.attributes.width != null &&
    item.attributes.height != null &&
    item.attributes.rx == null &&
    item.attributes.ry == null
  ) {
    const x = Number(item.attributes.x || '0');
    const y = Number(item.attributes.y || '0');
    const width = Number(item.attributes.width);
    const height = Number(item.attributes.height);
    // Values like '100%' compute to NaN, thus running after
    // cleanupNumericValues when 'px' units has already been removed.
    // TODO: Calculate sizes from % and non-px units if possible.
    if (isNaN(x - y + width - height)) return;
    const pathData = [
      { command: 'M', args: [x, y] },
      { command: 'H', args: [x + width] },
      { command: 'V', args: [y + height] },
      { command: 'H', args: [x] },
      { command: 'z', args: [] },
    ];
    item.attributes.d = stringifyPathData({ pathData, precision });
    item.renameElem('path');
    delete item.attributes.x;
    delete item.attributes.y;
    delete item.attributes.width;
    delete item.attributes.height;
  }

  if (item.isElem('line')) {
    const x1 = Number(item.attributes.x1 || '0');
    const y1 = Number(item.attributes.y1 || '0');
    const x2 = Number(item.attributes.x2 || '0');
    const y2 = Number(item.attributes.y2 || '0');
    if (isNaN(x1 - y1 + x2 - y2)) return;
    const pathData = [
      { command: 'M', args: [x1, y1] },
      { command: 'L', args: [x2, y2] },
    ];
    item.attributes.d = stringifyPathData({ pathData, precision });
    item.renameElem('path');
    delete item.attributes.x1;
    delete item.attributes.y1;
    delete item.attributes.x2;
    delete item.attributes.y2;
  }

  if (
    (item.isElem('polyline') || item.isElem('polygon')) &&
    item.attributes.points != null
  ) {
    const coords = (item.attributes.points.match(regNumber) || []).map(Number);
    if (coords.length < 4) return false;
    const pathData = [];
    for (let i = 0; i < coords.length; i += 2) {
      pathData.push({
        command: i === 0 ? 'M' : 'L',
        args: coords.slice(i, i + 2),
      });
    }
    if (item.isElem('polygon')) {
      pathData.push({ command: 'z', args: [] });
    }
    item.attributes.d = stringifyPathData({ pathData, precision });
    item.renameElem('path');
    delete item.attributes.points;
  }

  if (item.isElem('circle') && convertArcs) {
    const cx = Number(item.attributes.cx || '0');
    const cy = Number(item.attributes.cy || '0');
    const r = Number(item.attributes.r || '0');
    if (isNaN(cx - cy + r)) {
      return;
    }
    const pathData = [
      { command: 'M', args: [cx, cy - r] },
      { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },
      { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },
      { command: 'z', args: [] },
    ];
    item.attributes.d = stringifyPathData({ pathData, precision });
    item.renameElem('path');
    delete item.attributes.cx;
    delete item.attributes.cy;
    delete item.attributes.r;
  }

  if (item.isElem('ellipse') && convertArcs) {
    const ecx = Number(item.attributes.cx || '0');
    const ecy = Number(item.attributes.cy || '0');
    const rx = Number(item.attributes.rx || '0');
    const ry = Number(item.attributes.ry || '0');
    if (isNaN(ecx - ecy + rx - ry)) {
      return;
    }
    const pathData = [
      { command: 'M', args: [ecx, ecy - ry] },
      { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
      { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
      { command: 'z', args: [] },
    ];
    item.attributes.d = stringifyPathData({ pathData, precision });
    item.renameElem('path');
    delete item.attributes.cx;
    delete item.attributes.cy;
    delete item.attributes.rx;
    delete item.attributes.ry;
  }
};

var convertStyleToAttrs = {};

convertStyleToAttrs.type = 'perItem';

convertStyleToAttrs.active = false;

convertStyleToAttrs.description = 'converts style to attributes';

convertStyleToAttrs.params = {
  keepImportant: false,
};

var stylingProps = _collections.attrsGroups.presentation,
  rEscape = '\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)', // Like \" or \2051. Code points consume one space.
  rAttr = '\\s*(' + g('[^:;\\\\]', rEscape) + '*?)\\s*', // attribute name like ‘fill’
  rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)", // string in single quotes: 'smth'
  rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)', // string in double quotes: "smth"
  rQuotedString = new RegExp('^' + g(rSingleQuotes, rQuotes) + '$'),
  // Parentheses, E.g.: url(data:image/png;base64,iVBO...).
  // ':' and ';' inside of it should be threated as is. (Just like in strings.)
  rParenthesis =
    '\\(' + g('[^\'"()\\\\]+', rEscape, rSingleQuotes, rQuotes) + '*?' + '\\)',
  // The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.
  rValue =
    '\\s*(' +
    g(
      '[^!\'"();\\\\]+?',
      rEscape,
      rSingleQuotes,
      rQuotes,
      rParenthesis,
      '[^;]*?'
    ) +
    '*?' +
    ')',
  // End of declaration. Spaces outside of capturing groups help to do natural trimming.
  rDeclEnd = '\\s*(?:;\\s*|$)',
  // Important rule
  rImportant = '(\\s*!important(?![-(\\w]))?',
  // Final RegExp to parse CSS declarations.
  regDeclarationBlock = new RegExp(
    rAttr + ':' + rValue + rImportant + rDeclEnd,
    'ig'
  ),
  // Comments expression. Honors escape sequences and strings.
  regStripComments = new RegExp(
    g(rEscape, rSingleQuotes, rQuotes, '/\\*[^]*?\\*/'),
    'ig'
  );

/**
 * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.
 *
 * @example
 * <g style="fill:#000; color: #fff;">
 *             ⬇
 * <g fill="#000" color="#fff">
 *
 * @example
 * <g style="fill:#000; color: #fff; -webkit-blah: blah">
 *             ⬇
 * <g fill="#000" color="#fff" style="-webkit-blah: blah">
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertStyleToAttrs.fn = function (item, params) {
  if (item.type === 'element' && item.attributes.style != null) {
    // ['opacity: 1', 'color: #000']
    let styles = [];
    const newAttributes = {};

    // Strip CSS comments preserving escape sequences and strings.
    const styleValue = item.attributes.style.replace(
      regStripComments,
      (match) => {
        return match[0] == '/'
          ? ''
          : match[0] == '\\' && /[-g-z]/i.test(match[1])
          ? match[1]
          : match;
      }
    );

    regDeclarationBlock.lastIndex = 0;
    // eslint-disable-next-line no-cond-assign
    for (var rule; (rule = regDeclarationBlock.exec(styleValue)); ) {
      if (!params.keepImportant || !rule[3]) {
        styles.push([rule[1], rule[2]]);
      }
    }

    if (styles.length) {
      styles = styles.filter(function (style) {
        if (style[0]) {
          var prop = style[0].toLowerCase(),
            val = style[1];

          if (rQuotedString.test(val)) {
            val = val.slice(1, -1);
          }

          if (stylingProps.includes(prop)) {
            newAttributes[prop] = val;

            return false;
          }
        }

        return true;
      });

      Object.assign(item.attributes, newAttributes);

      if (styles.length) {
        item.attributes.style = styles
          .map((declaration) => declaration.join(':'))
          .join(';');
      } else {
        delete item.attributes.style;
      }
    }
  }
};

function g() {
  return '(?:' + Array.prototype.join.call(arguments, '|') + ')';
}

var convertTransform$1 = {};

convertTransform$1.type = 'perItem';

convertTransform$1.active = true;

convertTransform$1.description = 'collapses multiple transformations and optimizes it';

convertTransform$1.params = {
  convertToShorts: true,
  // degPrecision: 3, // transformPrecision (or matrix precision) - 2 by default
  floatPrecision: 3,
  transformPrecision: 5,
  matrixToTransform: true,
  shortTranslate: true,
  shortScale: true,
  shortRotate: true,
  removeUseless: true,
  collapseIntoOne: true,
  leadingZero: true,
  negativeExtraSpace: false,
};

var cleanupOutData = tools.cleanupOutData,
  transform2js = _transforms.transform2js,
  transformsMultiply = _transforms.transformsMultiply,
  matrixToTransform = _transforms.matrixToTransform,
  degRound,
  floatRound,
  transformRound;

/**
 * Convert matrices to the short aliases,
 * convert long translate, scale or rotate transform notations to the shorts ones,
 * convert transforms to the matrices and multiply them all into one,
 * remove useless transforms.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
convertTransform$1.fn = function (item, params) {
  if (item.type === 'element') {
    // transform
    if (item.attributes.transform != null) {
      convertTransform(item, 'transform', params);
    }

    // gradientTransform
    if (item.attributes.gradientTransform != null) {
      convertTransform(item, 'gradientTransform', params);
    }

    // patternTransform
    if (item.attributes.patternTransform != null) {
      convertTransform(item, 'patternTransform', params);
    }
  }
};

/**
 * Main function.
 *
 * @param {Object} item input item
 * @param {String} attrName attribute name
 * @param {Object} params plugin params
 */
function convertTransform(item, attrName, params) {
  let data = transform2js(item.attributes[attrName]);
  params = definePrecision(data, params);

  if (params.collapseIntoOne && data.length > 1) {
    data = [transformsMultiply(data)];
  }

  if (params.convertToShorts) {
    data = convertToShorts(data, params);
  } else {
    data.forEach(roundTransform);
  }

  if (params.removeUseless) {
    data = removeUseless(data);
  }

  if (data.length) {
    item.attributes[attrName] = js2transform(data, params);
  } else {
    delete item.attributes[attrName];
  }
}

/**
 * Defines precision to work with certain parts.
 * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),
 * floatPrecision - for translate including two last matrix and rotate parameters,
 * degPrecision - for rotate and skew. By default it's equal to (rougly)
 * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.
 *
 * @param {Array} transforms input array
 * @param {Object} params plugin params
 * @return {Array} output array
 */
function definePrecision(data, params) {
  var matrixData = data.reduce(getMatrixData, []),
    significantDigits = params.transformPrecision;

  // Clone params so it don't affect other elements transformations.
  params = Object.assign({}, params);

  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
  if (matrixData.length) {
    params.transformPrecision = Math.min(
      params.transformPrecision,
      Math.max.apply(Math, matrixData.map(floatDigits)) ||
        params.transformPrecision
    );

    significantDigits = Math.max.apply(
      Math,
      matrixData.map(function (n) {
        return String(n).replace(/\D+/g, '').length; // Number of digits in a number. 123.45 → 5
      })
    );
  }
  // No sense in angle precision more then number of significant digits in matrix.
  if (!('degPrecision' in params)) {
    params.degPrecision = Math.max(
      0,
      Math.min(params.floatPrecision, significantDigits - 2)
    );
  }

  floatRound =
    params.floatPrecision >= 1 && params.floatPrecision < 20
      ? smartRound.bind(this, params.floatPrecision)
      : round;
  degRound =
    params.degPrecision >= 1 && params.floatPrecision < 20
      ? smartRound.bind(this, params.degPrecision)
      : round;
  transformRound =
    params.transformPrecision >= 1 && params.floatPrecision < 20
      ? smartRound.bind(this, params.transformPrecision)
      : round;

  return params;
}

/**
 * Gathers four first matrix parameters.
 *
 * @param {Array} a array of data
 * @param {Object} transform
 * @return {Array} output array
 */
function getMatrixData(a, b) {
  return b.name == 'matrix' ? a.concat(b.data.slice(0, 4)) : a;
}

/**
 * Returns number of digits after the point. 0.125 → 3
 */
function floatDigits(n) {
  return (n = String(n)).slice(n.indexOf('.')).length - 1;
}

/**
 * Convert transforms to the shorthand alternatives.
 *
 * @param {Array} transforms input array
 * @param {Object} params plugin params
 * @return {Array} output array
 */
function convertToShorts(transforms, params) {
  for (var i = 0; i < transforms.length; i++) {
    var transform = transforms[i];

    // convert matrix to the short aliases
    if (params.matrixToTransform && transform.name === 'matrix') {
      var decomposed = matrixToTransform(transform, params);
      if (
        decomposed != transform &&
        js2transform(decomposed, params).length <=
          js2transform([transform], params).length
      ) {
        transforms.splice.apply(transforms, [i, 1].concat(decomposed));
      }
      transform = transforms[i];
    }

    // fixed-point numbers
    // 12.754997 → 12.755
    roundTransform(transform);

    // convert long translate transform notation to the shorts one
    // translate(10 0) → translate(10)
    if (
      params.shortTranslate &&
      transform.name === 'translate' &&
      transform.data.length === 2 &&
      !transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long scale transform notation to the shorts one
    // scale(2 2) → scale(2)
    if (
      params.shortScale &&
      transform.name === 'scale' &&
      transform.data.length === 2 &&
      transform.data[0] === transform.data[1]
    ) {
      transform.data.pop();
    }

    // convert long rotate transform notation to the short one
    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)
    if (
      params.shortRotate &&
      transforms[i - 2] &&
      transforms[i - 2].name === 'translate' &&
      transforms[i - 1].name === 'rotate' &&
      transforms[i].name === 'translate' &&
      transforms[i - 2].data[0] === -transforms[i].data[0] &&
      transforms[i - 2].data[1] === -transforms[i].data[1]
    ) {
      transforms.splice(i - 2, 3, {
        name: 'rotate',
        data: [
          transforms[i - 1].data[0],
          transforms[i - 2].data[0],
          transforms[i - 2].data[1],
        ],
      });

      // splice compensation
      i -= 2;
    }
  }

  return transforms;
}

/**
 * Remove useless transforms.
 *
 * @param {Array} transforms input array
 * @return {Array} output array
 */
function removeUseless(transforms) {
  return transforms.filter(function (transform) {
    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)
    if (
      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&
        (transform.data.length == 1 || transform.name == 'rotate') &&
        !transform.data[0]) ||
      // translate(0, 0)
      (transform.name == 'translate' &&
        !transform.data[0] &&
        !transform.data[1]) ||
      // scale(1)
      (transform.name == 'scale' &&
        transform.data[0] == 1 &&
        (transform.data.length < 2 || transform.data[1] == 1)) ||
      // matrix(1 0 0 1 0 0)
      (transform.name == 'matrix' &&
        transform.data[0] == 1 &&
        transform.data[3] == 1 &&
        !(
          transform.data[1] ||
          transform.data[2] ||
          transform.data[4] ||
          transform.data[5]
        ))
    ) {
      return false;
    }

    return true;
  });
}

/**
 * Convert transforms JS representation to string.
 *
 * @param {Array} transformJS JS representation array
 * @param {Object} params plugin params
 * @return {String} output string
 */
function js2transform(transformJS, params) {
  var transformString = '';

  // collect output value string
  transformJS.forEach(function (transform) {
    roundTransform(transform);
    transformString +=
      (transformString && ' ') +
      transform.name +
      '(' +
      cleanupOutData(transform.data, params) +
      ')';
  });

  return transformString;
}

function roundTransform(transform) {
  switch (transform.name) {
    case 'translate':
      transform.data = floatRound(transform.data);
      break;
    case 'rotate':
      transform.data = degRound(transform.data.slice(0, 1)).concat(
        floatRound(transform.data.slice(1))
      );
      break;
    case 'skewX':
    case 'skewY':
      transform.data = degRound(transform.data);
      break;
    case 'scale':
      transform.data = transformRound(transform.data);
      break;
    case 'matrix':
      transform.data = transformRound(transform.data.slice(0, 4)).concat(
        floatRound(transform.data.slice(4))
      );
      break;
  }
  return transform;
}

/**
 * Rounds numbers in array.
 *
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function round(data) {
  return data.map(Math.round);
}

/**
 * Decrease accuracy of floating-point numbers
 * in transforms keeping a specified number of decimals.
 * Smart rounds values like 2.349 to 2.35.
 *
 * @param {Number} fixed number of decimals
 * @param {Array} data input data array
 * @return {Array} output data array
 */
function smartRound(precision, data) {
  for (
    var i = data.length,
      tolerance = +Math.pow(0.1, precision).toFixed(precision);
    i--;

  ) {
    if (data[i].toFixed(precision) != data[i]) {
      var rounded = +data[i].toFixed(precision - 1);
      data[i] =
        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
          ? +data[i].toFixed(precision)
          : rounded;
    }
  }
  return data;
}

var mergeStyles = {};

var CSSClassList$1 = function (node) {
  this.parentNode = node;
  this.classNames = new Set();
  const value = node.attributes.class;
  if (value != null) {
    this.addClassValueHandler();
    this.setClassValue(value);
  }
};

// attr.class.value

CSSClassList$1.prototype.addClassValueHandler = function () {
  Object.defineProperty(this.parentNode.attributes, 'class', {
    get: this.getClassValue.bind(this),
    set: this.setClassValue.bind(this),
    enumerable: true,
    configurable: true,
  });
};

CSSClassList$1.prototype.getClassValue = function () {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames.join(' ');
};

CSSClassList$1.prototype.setClassValue = function (newValue) {
  if (typeof newValue === 'undefined') {
    this.classNames.clear();
    return;
  }
  var arrClassNames = newValue.split(' ');
  this.classNames = new Set(arrClassNames);
};

CSSClassList$1.prototype.add = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._addSingle.bind(this));
};

CSSClassList$1.prototype._addSingle = function (className) {
  this.classNames.add(className);
};

CSSClassList$1.prototype.remove = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._removeSingle.bind(this));
};

CSSClassList$1.prototype._removeSingle = function (className) {
  this.classNames.delete(className);
};

CSSClassList$1.prototype.item = function (index) {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames[index];
};

CSSClassList$1.prototype.toggle = function (className, force) {
  if (this.contains(className) || force === false) {
    this.classNames.delete(className);
  }
  this.classNames.add(className);
};

CSSClassList$1.prototype.contains = function (className) {
  return this.classNames.has(className);
};

var cssClassList = CSSClassList$1;

var csstree$3 = lib$1,
  csstools = cssTools$1;

var CSSStyleDeclaration$1 = function (node) {
  this.parentNode = node;

  this.properties = new Map();
  this.hasSynced = false;

  this.styleValue = null;

  this.parseError = false;
  const value = node.attributes.style;
  if (value != null) {
    this.addStyleValueHandler();
    this.setStyleValue(value);
  }
};

// attr.style.value

CSSStyleDeclaration$1.prototype.addStyleValueHandler = function () {
  Object.defineProperty(this.parentNode.attributes, 'style', {
    get: this.getStyleValue.bind(this),
    set: this.setStyleValue.bind(this),
    enumerable: true,
    configurable: true,
  });
};

CSSStyleDeclaration$1.prototype.getStyleValue = function () {
  return this.getCssText();
};

CSSStyleDeclaration$1.prototype.setStyleValue = function (newValue) {
  this.properties.clear(); // reset all existing properties
  this.styleValue = newValue;
  this.hasSynced = false; // raw css changed
};

CSSStyleDeclaration$1.prototype._loadCssText = function () {
  if (this.hasSynced) {
    return;
  }
  this.hasSynced = true; // must be set here to prevent loop in setProperty(...)

  if (!this.styleValue || this.styleValue.length === 0) {
    return;
  }
  var inlineCssStr = this.styleValue;

  var declarations = {};
  try {
    declarations = csstree$3.parse(inlineCssStr, {
      context: 'declarationList',
      parseValue: false,
    });
  } catch (parseError) {
    this.parseError = parseError;
    return;
  }
  this.parseError = false;

  var self = this;
  declarations.children.each(function (declaration) {
    try {
      var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
      self.setProperty(
        styleDeclaration.name,
        styleDeclaration.value,
        styleDeclaration.priority
      );
    } catch (styleError) {
      if (styleError.message !== 'Unknown node type: undefined') {
        self.parseError = styleError;
      }
    }
  });
};

// only reads from properties

/**
 * Get the textual representation of the declaration block (equivalent to .cssText attribute).
 *
 * @return {string} Textual representation of the declaration block (empty string for no properties)
 */
CSSStyleDeclaration$1.prototype.getCssText = function () {
  var properties = this.getProperties();

  if (this.parseError) {
    // in case of a parse error, pass through original styles
    return this.styleValue;
  }

  var cssText = [];
  properties.forEach(function (property, propertyName) {
    var strImportant = property.priority === 'important' ? '!important' : '';
    cssText.push(
      propertyName.trim() + ':' + property.value.trim() + strImportant
    );
  });
  return cssText.join(';');
};

CSSStyleDeclaration$1.prototype._handleParseError = function () {
  if (this.parseError) {
    console.warn(
      "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " +
        this.parseError
    );
  }
};

CSSStyleDeclaration$1.prototype._getProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();
  this._handleParseError();

  var property = properties.get(propertyName.trim());
  return property;
};

/**
 * Return the optional priority, "important".
 *
 * @param {string} propertyName representing the property name to be checked.
 * @return {string} priority that represents the priority (e.g. "important") if one exists. If none exists, returns the empty string.
 */
CSSStyleDeclaration$1.prototype.getPropertyPriority = function (propertyName) {
  var property = this._getProperty(propertyName);
  return property ? property.priority : '';
};

/**
 * Return the property value given a property name.
 *
 * @param {string} propertyName representing the property name to be checked.
 * @return {string} value containing the value of the property. If not set, returns the empty string.
 */
CSSStyleDeclaration$1.prototype.getPropertyValue = function (propertyName) {
  var property = this._getProperty(propertyName);
  return property ? property.value : null;
};

/**
 * Return a property name.
 *
 * @param {number} index of the node to be fetched. The index is zero-based.
 * @return {string} propertyName that is the name of the CSS property at the specified index.
 */
CSSStyleDeclaration$1.prototype.item = function (index) {
  if (typeof index === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();
  this._handleParseError();

  return Array.from(properties.keys())[index];
};

/**
 * Return all properties of the node.
 *
 * @return {Map} properties that is a Map with propertyName as key and property (propertyValue + propertyPriority) as value.
 */
CSSStyleDeclaration$1.prototype.getProperties = function () {
  this._loadCssText();
  return this.properties;
};

// writes to properties

/**
 * Remove a property from the CSS declaration block.
 *
 * @param {string} propertyName representing the property name to be removed.
 * @return {string} oldValue equal to the value of the CSS property before it was removed.
 */
CSSStyleDeclaration$1.prototype.removeProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  this.addStyleValueHandler();

  var properties = this.getProperties();
  this._handleParseError();

  var oldValue = this.getPropertyValue(propertyName);
  properties.delete(propertyName.trim());
  return oldValue;
};

/**
 * Modify an existing CSS property or creates a new CSS property in the declaration block.
 *
 * @param {string} propertyName representing the CSS property name to be modified.
 * @param {string} value containing the new property value. If not specified, treated as the empty string. value must not contain "!important" -- that should be set using the priority parameter.
 * @param {string} priority allowing the "important" CSS priority to be set. If not specified, treated as the empty string.
 * @return {{value: string, priority: string}}
 */
CSSStyleDeclaration$1.prototype.setProperty = function (
  propertyName,
  value,
  priority
) {
  if (typeof propertyName === 'undefined') {
    throw Error('propertyName argument required, but only not present.');
  }

  this.addStyleValueHandler();

  var properties = this.getProperties();
  this._handleParseError();

  var property = {
    value: value.trim(),
    priority: priority.trim(),
  };
  properties.set(propertyName.trim(), property);

  return property;
};

var cssStyleDeclaration = CSSStyleDeclaration$1;

const { selectAll, selectOne, is } = lib$9;
const { parseName: parseName$4 } = tools;
const svgoCssSelectAdapter = cssSelectAdapter;
const CSSClassList = cssClassList;
const CSSStyleDeclaration = cssStyleDeclaration;

var cssSelectOpts = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter,
};

const attrsHandler = {
  get: (attributes, name) => {
    // eslint-disable-next-line no-prototype-builtins
    if (attributes.hasOwnProperty(name)) {
      return {
        name,
        get value() {
          return attributes[name];
        },
        set value(value) {
          attributes[name] = value;
        },
      };
    }
  },
  set: (attributes, name, attr) => {
    attributes[name] = attr.value;
    return true;
  },
};

var JSAPI$5 = function (data, parentNode) {
  Object.assign(this, data);
  if (this.type === 'element') {
    if (this.attributes == null) {
      this.attributes = {};
    }
    if (this.children == null) {
      this.children = [];
    }
    Object.defineProperty(this, 'class', {
      writable: true,
      configurable: true,
      value: new CSSClassList(this),
    });
    Object.defineProperty(this, 'style', {
      writable: true,
      configurable: true,
      value: new CSSStyleDeclaration(this),
    });
    Object.defineProperty(this, 'parentNode', {
      writable: true,
      value: parentNode,
    });

    // temporary attrs polyfill
    // TODO remove after migration
    const element = this;
    Object.defineProperty(this, 'attrs', {
      configurable: true,
      get() {
        return new Proxy(element.attributes, attrsHandler);
      },
      set(value) {
        const newAttributes = {};
        for (const attr of Object.values(value)) {
          newAttributes[attr.name] = attr.value;
        }
        element.attributes = newAttributes;
      },
    });
  }
};
var jsAPI = JSAPI$5;

/**
 * Perform a deep clone of this node.
 *
 * @return {Object} element
 */
JSAPI$5.prototype.clone = function () {
  const { children, ...nodeData } = this;
  // Deep-clone node data.
  const clonedNode = new JSAPI$5(JSON.parse(JSON.stringify(nodeData)), null);
  if (children) {
    clonedNode.children = children.map((child) => {
      const clonedChild = child.clone();
      clonedChild.parentNode = clonedNode;
      return clonedChild;
    });
  }
  return clonedNode;
};

/**
 * Determine if item is an element
 * (any, with a specific name or in a names array).
 *
 * @param {String|Array} [param] element name or names arrays
 * @return {Boolean}
 */
JSAPI$5.prototype.isElem = function (param) {
  if (this.type !== 'element') {
    return false;
  }
  if (param == null) {
    return true;
  }
  if (Array.isArray(param)) {
    return param.includes(this.name);
  }
  return this.name === param;
};

/**
 * Renames an element
 *
 * @param {String} name new element name
 * @return {Object} element
 */
JSAPI$5.prototype.renameElem = function (name) {
  if (name && typeof name === 'string') this.name = name;

  return this;
};

/**
 * Determine if element is empty.
 *
 * @return {Boolean}
 */
JSAPI$5.prototype.isEmpty = function () {
  return !this.children || !this.children.length;
};

/**
 * Find the closest ancestor of the current element.
 * @param elemName
 *
 * @return {?Object}
 */
JSAPI$5.prototype.closestElem = function (elemName) {
  var elem = this;

  while ((elem = elem.parentNode) && !elem.isElem(elemName));

  return elem;
};

/**
 * Changes children by removing elements and/or adding new elements.
 *
 * @param {Number} start Index at which to start changing the children.
 * @param {Number} n Number of elements to remove.
 * @param {Array|Object} [insertion] Elements to add to the children.
 * @return {Array} Removed elements.
 */
JSAPI$5.prototype.spliceContent = function (start, n, insertion) {
  if (arguments.length < 2) return [];

  if (!Array.isArray(insertion))
    insertion = Array.apply(null, arguments).slice(2);

  insertion.forEach(function (inner) {
    inner.parentNode = this;
  }, this);

  return this.children.splice.apply(
    this.children,
    [start, n].concat(insertion)
  );
};

/**
 * Determine if element has an attribute
 * (any, or by name or by name + value).
 *
 * @param {String} [name] attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Boolean}
 */
JSAPI$5.prototype.hasAttr = function (name, val) {
  if (this.type !== 'element') {
    return false;
  }
  if (Object.keys(this.attributes).length === 0) {
    return false;
  }
  if (name == null) {
    return true;
  }
  // eslint-disable-next-line no-prototype-builtins
  if (this.attributes.hasOwnProperty(name) === false) {
    return false;
  }
  if (val !== undefined) {
    return this.attributes[name] === val.toString();
  }
  return true;
};

/**
 * Determine if element has an attribute by local name
 * (any, or by name or by name + value).
 *
 * @param {String} [localName] local attribute name
 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
 * @return {Boolean}
 */
JSAPI$5.prototype.hasAttrLocal = function (localName, val) {
  if (!this.attrs || !Object.keys(this.attrs).length) return false;

  if (!arguments.length) return !!this.attrs;

  var callback;

  switch (val != null && val.constructor && val.constructor.name) {
    case 'Number': // same as String
    case 'String':
      callback = stringValueTest;
      break;
    case 'RegExp':
      callback = regexpValueTest;
      break;
    case 'Function':
      callback = funcValueTest;
      break;
    default:
      callback = nameTest;
  }
  return this.someAttr(callback);

  function nameTest(attr) {
    const { local } = parseName$4(attr.name);
    return local === localName;
  }

  function stringValueTest(attr) {
    const { local } = parseName$4(attr.name);
    return local === localName && val == attr.value;
  }

  function regexpValueTest(attr) {
    const { local } = parseName$4(attr.name);
    return local === localName && val.test(attr.value);
  }

  function funcValueTest(attr) {
    const { local } = parseName$4(attr.name);
    return local === localName && val(attr.value);
  }
};

/**
 * Get a specific attribute from an element
 * (by name or name + value).
 *
 * @param {String} name attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Object|Undefined}
 */
JSAPI$5.prototype.attr = function (name, val) {
  if (this.hasAttr(name, val)) {
    return this.attrs[name];
  }
};

/**
 * Get computed attribute value from an element
 *
 * @param {String} name attribute name
 * @return {Object|Undefined}
 */
JSAPI$5.prototype.computedAttr = function (name, val) {
  if (!arguments.length) return;

  for (
    var elem = this;
    elem && (!elem.hasAttr(name) || !elem.attributes[name]);
    elem = elem.parentNode
  );

  if (val != null) {
    return elem ? elem.hasAttr(name, val) : false;
  } else if (elem && elem.hasAttr(name)) {
    return elem.attributes[name];
  }
};

/**
 * Remove a specific attribute.
 *
 * @param {String|Array} name attribute name
 * @param {String} [val] attribute value
 * @return {Boolean}
 */
JSAPI$5.prototype.removeAttr = function (name, val) {
  if (this.type !== 'element') {
    return false;
  }
  if (arguments.length === 0) {
    return false;
  }
  if (Array.isArray(name)) {
    for (const nameItem of name) {
      this.removeAttr(nameItem, val);
    }
    return false;
  }
  if (this.hasAttr(name, val) === false) {
    return false;
  }
  delete this.attributes[name];
  return true;
};

/**
 * Add attribute.
 *
 * @param {Object} [attr={}] attribute object
 * @return {Object|Boolean} created attribute or false if no attr was passed in
 */
JSAPI$5.prototype.addAttr = function (attr) {
  attr = attr || {};

  if (attr.name === undefined) return false;

  this.attributes[attr.name] = attr.value;

  if (attr.name === 'class') {
    // newly added class attribute
    this.class.hasClass();
  }

  if (attr.name === 'style') {
    // newly added style attribute
    this.style.hasStyle();
  }

  return this.attrs[attr.name];
};

/**
 * Iterates over all attributes.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
JSAPI$5.prototype.eachAttr = function (callback, context) {
  if (this.type !== 'element') {
    return false;
  }
  if (callback == null) {
    return false;
  }
  for (const attr of Object.values(this.attrs)) {
    callback.call(context, attr);
  }
  return true;
};

/**
 * Tests whether some attribute passes the test.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
JSAPI$5.prototype.someAttr = function (callback, context) {
  if (this.type !== 'element') {
    return false;
  }

  for (const attr of Object.values(this.attrs)) {
    if (callback.call(context, attr)) return true;
  }

  return false;
};

/**
 * Evaluate a string of CSS selectors against the element and returns matched elements.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no elements matched
 */
JSAPI$5.prototype.querySelectorAll = function (selectors) {
  var matchedEls = selectAll(selectors, this, cssSelectOpts);

  return matchedEls.length > 0 ? matchedEls : null;
};

/**
 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no element matched
 */
JSAPI$5.prototype.querySelector = function (selectors) {
  return selectOne(selectors, this, cssSelectOpts);
};

/**
 * Test if a selector matches a given element.
 *
 * @param {String} selector CSS selector string
 * @return {Boolean} true if element would be selected by selector string, false if it does not
 */
JSAPI$5.prototype.matches = function (selector) {
  return is(this, selector, cssSelectOpts);
};

const { closestByName: closestByName$3, detachNodeFromParent: detachNodeFromParent$2 } = xast;
const JSAPI$4 = jsAPI;

mergeStyles.type = 'visitor';
mergeStyles.active = true;
mergeStyles.description = 'merge multiple style elements into one';

/**
 * Merge multiple style elements into one.
 *
 * @author strarsis <strarsis@gmail.com>
 */
mergeStyles.fn = () => {
  let firstStyleElement = null;
  let collectedStyles = '';
  let styleContentType = 'text';

  const enterElement = (node) => {
    // collect style elements
    if (node.name !== 'style') {
      return;
    }

    // skip <style> with invalid type attribute
    if (
      node.attributes.type != null &&
      node.attributes.type !== '' &&
      node.attributes.type !== 'text/css'
    ) {
      return;
    }

    // skip <foreignObject> content
    if (closestByName$3(node, 'foreignObject')) {
      return;
    }

    // extract style element content
    let css = '';
    for (const child of node.children) {
      if (child.type === 'text') {
        css += child.value;
      }
      if (child.type === 'cdata') {
        styleContentType = 'cdata';
        css += child.value;
      }
    }

    // remove empty style elements
    if (css.trim().length === 0) {
      detachNodeFromParent$2(node);
      return;
    }

    // collect css and wrap with media query if present in attribute
    if (node.attributes.media == null) {
      collectedStyles += css;
    } else {
      collectedStyles += `@media ${node.attributes.media}{${css}}`;
      delete node.attributes.media;
    }

    // combine collected styles in the first style element
    if (firstStyleElement == null) {
      firstStyleElement = node;
    } else {
      detachNodeFromParent$2(node);
      firstStyleElement.children = [
        new JSAPI$4(
          { type: styleContentType, value: collectedStyles },
          firstStyleElement
        ),
      ];
    }
  };

  return {
    element: {
      enter: enterElement,
    },
  };
};

var inlineStyles = {};

const csstree$2 = lib$1;
const { querySelectorAll, closestByName: closestByName$2 } = xast;
const cssTools = cssTools$1;

inlineStyles.type = 'full';

inlineStyles.active = true;

inlineStyles.params = {
  onlyMatchedOnce: true,
  removeMatchedSelectors: true,
  useMqs: ['', 'screen'],
  usePseudos: [''],
};

inlineStyles.description = 'inline styles (additional options)';

/**
 * Moves + merges styles from style elements to element styles
 *
 * Options
 *   onlyMatchedOnce (default: true)
 *     inline only selectors that match once
 *
 *   removeMatchedSelectors (default: true)
 *     clean up matched selectors,
 *     leave selectors that hadn't matched
 *
 *   useMqs (default: ['', 'screen'])
 *     what media queries to be used
 *     empty string element for styles outside media queries
 *
 *   usePseudos (default: [''])
 *     what pseudo-classes/-elements to be used
 *     empty string element for all non-pseudo-classes and/or -elements
 *
 * @param {Object} root document element
 * @param {Object} opts plugin params
 *
 * @author strarsis <strarsis@gmail.com>
 */
inlineStyles.fn = function (root, opts) {
  // collect <style/>s
  var styleEls = querySelectorAll(root, 'style');

  //no <styles/>s, nothing to do
  if (styleEls.length === 0) {
    return root;
  }

  var styles = [],
    selectors = [];

  for (var styleEl of styleEls) {
    // values other than the empty string or text/css are not used
    if (
      styleEl.attributes.type != null &&
      styleEl.attributes.type !== '' &&
      styleEl.attributes.type !== 'text/css'
    ) {
      continue;
    }
    // skip empty <style/>s or <foreignObject> content.
    if (
      styleEl.children.length === 0 ||
      closestByName$2(styleEl, 'foreignObject')
    ) {
      continue;
    }

    var cssStr = cssTools.getCssStr(styleEl);

    // collect <style/>s and their css ast
    var cssAst = {};
    try {
      cssAst = csstree$2.parse(cssStr, {
        parseValue: false,
        parseCustomProperty: false,
      });
    } catch (parseError) {
      // console.warn('Warning: Parse error of styles of <style/> element, skipped. Error details: ' + parseError);
      continue;
    }

    styles.push({
      styleEl: styleEl,
      cssAst: cssAst,
    });

    selectors = selectors.concat(cssTools.flattenToSelectors(cssAst));
  }

  // filter for mediaqueries to be used or without any mediaquery
  var selectorsMq = cssTools.filterByMqs(selectors, opts.useMqs);

  // filter for pseudo elements to be used
  var selectorsPseudo = cssTools.filterByPseudos(selectorsMq, opts.usePseudos);

  // remove PseudoClass from its SimpleSelector for proper matching
  cssTools.cleanPseudos(selectorsPseudo);

  // stable sort selectors
  var sortedSelectors = cssTools.sortSelectors(selectorsPseudo).reverse();

  var selector, selectedEl;

  // match selectors
  for (selector of sortedSelectors) {
    var selectorStr = csstree$2.generate(selector.item.data),
      selectedEls = null;

    try {
      selectedEls = querySelectorAll(root, selectorStr);
    } catch (selectError) {
      // console.warn('Warning: Syntax error when trying to select \n\n' + selectorStr + '\n\n, skipped. Error details: ' + selectError);
      continue;
    }

    if (selectedEls.length === 0) {
      // nothing selected
      continue;
    }

    selector.selectedEls = selectedEls;
  }

  // apply <style/> styles to matched elements
  for (selector of sortedSelectors) {
    if (!selector.selectedEls) {
      continue;
    }

    if (
      opts.onlyMatchedOnce &&
      selector.selectedEls !== null &&
      selector.selectedEls.length > 1
    ) {
      // skip selectors that match more than once if option onlyMatchedOnce is enabled
      continue;
    }

    // apply <style/> to matched elements
    for (selectedEl of selector.selectedEls) {
      if (selector.rule === null) {
        continue;
      }

      // merge declarations
      csstree$2.walk(selector.rule, {
        visit: 'Declaration',
        enter: function (styleCsstreeDeclaration) {
          // existing inline styles have higher priority
          // no inline styles, external styles,                                    external styles used
          // inline styles,    external styles same   priority as inline styles,   inline   styles used
          // inline styles,    external styles higher priority than inline styles, external styles used
          var styleDeclaration = cssTools.csstreeToStyleDeclaration(
            styleCsstreeDeclaration
          );
          if (
            selectedEl.style.getPropertyValue(styleDeclaration.name) !== null &&
            selectedEl.style.getPropertyPriority(styleDeclaration.name) >=
              styleDeclaration.priority
          ) {
            return;
          }
          selectedEl.style.setProperty(
            styleDeclaration.name,
            styleDeclaration.value,
            styleDeclaration.priority
          );
        },
      });
    }

    if (
      opts.removeMatchedSelectors &&
      selector.selectedEls !== null &&
      selector.selectedEls.length > 0
    ) {
      // clean up matching simple selectors if option removeMatchedSelectors is enabled
      selector.rule.prelude.children.remove(selector.item);
    }
  }

  if (!opts.removeMatchedSelectors) {
    return root; // no further processing required
  }

  // clean up matched class + ID attribute values
  for (selector of sortedSelectors) {
    if (!selector.selectedEls) {
      continue;
    }

    if (
      opts.onlyMatchedOnce &&
      selector.selectedEls !== null &&
      selector.selectedEls.length > 1
    ) {
      // skip selectors that match more than once if option onlyMatchedOnce is enabled
      continue;
    }

    for (selectedEl of selector.selectedEls) {
      // class
      var firstSubSelector = selector.item.data.children.first();
      if (firstSubSelector.type === 'ClassSelector') {
        selectedEl.class.remove(firstSubSelector.name);
      }
      // clean up now empty class attributes
      if (typeof selectedEl.class.item(0) === 'undefined') {
        delete selectedEl.attributes.class;
      }

      // ID
      if (firstSubSelector.type === 'IdSelector') {
        if (selectedEl.attributes.id === firstSubSelector.name) {
          delete selectedEl.attributes.id;
        }
      }
    }
  }

  // clean up now empty elements
  for (var style of styles) {
    csstree$2.walk(style.cssAst, {
      visit: 'Rule',
      enter: function (node, item, list) {
        // clean up <style/> atrules without any rulesets left
        if (
          node.type === 'Atrule' &&
          // only Atrules containing rulesets
          node.block !== null &&
          node.block.children.isEmpty()
        ) {
          list.remove(item);
          return;
        }

        // clean up <style/> rulesets without any css selectors left
        if (node.type === 'Rule' && node.prelude.children.isEmpty()) {
          list.remove(item);
        }
      },
    });

    if (style.cssAst.children.isEmpty()) {
      // clean up now emtpy <style/>s
      var styleParentEl = style.styleEl.parentNode;
      styleParentEl.spliceContent(
        styleParentEl.children.indexOf(style.styleEl),
        1
      );

      if (
        styleParentEl.name === 'defs' &&
        styleParentEl.children.length === 0
      ) {
        // also clean up now empty <def/>s
        var defsParentEl = styleParentEl.parentNode;
        defsParentEl.spliceContent(
          defsParentEl.children.indexOf(styleParentEl),
          1
        );
      }

      continue;
    }

    // update existing, left over <style>s
    cssTools.setCssStr(style.styleEl, csstree$2.generate(style.cssAst));
  }

  return root;
};

var mergePaths = {};

const { detachNodeFromParent: detachNodeFromParent$1 } = xast;
const { computeStyle: computeStyle$1 } = style;
const { path2js: path2js$1, js2path, intersects: intersects$1 } = _path$1;

mergePaths.type = 'visitor';
mergePaths.active = true;
mergePaths.description = 'merges multiple paths in one if possible';

/**
 * Merge multiple Paths into one.
 *
 * @param {Object} root
 * @param {Object} params
 *
 * @author Kir Belevich, Lev Solntsev
 */
mergePaths.fn = (root, params) => {
  const {
    force = false,
    floatPrecision,
    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20
  } = params;

  return {
    element: {
      enter: (node) => {
        let prevChild = null;

        for (const child of node.children) {
          // skip if previous element is not path or contains animation elements
          if (
            prevChild == null ||
            prevChild.type !== 'element' ||
            prevChild.name !== 'path' ||
            prevChild.children.length !== 0 ||
            prevChild.attributes.d == null
          ) {
            prevChild = child;
            continue;
          }

          // skip if element is not path or contains animation elements
          if (
            child.type !== 'element' ||
            child.name !== 'path' ||
            child.children.length !== 0 ||
            child.attributes.d == null
          ) {
            prevChild = child;
            continue;
          }

          // preserve paths with markers
          const computedStyle = computeStyle$1(child);
          if (
            computedStyle['marker-start'] ||
            computedStyle['marker-mid'] ||
            computedStyle['marker-end']
          ) {
            prevChild = child;
            continue;
          }

          const prevChildAttrs = Object.keys(prevChild.attributes);
          const childAttrs = Object.keys(child.attributes);
          let attributesAreEqual = prevChildAttrs.length === childAttrs.length;
          for (const name of childAttrs) {
            if (name !== 'd') {
              if (
                prevChild.attributes[name] == null ||
                prevChild.attributes[name] !== child.attributes[name]
              ) {
                attributesAreEqual = false;
              }
            }
          }
          const prevPathJS = path2js$1(prevChild);
          const curPathJS = path2js$1(child);

          if (
            attributesAreEqual &&
            (force || !intersects$1(prevPathJS, curPathJS))
          ) {
            js2path(prevChild, prevPathJS.concat(curPathJS), {
              floatPrecision,
              noSpaceAfterFlags,
            });
            detachNodeFromParent$1(child);
            continue;
          }

          prevChild = child;
        }
      },
    },
  };
};

var minifyStyles = {};

var hasOwnProperty$4 = Object.prototype.hasOwnProperty;

function buildMap(list, caseInsensitive) {
    var map = Object.create(null);

    if (!Array.isArray(list)) {
        return null;
    }

    for (var i = 0; i < list.length; i++) {
        var name = list[i];

        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function buildList(data) {
    if (!data) {
        return null;
    }

    var tags = buildMap(data.tags, true);
    var ids = buildMap(data.ids);
    var classes = buildMap(data.classes);

    if (tags === null &&
        ids === null &&
        classes === null) {
        return null;
    }

    return {
        tags: tags,
        ids: ids,
        classes: classes
    };
}

function buildIndex(data) {
    var scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (var j = 0; j < list.length; j++) {
                var name = list[j];

                if (hasOwnProperty$4.call(scopes, name)) {
                    throw new Error('Class can\'t be used for several scopes: ' + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes: scopes
    };
}

var usage = {
    buildIndex: buildIndex
};

var utils$4 = {
    hasNoChildren: function(node) {
        return !node || !node.children || node.children.isEmpty();
    },
    isNodeChildrenList: function(node, list) {
        return node !== null && node.children === list;
    }
};

var resolveKeyword$4 = lib$1.keyword;
var { hasNoChildren: hasNoChildren$1 } = utils$4;

var Atrule$1 = function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
        }

        if (hasNoChildren$1(node.block)) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (hasNoChildren$1(node.prelude)) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function(rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
            }, this);

            break;

        default:
            var name = resolveKeyword$4(node.name).basename;
            if (name === 'keyframes' ||
                name === 'media' ||
                name === 'supports') {

                // drop at-rule with no prelude
                if (hasNoChildren$1(node.prelude) || hasNoChildren$1(node.block)) {
                    list.remove(item);
                }
            }
    }
};

var Comment = function cleanComment(data, item, list) {
    list.remove(item);
};

var property = lib$1.property;

var Declaration = function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
        return;
    }

    if (property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
        }
    }
};

var { isNodeChildrenList: isNodeChildrenList$1 } = utils$4;

var Raw = function cleanRaw(node, item, list) {
    // raw in stylesheet or block children
    if (isNodeChildrenList$1(this.stylesheet, list) ||
        isNodeChildrenList$1(this.block, list)) {
        list.remove(item);
    }
};

var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var walk$b = lib$1.walk;
var { hasNoChildren } = utils$4;

function cleanUnused(selectorList, usageData) {
    selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;

        walk$b(selector, function(node) {
            // ignore nodes in nested selectors
            if (this.selector === null || this.selector === selectorList) {
                switch (node.type) {
                    case 'SelectorList':
                        // TODO: remove toLowerCase when pseudo selectors will be normalized
                        // ignore selectors inside :not()
                        if (this.function === null || this.function.name.toLowerCase() !== 'not') {
                            if (cleanUnused(node, usageData)) {
                                shouldRemove = true;
                            }
                        }
                        break;

                    case 'ClassSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.classes !== null &&
                            !hasOwnProperty$3.call(usageData.whitelist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.classes !== null &&
                            hasOwnProperty$3.call(usageData.blacklist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'IdSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.ids !== null &&
                            !hasOwnProperty$3.call(usageData.whitelist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.ids !== null &&
                            hasOwnProperty$3.call(usageData.blacklist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'TypeSelector':
                        // TODO: remove toLowerCase when type selectors will be normalized
                        // ignore universal selectors
                        if (node.name.charAt(node.name.length - 1) !== '*') {
                            if (usageData.whitelist !== null &&
                                usageData.whitelist.tags !== null &&
                                !hasOwnProperty$3.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                            if (usageData.blacklist !== null &&
                                usageData.blacklist.tags !== null &&
                                hasOwnProperty$3.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                        }
                        break;
                }
            }
        });

        if (shouldRemove) {
            list.remove(item);
        }
    });

    return selectorList.children.isEmpty();
}

var Rule = function cleanRule(node, item, list, options) {
    if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
    }

    var usageData = options.usage;

    if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);

        if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
        }
    }
};

// remove useless universal selector
var TypeSelector = function cleanTypeSelector(node, item, list) {
    var name = item.data.name;

    // check it's a non-namespaced universal selector
    if (name !== '*') {
        return;
    }

    // remove when universal selector before other selectors
    var nextType = item.next && item.next.data.type;
    if (nextType === 'IdSelector' ||
        nextType === 'ClassSelector' ||
        nextType === 'AttributeSelector' ||
        nextType === 'PseudoClassSelector' ||
        nextType === 'PseudoElementSelector') {
        list.remove(item);
    }
};

var { isNodeChildrenList } = utils$4;

function isSafeOperator(node) {
    return node.type === 'Operator' && node.value !== '+' && node.value !== '-';
}

var WhiteSpace = function cleanWhitespace(node, item, list) {
    // remove when first or last item in sequence
    if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
    }

    // white space in stylesheet or block children
    if (isNodeChildrenList(this.stylesheet, list) ||
        isNodeChildrenList(this.block, list)) {
        list.remove(item);
        return;
    }

    if (item.next.data.type === 'WhiteSpace') {
        list.remove(item);
        return;
    }

    if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
        list.remove(item);
        return;
    }
};

var walk$a = lib$1.walk;
var handlers$2 = {
    Atrule: Atrule$1,
    Comment: Comment,
    Declaration: Declaration,
    Raw: Raw,
    Rule: Rule,
    TypeSelector: TypeSelector,
    WhiteSpace: WhiteSpace
};

var clean$1 = function(ast, options) {
    walk$a(ast, {
        leave: function(node, item, list) {
            if (handlers$2.hasOwnProperty(node.type)) {
                handlers$2[node.type].call(this, node, item, list, options);
            }
        }
    });
};

var keyframes = function(node) {
    node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
            simpleselector.children.each(function(data, item) {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'TypeSelector',
                        loc: data.loc,
                        name: 'to'
                    };
                } else if (data.type === 'TypeSelector' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        loc: data.loc,
                        value: '0'
                    };
                }
            });
        });
    });
};

var resolveKeyword$3 = lib$1.keyword;
var compressKeyframes = keyframes;

var Atrule = function(node) {
    // compress @keyframe selectors
    if (resolveKeyword$3(node.name).basename === 'keyframes') {
        compressKeyframes(node);
    }
};

// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    if (value === '' || value === '-') {
        return;
    }

    // Escapes are valid, so replace them with a valid non-empty string
    value = value.replace(escapesRx, 'a');

    return !blockUnquoteRx.test(value);
}

var AttributeSelector = function(node) {
    var attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
    if (canUnquote(unquotedValue)) {
        node.value = {
            type: 'Identifier',
            loc: attrValue.loc,
            name: unquotedValue
        };
    }
};

var font = function compressFont(node) {
    var list = node.children;

    list.eachRight(function(node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                var prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            } else if (node.name === 'medium') {
                var next = item.next;

                if (!next || next.data.type !== 'Operator') {
                    this.remove(item);
                }
            }
        }
    });

    // remove redundant spaces
    list.each(function(node, item) {
        if (node.type === 'WhiteSpace') {
            if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
                this.remove(item);
            }
        }
    });

    if (list.isEmpty()) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};

var fontWeight = function compressFontWeight(node) {
    var value = node.children.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '400'
                };
                break;
            case 'bold':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '700'
                };
                break;
        }
    }
};

var List$5 = lib$1.List;

var background = function compressBackground(node) {
    function lastType() {
        if (buffer.length) {
            return buffer[buffer.length - 1].type;
        }
    }

    function flush() {
        if (lastType() === 'WhiteSpace') {
            buffer.pop();
        }

        if (!buffer.length) {
            buffer.unshift(
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                },
                {
                    type: 'WhiteSpace',
                    value: ' '
                },
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                }
            );
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    var newValue = [];
    var buffer = [];

    node.children.each(function(node) {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' ||
                node.name === 'none' ||
                node.name === 'repeat' ||
                node.name === 'scroll') {
                return;
            }
        }

        // don't add redundant spaces
        if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
            return;
        }

        buffer.push(node);
    });

    flush();
    node.children = new List$5().fromArray(newValue);
};

function removeItemAndRedundantWhiteSpace(list, item) {
    var prev = item.prev;
    var next = item.next;

    if (next !== null) {
        if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
            list.remove(next);
        }
    } else if (prev !== null && prev.data.type === 'WhiteSpace') {
        list.remove(prev);
    }

    list.remove(item);
}

var border = function compressBorder(node) {
    node.children.each(function(node, item, list) {
        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
            if (list.head === list.tail) {
                // replace `none` for zero when `none` is a single term
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '0'
                };
            } else {
                removeItemAndRedundantWhiteSpace(list, item);
            }
        }
    });
};

var resolveName = lib$1.property;
var handlers$1 = {
    'font': font,
    'font-weight': fontWeight,
    'background': background,
    'border': border,
    'outline': border
};

var Value = function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    var property = resolveName(this.declaration.property);

    if (handlers$1.hasOwnProperty(property.basename)) {
        handlers$1[property.basename](node);
    }
};

var _Number = {exports: {}};

var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var unsafeToRemovePlusSignAfter = {
    Dimension: true,
    Hash: true,
    Identifier: true,
    Number: true,
    Raw: true,
    UnicodeRange: true
};

function packNumber$3(value, item) {
    // omit plus sign only if no prev or prev is safe type
    var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
        ? KEEP_PLUSSIGN
        : OMIT_PLUSSIGN;

    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    // -0 -> '-'
    value = String(value).replace(regexp, '$1$2$3');

    if (value === '' || value === '-') {
        value = '0';
    }

    return value;
}

_Number.exports = function(node, item) {
    node.value = packNumber$3(node.value, item);
};
_Number.exports.pack = packNumber$3;

var packNumber$2 = _Number.exports.pack;
var MATH_FUNCTIONS = {
    'calc': true,
    'min': true,
    'max': true,
    'clamp': true
};
var LENGTH_UNIT = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var Dimension = function compressDimension(node, item) {
    var value = packNumber$2(node.value, item);

    node.value = value;

    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
        }

        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
        if (this.declaration.property === '-ms-flex' ||
            this.declaration.property === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
            return;
        }

        item.data = {
            type: 'Number',
            loc: node.loc,
            value: value
        };
    }
};

var lexer$1 = lib$1.lexer;
var packNumber$1 = _Number.exports.pack;
var blacklist = new Set([
    // see https://github.com/jakubpawlowicz/clean-css/issues/957
    'width',
    'min-width',
    'max-width',
    'height',
    'min-height',
    'max-height',

    // issue #410: Don’t remove units in flex-basis value for (-ms-)flex shorthand
    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
    'flex',
    '-ms-flex'
]);

var Percentage = function compressPercentage(node, item) {
    node.value = packNumber$1(node.value, item);

    if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
        // try to convert a number
        item.data = {
            type: 'Number',
            loc: node.loc,
            value: node.value
        };

        // that's ok only when new value matches on length
        if (!lexer$1.matchDeclaration(this.declaration).isType(item.data, 'length')) {
            // otherwise rollback changes
            item.data = node;
        }
    }
};

var _String = function(node) {
    var value = node.value;

    // remove escaped newlines, i.e.
    // .a { content: "foo\
    // bar"}
    // ->
    // .a { content: "foobar" }
    value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');

    node.value = value;
};

var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

var Url = function(node) {
    var value = node.value;

    if (value.type !== 'String') {
        return;
    }

    var quote = value.value[0];
    var url = value.value.substr(1, value.value.length - 2);

    // convert `\\` to `/`
    url = url.replace(/\\\\/g, '/');

    // remove quotes when safe
    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
    if (SAFE_URL.test(url)) {
        node.value = {
            type: 'Raw',
            loc: node.value.loc,
            value: url
        };
    } else {
        // use double quotes if string has no double quotes
        // otherwise use original quotes
        // TODO: make better quote type selection
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
    }
};

var lexer = lib$1.lexer;
var packNumber = _Number.exports.pack;

// http://www.w3.org/TR/css3-color/#svg-color
var NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

var HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function hslToRgb(h, s, l, a) {
    var r;
    var g;
    var b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
    ];
}

function toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? '0' + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
    var cursor = functionArgs.head;
    var args = [];
    var wasValue = false;

    while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;

        switch (type) {
            case 'Number':
            case 'Percentage':
                if (wasValue) {
                    return;
                }

                wasValue = true;
                args.push({
                    type: type,
                    value: Number(node.value)
                });
                break;

            case 'Operator':
                if (node.value === ',') {
                    if (!wasValue) {
                        return;
                    }
                    wasValue = false;
                } else if (wasValue || node.value !== '+') {
                    return;
                }
                break;

            default:
                // something we couldn't understand
                return;
        }

        cursor = cursor.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' ||
            args[1].type !== 'Percentage' ||
            args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function(arg) {
        var value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (((value % 360) + 360) % 360) / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function compressFunction(node, item, list) {
    var functionName = node.name;
    var args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = hslToRgb.apply(null, args);
            node.name = 'rgba';
        }

        if (args[3] === 0) {
            // try to replace `rgba(x, x, x, 0)` to `transparent`
            // always replace `rgba(0, 0, 0, 0)` to `transparent`
            // otherwise avoid replacement in gradients since it may break color transition
            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
            var scopeFunctionName = this.function && this.function.name;
            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

                item.data = {
                    type: 'Identifier',
                    loc: node.loc,
                    name: 'transparent'
                };

                return;
            }
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.children.each(function(node, item, list) {
                if (node.type === 'Operator') {
                    if (node.value !== ',') {
                        list.remove(item);
                    }
                    return;
                }

                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: packNumber(args.shift(), null)
                };
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || parseFunctionArgs(node.children, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = hslToRgb.apply(null, args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || parseFunctionArgs(node.children, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        // check if color is not at the end and not followed by space
        var next = item.next;
        if (next && next.data.type !== 'WhiteSpace') {
            list.insert(list.createItem({
                type: 'WhiteSpace',
                value: ' '
            }), next);
        }

        item.data = {
            type: 'Hash',
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };

        compressHex(item.data, item);
    }
}

function compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    var color = node.name.toLowerCase();

    if (NAME_TO_HEX.hasOwnProperty(color) &&
        lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
        var hex = NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'Hash',
                loc: node.loc,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function compressHex(node, item) {
    var color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 &&
        color[0] === color[1] &&
        color[2] === color[3] &&
        color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            loc: node.loc,
            name: HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

var color = {
    compressFunction: compressFunction,
    compressIdent: compressIdent,
    compressHex: compressHex
};

var walk$9 = lib$1.walk;
var handlers = {
    Atrule: Atrule,
    AttributeSelector: AttributeSelector,
    Value: Value,
    Dimension: Dimension,
    Percentage: Percentage,
    Number: _Number.exports,
    String: _String,
    Url: Url,
    Hash: color.compressHex,
    Identifier: color.compressIdent,
    Function: color.compressFunction
};

var replace$1 = function(ast) {
    walk$9(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list);
            }
        }
    });
};

var generate$5 = lib$1.generate;

function Index() {
    this.seed = 0;
    this.map = Object.create(null);
}

Index.prototype.resolve = function(str) {
    var index = this.map[str];

    if (!index) {
        index = ++this.seed;
        this.map[str] = index;
    }

    return index;
};

var createDeclarationIndexer$1 = function createDeclarationIndexer() {
    var ids = new Index();

    return function markDeclaration(node) {
        var id = generate$5(node);

        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;

        return node;
    };
};

var generate$4 = lib$1.generate;
var specificity = specificity$3;

var nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

var processSelector$1 = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.prelude.children.each(function(simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.children.each(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + generate$4(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClassSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                        pseudos[':' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElementSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                        pseudos['::' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'WhiteSpace':
                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = generate$4(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
};

var resolveKeyword$2 = lib$1.keyword;
var walk$8 = lib$1.walk;
var generate$3 = lib$1.generate;
var createDeclarationIndexer = createDeclarationIndexer$1;
var processSelector = processSelector$1;

var prepare$1 = function prepare(ast, options) {
    var markDeclaration = createDeclarationIndexer();

    walk$8(ast, {
        visit: 'Rule',
        enter: function processRule(node) {
            node.block.children.each(markDeclaration);
            processSelector(node, options.usage);
        }
    });

    walk$8(ast, {
        visit: 'Atrule',
        enter: function(node) {
            if (node.prelude) {
                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
                node.prelude.id = generate$3(node.prelude);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (resolveKeyword$2(node.name).basename === 'keyframes') {
                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
                node.block.children.each(function(rule) {
                    rule.prelude.children.each(function(simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
        }
    });

    return {
        declaration: markDeclaration
    };
};

var List$4 = lib$1.List;
var resolveKeyword$1 = lib$1.keyword;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var walk$7 = lib$1.walk;

function addRuleToMap(map, item, list, single) {
    var node = item.data;
    var name = resolveKeyword$1(node.name).basename;
    var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

    if (!hasOwnProperty$2.call(map, name)) {
        map[name] = Object.create(null);
    }

    if (single) {
        delete map[name][id];
    }

    if (!hasOwnProperty$2.call(map[name], id)) {
        map[name][id] = new List$4();
    }

    map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
    var collected = Object.create(null);
    var topInjectPoint = null;

    ast.children.each(function(node, item, list) {
        if (node.type === 'Atrule') {
            var name = resolveKeyword$1(node.name).basename;

            switch (name) {
                case 'keyframes':
                    addRuleToMap(collected, item, list, true);
                    return;

                case 'media':
                    if (options.forceMediaMerge) {
                        addRuleToMap(collected, item, list, false);
                        return;
                    }
                    break;
            }

            if (topInjectPoint === null &&
                name !== 'charset' &&
                name !== 'import') {
                topInjectPoint = item;
            }
        } else {
            if (topInjectPoint === null) {
                topInjectPoint = item;
            }
        }
    });

    for (var atrule in collected) {
        for (var id in collected[atrule]) {
            ast.children.insertList(
                collected[atrule][id],
                atrule === 'media' ? null : topInjectPoint
            );
        }
    }
}
function isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
        return;
    }

    var prev = item.prev && item.prev.data;

    if (!prev || !isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.prelude &&
        prev.prelude &&
        node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);

        // TODO: use it when we can refer to several points in source
        // prev.loc = {
        //     primary: prev.loc,
        //     merged: node.loc
        // };
    }
}

var _1MergeAtrule = function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);

    walk$7(ast, {
        visit: 'Atrule',
        reverse: true,
        enter: processAtrule
    });
};

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function isEqualSelectors(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
    var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    var fingerprints = Object.create(null);
    var declarations2hash = Object.create(null);

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        declarations2hash[cursor.data.id] = true;
    }

    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (declarations2hash[data.id]) {
            // when declarations1 has an overriding declaration, this is not a difference
            // unless no !important is used on prev and !important is used on the following
            if (!hasOwnProperty$1.call(fingerprints, data.fingerprint) ||
                (!fingerprints[data.fingerprint] && data.important)) {
                result.ne2.push(data);
            }

            result.ne2overrided.push(data);
        }
    }

    return result;
}

function addSelectors(dest, source) {
    source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;

        while (cursor) {
            var nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
    var cursor1 = selectors1.head;

    while (cursor1 !== null) {
        var cursor2 = selectors2.head;

        while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
                return true;
            }

            cursor2 = cursor2.next;
        }

        cursor1 = cursor1.next;
    }

    return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Rule':
            // unsafe skip ruleset with selector similarities
            return hasSimilarSelectors(node.prelude.children, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.children.some(unsafeToSkipNode, this);
            }
            break;

        case 'Declaration':
            return false;
    }

    // unsafe by default
    return true;
}

var utils$3 = {
    isEqualSelectors: isEqualSelectors,
    isEqualDeclarations: isEqualDeclarations,
    compareDeclarations: compareDeclarations,
    addSelectors: addSelectors,
    hasSimilarSelectors: hasSimilarSelectors,
    unsafeToSkipNode: unsafeToSkipNode
};

var walk$6 = lib$1.walk;
var utils$2 = utils$3;

function processRule$5(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;

    list.prevUntil(item.prev, function(prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return utils$2.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (utils$2.isEqualSelectors(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (utils$2.isEqualDeclarations(declarations, prevDeclarations)) {
                utils$2.addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return utils$2.hasSimilarSelectors(selectors, prevSelectors);
    });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
var _2InitialMergeRuleset = function initialMergeRule(ast) {
    walk$6(ast, {
        visit: 'Rule',
        enter: processRule$5
    });
};

var List$3 = lib$1.List;
var walk$5 = lib$1.walk;

function processRule$4(node, item, list) {
    var selectors = node.prelude.children;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        var newSelectors = new List$3();
        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Rule',
            loc: node.loc,
            prelude: {
                type: 'SelectorList',
                loc: node.prelude.loc,
                children: newSelectors
            },
            block: {
                type: 'Block',
                loc: node.block.loc,
                children: node.block.children.copy()
            },
            pseudoSignature: node.pseudoSignature
        }), item);
    }
}

var _3DisjoinRuleset = function disjoinRule(ast) {
    walk$5(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule$4
    });
};

var List$2 = lib$1.List;
var generate$2 = lib$1.generate;
var walk$4 = lib$1.walk;

var REPLACE = 1;
var REMOVE = 2;
var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var SIDES = ['top', 'right', 'bottom', 'left'];
var SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
var MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

function TRBL(name) {
    this.name = name;
    this.loc = null;
    this.iehack = undefined;
    this.sides = {
        'top': null,
        'right': null,
        'bottom': null,
        'left': null
    };
}

TRBL.prototype.getValueSequence = function(declaration, count) {
    var values = [];
    var iehack = '';
    var hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function(child) {
        var special = false;

        switch (child.type) {
            case 'Identifier':
                switch (child.name) {
                    case '\\0':
                    case '\\9':
                        iehack = child.name;
                        return;

                    case 'inherit':
                    case 'initial':
                    case 'unset':
                    case 'revert':
                        special = child.name;
                        break;
                }
                break;

            case 'Dimension':
                switch (child.unit) {
                    // is not supported until IE11
                    case 'rem':

                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case 'vw':
                    case 'vh':
                    case 'vmin':
                    case 'vmax':
                    case 'vm': // IE9 supporting "vm" instead of "vmin".
                        special = child.unit;
                        break;
                }
                break;

            case 'Hash': // color
            case 'Number':
            case 'Percentage':
                break;

            case 'Function':
                if (child.name === 'var') {
                    return true;
                }

                special = child.name;
                break;

            case 'WhiteSpace':
                return false; // ignore space

            default:
                return true;  // bad value
        }

        values.push({
            node: child,
            special: special,
            important: declaration.important
        });
    });

    if (hasBadValues || values.length > count) {
        return false;
    }

    if (typeof this.iehack === 'string' && this.iehack !== iehack) {
        return false;
    }

    this.iehack = iehack; // move outside

    return values;
};

TRBL.prototype.canOverride = function(side, value) {
    var currentValue = this.sides[side];

    return !currentValue || (value.important && !currentValue.important);
};

TRBL.prototype.add = function(name, declaration) {
    function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];

        if (side) {
            if (side in sides === false) {
                return false;
            }

            var values = this.getValueSequence(declaration, 1);

            if (!values || !values.length) {
                return false;
            }

            // can mix only if specials are equal
            for (var key in sides) {
                if (sides[key] !== null && sides[key].special !== values[0].special) {
                    return false;
                }
            }

            if (!this.canOverride(side, values[0])) {
                return true;
            }

            sides[side] = values[0];
            return true;
        } else if (name === this.name) {
            var values = this.getValueSequence(declaration, 4);

            if (!values || !values.length) {
                return false;
            }

            switch (values.length) {
                case 1:
                    values[RIGHT] = values[TOP];
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[TOP];
                    break;

                case 2:
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[RIGHT];
                    break;

                case 3:
                    values[LEFT] = values[RIGHT];
                    break;
            }

            // can mix only if specials are equal
            for (var i = 0; i < 4; i++) {
                for (var key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[i].special) {
                        return false;
                    }
                }
            }

            for (var i = 0; i < 4; i++) {
                if (this.canOverride(SIDES[i], values[i])) {
                    sides[SIDES[i]] = values[i];
                }
            }

            return true;
        }
    }

    if (!attemptToAdd.call(this)) {
        return false;
    }

    // TODO: use it when we can refer to several points in source
    // if (this.loc) {
    //     this.loc = {
    //         primary: this.loc,
    //         merged: declaration.loc
    //     };
    // } else {
    //     this.loc = declaration.loc;
    // }
    if (!this.loc) {
        this.loc = declaration.loc;
    }

    return true;
};

TRBL.prototype.isOkToMinimize = function() {
    var top = this.sides.top;
    var right = this.sides.right;
    var bottom = this.sides.bottom;
    var left = this.sides.left;

    if (top && right && bottom && left) {
        var important =
            top.important +
            right.important +
            bottom.important +
            left.important;

        return important === 0 || important === 4;
    }

    return false;
};

TRBL.prototype.getValue = function() {
    var result = new List$2();
    var sides = this.sides;
    var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
    ];
    var stringValues = [
        generate$2(sides.top.node),
        generate$2(sides.right.node),
        generate$2(sides.bottom.node),
        generate$2(sides.left.node)
    ];

    if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
                values.pop();
            }
        }
    }

    for (var i = 0; i < values.length; i++) {
        if (i) {
            result.appendData({ type: 'WhiteSpace', value: ' ' });
        }

        result.appendData(values[i].node);
    }

    if (this.iehack) {
        result.appendData({ type: 'WhiteSpace', value: ' ' });
        result.appendData({
            type: 'Identifier',
            loc: null,
            name: this.iehack
        });
    }

    return {
        type: 'Value',
        loc: null,
        children: result
    };
};

TRBL.prototype.getDeclaration = function() {
    return {
        type: 'Declaration',
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
    };
};

function processRule$3(rule, shorts, shortDeclarations, lastShortSelector) {
    var declarations = rule.block.children;
    var selector = rule.prelude.children.first().id;

    rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;

        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);

            // if can't parse value ignore it and break shorthand children
            if (!shorthand.add(property, declaration)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation: operation,
            block: declarations,
            item: item,
            shorthand: shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
            item.block.remove(item.item);
        }
    });
}

var _4RestructShorthand = function restructBlock(ast, indexer) {
    var stylesheetMap = {};
    var shortDeclarations = [];

    walk$4(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var shorts;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {
                    lastShortSelector: null
                };
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                shorts = ruleMap[ruleId];
            } else {
                shorts = {};
                ruleMap[ruleId] = shorts;
            }

            ruleMap.lastShortSelector = processRule$3.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
    });

    processShorthands(shortDeclarations, indexer.declaration);
};

var resolveProperty = lib$1.property;
var resolveKeyword = lib$1.keyword;
var walk$3 = lib$1.walk;
var generate$1 = lib$1.generate;
var fingerprintId = 1;
var dontRestructure = {
    'src': 1 // https://github.com/afelix/csso/issues/50
};

var DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

var SAFE_VALUES = {
    cursor: [
        'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
        'n-resize', 'e-resize', 's-resize', 'w-resize',
        'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
        'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
        'col-resize', 'row-resize'
    ],
    overflow: [
        'hidden', 'visible', 'scroll', 'auto'
    ],
    position: [
        'static', 'relative', 'absolute', 'fixed'
    ]
};

var NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    var realName = resolveProperty(propertyName).basename;

    if (realName === 'background') {
        return propertyName + ':' + generate$1(declaration.value);
    }

    var declarationId = declaration.id;
    var fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        switch (declaration.value.type) {
            case 'Value':
                var vendorId = '';
                var iehack = '';
                var special = {};
                var raw = false;

                declaration.value.children.each(function walk(node) {
                    switch (node.type) {
                        case 'Value':
                        case 'Brackets':
                        case 'Parentheses':
                            node.children.each(walk);
                            break;

                        case 'Raw':
                            raw = true;
                            break;

                        case 'Identifier':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (/\\[09]/.test(name)) {
                                iehack = RegExp.lastMatch;
                            }

                            if (SAFE_VALUES.hasOwnProperty(realName)) {
                                if (SAFE_VALUES[realName].indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                                if (DONT_MIX_VALUE[realName].test(name)) {
                                    special[name] = true;
                                }
                            }

                            break;

                        case 'Function':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (name === 'rect') {
                                // there are 2 forms of rect:
                                //   rect(<top>, <right>, <bottom>, <left>) - standart
                                //   rect(<top> <right> <bottom> <left>) – backwards compatible syntax
                                // only the same form values can be merged
                                var hasComma = node.children.some(function(node) {
                                    return node.type === 'Operator' && node.value === ',';
                                });
                                if (!hasComma) {
                                    name = 'rect-backward';
                                }
                            }

                            special[name + '()'] = true;

                            // check nested tokens too
                            node.children.each(walk);

                            break;

                        case 'Dimension':
                            var unit = node.unit;

                            if (/\\[09]/.test(unit)) {
                                iehack = RegExp.lastMatch;
                            }

                            switch (unit) {
                                // is not supported until IE11
                                case 'rem':

                                // v* units is too buggy across browsers and better
                                // don't merge values with those units
                                case 'vw':
                                case 'vh':
                                case 'vmin':
                                case 'vmax':
                                case 'vm': // IE9 supporting "vm" instead of "vmin".
                                    special[unit] = true;
                                    break;
                            }
                            break;
                    }
                });

                fingerprint = raw
                    ? '!' + fingerprintId++
                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
                break;

            case 'Raw':
                fingerprint = '!' + declaration.value.value;
                break;

            default:
                fingerprint = generate$1(declaration.value);
        }

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
    var property = resolveProperty(declaration.property);

    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];

        for (var i = 0; i < table.length; i++) {
            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

            if (prev && (!declaration.important || prev.item.data.important)) {
                return prev;
            }
        }
    }
}

function processRule$2(rule, item, list, props, fingerprints) {
    var declarations = rule.block.children;

    declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];

        if (prev && !dontRestructure.hasOwnProperty(property)) {
            if (declaration.important && !prev.item.data.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);

                // TODO: use it when we can refer to several points in source
                // declaration.loc = {
                //     primary: declaration.loc,
                //     merged: prev.item.data.loc
                // };
            } else {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            }
        } else {
            var prev = needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty()) {
        list.remove(item);
    }
}

var _6RestructBlock = function restructBlock(ast) {
    var stylesheetMap = {};
    var fingerprints = Object.create(null);

    walk$3(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node, item, list) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var props;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {};
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                props = ruleMap[ruleId];
            } else {
                props = {};
                ruleMap[ruleId] = props;
            }

            processRule$2.call(this, node, item, list, props, fingerprints);
        }
    });
};

var walk$2 = lib$1.walk;
var utils$1 = utils$3;

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function processRule$1(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;
    var nodeCompareMarker = selectors.first().compareMarker;
    var skippedCompareMarkers = {};

    list.nextUntil(item.next, function(next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Rule') {
            return utils$1.unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (utils$1.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;

            selectors.some(function(data, item) {
                var curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
}

var _7MergeRuleset = function mergeRule(ast) {
    walk$2(ast, {
        visit: 'Rule',
        enter: processRule$1
    });
};

var List$1 = lib$1.List;
var walk$1 = lib$1.walk;
var utils = utils$3;

function calcSelectorLength(list) {
    var length = 0;

    list.each(function(data) {
        length += data.id.length + 1;
    });

    return length - 1;
}

function calcDeclarationsLength(tokens) {
    var length = 0;

    for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
    }

    return (
        length +          // declarations
        tokens.length - 1 // delimeters
    );
}

function processRule(node, item, list) {
    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    var selectors = node.prelude.children;
    var block = node.block;
    var disallowDownMarkers = Object.create(null);
    var allowMergeUp = true;
    var allowMergeDown = true;

    list.prevUntil(item.prev, function(prev, prevItem) {
        var prevBlock = prev.block;
        var prevType = prev.type;

        if (prevType !== 'Rule') {
            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);

            if (!unsafe && prevType === 'Atrule' && prevBlock) {
                walk$1(prevBlock, {
                    visit: 'Rule',
                    enter: function(node) {
                        node.prelude.children.each(function(data) {
                            disallowDownMarkers[data.compareMarker] = true;
                        });
                    }
                });
            }

            return unsafe;
        }

        var prevSelectors = prev.prelude.children;

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        allowMergeDown = !prevSelectors.some(function(selector) {
            return selector.compareMarker in disallowDownMarkers;
        });

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
        }

        // try to join by properties
        var diff = utils.compareDeclarations(block.children, prevBlock.children);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    utils.addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    var selectorLength = calcSelectorLength(selectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        utils.addSelectors(prevSelectors, selectors);
                        block.children = new List$1().fromArray(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    var selectorLength = calcSelectorLength(prevSelectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        utils.addSelectors(selectors, prevSelectors);
                        prevBlock.children = new List$1().fromArray(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    var newSelector = {
                        type: 'SelectorList',
                        loc: null,
                        children: utils.addSelectors(prevSelectors.copy(), selectors)
                    };
                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (blockLength >= newBlockLength) {
                        var newItem = list.createItem({
                            type: 'Rule',
                            loc: null,
                            prelude: newSelector,
                            block: {
                                type: 'Block',
                                loc: null,
                                children: new List$1().fromArray(diff.eq)
                            },
                            pseudoSignature: node.pseudoSignature
                        });

                        block.children = new List$1().fromArray(diff.ne1);
                        prevBlock.children = new List$1().fromArray(diff.ne2overrided);

                        if (allowMergeUp) {
                            list.insert(newItem, prevItem);
                        } else {
                            list.insert(newItem, item);
                        }

                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some(function(prevSelector) {
                return selectors.some(function(selector) {
                    return selector.compareMarker === prevSelector.compareMarker;
                });
            });
        }

        prevSelectors.each(function(data) {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
}

var _8RestructRuleset = function restructRule(ast) {
    walk$1(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};

var prepare = prepare$1;
var mergeAtrule = _1MergeAtrule;
var initialMergeRuleset = _2InitialMergeRuleset;
var disjoinRuleset = _3DisjoinRuleset;
var restructShorthand = _4RestructShorthand;
var restructBlock = _6RestructBlock;
var mergeRuleset = _7MergeRuleset;
var restructRuleset = _8RestructRuleset;

var restructure$1 = function(ast, options) {
    // prepare ast for restructing
    var indexer = prepare(ast, options);
    options.logger('prepare', ast);

    mergeAtrule(ast, options);
    options.logger('mergeAtrule', ast);

    initialMergeRuleset(ast);
    options.logger('initialMergeRuleset', ast);

    disjoinRuleset(ast);
    options.logger('disjoinRuleset', ast);

    restructShorthand(ast, indexer);
    options.logger('restructShorthand', ast);

    restructBlock(ast);
    options.logger('restructBlock', ast);

    mergeRuleset(ast);
    options.logger('mergeRuleset', ast);

    restructRuleset(ast);
    options.logger('restructRuleset', ast);
};

var List = lib$1.List;
var clone = lib$1.clone;
var usageUtils = usage;
var clean = clean$1;
var replace = replace$1;
var restructure = restructure$1;
var walk = lib$1.walk;

function readChunk(children, specialComments) {
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.nextUntil(children.head, function(node, item, list) {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;
            return;
        }

        if (node.type !== 'WhiteSpace') {
            nonSpaceTokenInBuffer = true;
        }

        buffer.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            loc: null,
            children: buffer
        }
    };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger('Compress block #' + num, null, true);

    var seed = 1;

    if (ast.type === 'StyleSheet') {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
    }

    walk(ast, {
        visit: 'Atrule',
        enter: function markScopes(node) {
            if (node.block !== null) {
                node.block.id = seed++;
            }
        }
    });
    options.logger('init', ast);

    // remove redundant
    clean(ast, options);
    options.logger('clean', ast);

    // replace nodes for shortened forms
    replace(ast);
    options.logger('replace', ast);

    // structure optimisations
    if (options.restructuring) {
        restructure(ast, options);
    }

    return ast;
}

function getCommentsOption(options) {
    var comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function getRestructureOption(options) {
    if ('restructure' in options) {
        return options.restructure;
    }

    return 'restructuring' in options ? options.restructuring : true;
}

function wrapBlock(block) {
    return new List().appendData({
        type: 'Rule',
        loc: null,
        prelude: {
            type: 'SelectorList',
            loc: null,
            children: new List().appendData({
                type: 'Selector',
                loc: null,
                children: new List().appendData({
                    type: 'TypeSelector',
                    loc: null,
                    name: 'x'
                })
            })
        },
        block: block
    });
}

var compress$1 = function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
    options = options || {};

    var compressOptions = {
        logger: typeof options.logger === 'function' ? options.logger : function() {},
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
    };
    var specialComments = getCommentsOption(options);
    var firstAtrulesAllowed = true;
    var input;
    var output = new List();
    var chunk;
    var chunkNum = 1;
    var chunkChildren;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        input = ast.children;
        ast.children = output;
    } else {
        input = wrapBlock(ast);
    }

    do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in output
            if (!output.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            output.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkChildren.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
            var lastRule = chunkChildren.last();

            if (lastRule.type !== 'Atrule' ||
               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        output.appendList(chunkChildren);
    } while (!input.isEmpty());

    return {
        ast: ast
    };
};

var name = "csso";
var version = "4.2.0";
var description = "CSS minifier with structural optimisations";
var homepage = "https://github.com/css/csso";
var author = "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)";
var maintainers = [
	{
		name: "Roman Dvornov",
		email: "rdvornov@gmail.com",
		"github-username": "lahmatiy"
	}
];
var license = "MIT";
var repository = "css/csso";
var bugs = {
	url: "https://github.com/css/csso/issues"
};
var keywords = [
	"css",
	"compress",
	"minifier",
	"minify",
	"optimise",
	"optimisation",
	"csstree"
];
var main = "./lib/index";
var scripts = {
	test: "mocha --reporter dot",
	lint: "eslint lib test",
	"lint-and-test": "npm run lint && npm test",
	build: "rollup --config && terser dist/csso.js --compress --mangle -o dist/csso.min.js",
	coverage: "nyc npm test",
	coveralls: "nyc report --reporter=text-lcov | coveralls",
	travis: "nyc npm run lint-and-test && npm run coveralls",
	hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
	prepublishOnly: "npm run build"
};
var dependencies = {
	"css-tree": "^1.1.2"
};
var browser = {
	"css-tree": "css-tree/dist/csstree.min.js"
};
var devDependencies = {
	"@rollup/plugin-commonjs": "^11.0.1",
	"@rollup/plugin-json": "^4.0.1",
	"@rollup/plugin-node-resolve": "^7.0.0",
	coveralls: "^3.0.11",
	eslint: "^6.8.0",
	mocha: "^7.1.1",
	nyc: "^15.0.0",
	rollup: "^1.29.0",
	"source-map": "^0.6.1",
	terser: "^4.6.3"
};
var engines = {
	node: ">=8.0.0"
};
var files = [
	"dist",
	"lib"
];
var require$$2 = {
	name: name,
	version: version,
	description: description,
	homepage: homepage,
	author: author,
	maintainers: maintainers,
	license: license,
	repository: repository,
	bugs: bugs,
	keywords: keywords,
	main: main,
	scripts: scripts,
	dependencies: dependencies,
	browser: browser,
	devDependencies: devDependencies,
	engines: engines,
	files: files
};

var csstree$1 = lib$1;
var parse = csstree$1.parse;
var compress = compress$1;
var generate = csstree$1.generate;

function debugOutput(name, options, startTime, data) {
    if (options.debug) {
        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
    }

    return data;
}

function createDefaultLogger(level) {
    var lastDebug;

    return function logger(title, ast) {
        var line = title;

        if (ast) {
            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
        }

        if (level > 1 && ast) {
            var css = generate(ast);

            // when level 2, limit css to 256 symbols
            if (level === 2 && css.length > 256) {
                css = css.substr(0, 256) + '...';
            }

            line += '\n  ' + css + '\n';
        }

        console.error(line);
        lastDebug = Date.now();
    };
}

function copy(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = obj[key];
    }

    return result;
}

function buildCompressOptions(options) {
    options = copy(options);

    if (typeof options.logger !== 'function' && options.debug) {
        options.logger = createDefaultLogger(options.debug);
    }

    return options;
}

function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
        handlers = [handlers];
    }

    handlers.forEach(function(fn) {
        fn(ast, options);
    });
}

function minify(context, source, options) {
    options = options || {};

    var filename = options.filename || '<unknown>';
    var result;

    // parse
    var ast = debugOutput('parsing', options, Date.now(),
        parse(source, {
            context: context,
            filename: filename,
            positions: Boolean(options.sourceMap)
        })
    );

    // before compress handlers
    if (options.beforeCompress) {
        debugOutput('beforeCompress', options, Date.now(),
            runHandler(ast, options, options.beforeCompress)
        );
    }

    // compress
    var compressResult = debugOutput('compress', options, Date.now(),
        compress(ast, buildCompressOptions(options))
    );

    // after compress handlers
    if (options.afterCompress) {
        debugOutput('afterCompress', options, Date.now(),
            runHandler(compressResult, options, options.afterCompress)
        );
    }

    // generate
    if (options.sourceMap) {
        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (function() {
            var tmp = generate(compressResult.ast, { sourceMap: true });
            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
            tmp.map.setSourceContent(filename, source);
            return tmp;
        }()));
    } else {
        result = debugOutput('generate', options, Date.now(), {
            css: generate(compressResult.ast),
            map: null
        });
    }

    return result;
}

function minifyStylesheet(source, options) {
    return minify('stylesheet', source, options);
}

function minifyBlock(source, options) {
    return minify('declarationList', source, options);
}

var lib = {
    version: require$$2.version,

    // main methods
    minify: minifyStylesheet,
    minifyBlock: minifyBlock,

    // css syntax parser/walkers/generator/etc
    syntax: Object.assign({
        compress: compress
    }, csstree$1)
};

const csso = lib;
const { traverse: traverse$2 } = xast;

minifyStyles.type = 'full';

minifyStyles.active = true;

minifyStyles.description =
  'minifies styles and removes unused styles based on usage data';

minifyStyles.params = {
  // ... CSSO options goes here

  // additional
  usage: {
    force: false, // force to use usage data even if it unsafe (document contains <script> or on* attributes)
    ids: true,
    classes: true,
    tags: true,
  },
};

/**
 * Minifies styles (<style> element + style attribute) using CSSO
 *
 * @author strarsis <strarsis@gmail.com>
 */
minifyStyles.fn = function (ast, options) {
  options = options || {};

  var minifyOptionsForStylesheet = cloneObject(options);
  var minifyOptionsForAttribute = cloneObject(options);
  var elems = findStyleElems(ast);

  minifyOptionsForStylesheet.usage = collectUsageData(ast, options);
  minifyOptionsForAttribute.usage = null;

  elems.forEach(function (elem) {
    if (elem.isElem('style')) {
      if (
        elem.children[0].type === 'text' ||
        elem.children[0].type === 'cdata'
      ) {
        const styleCss = elem.children[0].value;
        const minified = csso.minify(styleCss, minifyOptionsForStylesheet).css;
        // preserve cdata if necessary
        // TODO split cdata -> text optimisation into separate plugin
        if (styleCss.indexOf('>') >= 0 || styleCss.indexOf('<') >= 0) {
          elem.children[0].type = 'cdata';
          elem.children[0].value = minified;
        } else {
          elem.children[0].type = 'text';
          elem.children[0].value = minified;
        }
      }
    } else {
      // style attribute
      var elemStyle = elem.attributes.style;

      elem.attributes.style = csso.minifyBlock(
        elemStyle,
        minifyOptionsForAttribute
      ).css;
    }
  });

  return ast;
};

function cloneObject(obj) {
  return { ...obj };
}

function findStyleElems(ast) {
  const nodesWithStyles = [];
  traverse$2(ast, (node) => {
    if (node.type === 'element') {
      if (node.name === 'style' && node.children.length !== 0) {
        nodesWithStyles.push(node);
      } else if (node.attributes.style != null) {
        nodesWithStyles.push(node);
      }
    }
  });
  return nodesWithStyles;
}

function shouldFilter(options, name) {
  if ('usage' in options === false) {
    return true;
  }

  if (options.usage && name in options.usage === false) {
    return true;
  }

  return Boolean(options.usage && options.usage[name]);
}

function collectUsageData(ast, options) {
  let safe = true;
  const usageData = {};
  let hasData = false;
  const rawData = {
    ids: Object.create(null),
    classes: Object.create(null),
    tags: Object.create(null),
  };

  traverse$2(ast, (node) => {
    if (node.type === 'element') {
      if (node.name === 'script') {
        safe = false;
      }

      rawData.tags[node.name] = true;

      if (node.attributes.id != null) {
        rawData.ids[node.attributes.id] = true;
      }

      if (node.attributes.class != null) {
        node.attributes.class
          .replace(/^\s+|\s+$/g, '')
          .split(/\s+/)
          .forEach((className) => {
            rawData.classes[className] = true;
          });
      }

      if (Object.keys(node.attributes).some((name) => /^on/i.test(name))) {
        safe = false;
      }
    }
  });

  if (!safe && options.usage && options.usage.force) {
    safe = true;
  }

  for (const [key, data] of Object.entries(rawData)) {
    if (shouldFilter(options, key)) {
      usageData[key] = Object.keys(data);
      hasData = true;
    }
  }

  return safe && hasData ? usageData : null;
}

var moveElemsAttrsToGroup = {};

const { inheritableAttrs: inheritableAttrs$1, pathElems: pathElems$1 } = _collections;

moveElemsAttrsToGroup.type = 'perItemReverse';

moveElemsAttrsToGroup.active = true;

moveElemsAttrsToGroup.description = 'moves elements attributes to the existing group wrapper';

/**
 * Collapse content's intersected and inheritable
 * attributes to the existing group wrapper.
 *
 * @example
 * <g attr1="val1">
 *     <g attr2="val2">
 *         text
 *     </g>
 *     <circle attr2="val2" attr3="val3"/>
 * </g>
 *              ⬇
 * <g attr1="val1" attr2="val2">
 *     <g>
 *         text
 *     </g>
 *    <circle attr3="val3"/>
 * </g>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
moveElemsAttrsToGroup.fn = function (item) {
  if (
    item.type === 'element' &&
    item.name === 'g' &&
    item.children.length > 1
  ) {
    var intersection = {},
      hasTransform = false,
      hasClip =
        item.attributes['clip-path'] != null || item.attributes.mask != null,
      intersected = item.children.every(function (inner) {
        if (
          inner.type === 'element' &&
          Object.keys(inner.attributes).length !== 0
        ) {
          // don't mess with possible styles (hack until CSS parsing is implemented)
          if (inner.attributes.class) return false;
          if (!Object.keys(intersection).length) {
            intersection = inner.attributes;
          } else {
            intersection = intersectInheritableAttrs(
              intersection,
              inner.attributes
            );

            if (!intersection) return false;
          }

          return true;
        }
      }),
      allPath = item.children.every(function (inner) {
        return inner.isElem(pathElems$1);
      });

    if (intersected) {
      item.children.forEach(function (g) {
        for (const [name, value] of Object.entries(intersection)) {
          if ((!allPath && !hasClip) || name !== 'transform') {
            delete g.attributes[name];

            if (name === 'transform') {
              if (!hasTransform) {
                if (item.attributes.transform != null) {
                  item.attributes.transform =
                    item.attributes.transform + ' ' + value;
                } else {
                  item.attributes.transform = value;
                }

                hasTransform = true;
              }
            } else {
              item.attributes[name] = value;
            }
          }
        }
      });
    }
  }
};

/**
 * Intersect inheritable attributes.
 *
 * @param {Object} a first attrs object
 * @param {Object} b second attrs object
 *
 * @return {Object} intersected attrs object
 */
function intersectInheritableAttrs(a, b) {
  var c = {};

  for (const [name, value] of Object.entries(a)) {
    if (
      // eslint-disable-next-line no-prototype-builtins
      b.hasOwnProperty(name) &&
      inheritableAttrs$1.includes(name) &&
      value === b[name]
    ) {
      c[name] = value;
    }
  }

  if (!Object.keys(c).length) return false;

  return c;
}

var moveGroupAttrsToElems = {};

const { pathElems, referencesProps: referencesProps$1 } = _collections;

moveGroupAttrsToElems.type = 'perItem';

moveGroupAttrsToElems.active = true;

moveGroupAttrsToElems.description = 'moves some group attributes to the content elements';

const pathElemsWithGroupsAndText = [...pathElems, 'g', 'text'];

/**
 * Move group attrs to the content elements.
 *
 * @example
 * <g transform="scale(2)">
 *     <path transform="rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *                          ⬇
 * <g>
 *     <path transform="scale(2) rotate(45)" d="M0,0 L10,20"/>
 *     <path transform="scale(2) translate(10, 20)" d="M0,10 L20,30"/>
 * </g>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
moveGroupAttrsToElems.fn = function (item) {
  // move group transform attr to content's pathElems
  if (
    item.type === 'element' &&
    item.name === 'g' &&
    item.children.length !== 0 &&
    item.attributes.transform != null &&
    Object.entries(item.attributes).some(
      ([name, value]) =>
        referencesProps$1.includes(name) && value.includes('url(')
    ) === false &&
    item.children.every(
      (inner) =>
        pathElemsWithGroupsAndText.includes(inner.name) &&
        inner.attributes.id == null
    )
  ) {
    for (const inner of item.children) {
      const value = item.attributes.transform;
      if (inner.attributes.transform != null) {
        inner.attributes.transform = value + ' ' + inner.attributes.transform;
      } else {
        inner.attributes.transform = value;
      }
    }

    delete item.attributes.transform;
  }
};

var prefixIds = {};

prefixIds.type = 'perItem';

prefixIds.active = false;

prefixIds.params = {
  delim: '__',
  prefixIds: true,
  prefixClassNames: true,
};

prefixIds.description = 'prefix IDs';

var csstree = lib$1,
  collections$1 = _collections,
  referencesProps = collections$1.referencesProps,
  rxId = /^#(.*)$/, // regular expression for matching an ID + extracing its name
  addPrefix = null;

const unquote = (string) => {
  const first = string.charAt(0);
  if (first === "'" || first === '"') {
    if (first === string.charAt(string.length - 1)) {
      return string.slice(1, -1);
    }
  }
  return string;
};

// Escapes a string for being used as ID
var escapeIdentifierName = function (str) {
  return str.replace(/[. ]/g, '_');
};

// Matches an #ID value, captures the ID name
var matchId = function (urlVal) {
  var idUrlMatches = urlVal.match(rxId);
  if (idUrlMatches === null) {
    return false;
  }
  return idUrlMatches[1];
};

// Matches an url(...) value, captures the URL
var matchUrl = function (val) {
  var urlMatches = /url\((.*?)\)/gi.exec(val);
  if (urlMatches === null) {
    return false;
  }
  return urlMatches[1];
};

// prefixes an #ID
var prefixId = function (val) {
  var idName = matchId(val);
  if (!idName) {
    return false;
  }
  return '#' + addPrefix(idName);
};

// prefixes a class attribute value
const addPrefixToClassAttr = (element, name) => {
  if (
    element.attributes[name] == null ||
    element.attributes[name].length === 0
  ) {
    return;
  }

  element.attributes[name] = element.attributes[name]
    .split(/\s+/)
    .map(addPrefix)
    .join(' ');
};

// prefixes an ID attribute value
const addPrefixToIdAttr = (element, name) => {
  if (
    element.attributes[name] == null ||
    element.attributes[name].length === 0
  ) {
    return;
  }

  element.attributes[name] = addPrefix(element.attributes[name]);
};

// prefixes a href attribute value
const addPrefixToHrefAttr = (element, name) => {
  if (
    element.attributes[name] == null ||
    element.attributes[name].length === 0
  ) {
    return;
  }

  const idPrefixed = prefixId(element.attributes[name]);
  if (!idPrefixed) {
    return;
  }
  element.attributes[name] = idPrefixed;
};

// prefixes an URL attribute value
const addPrefixToUrlAttr = (element, name) => {
  if (
    element.attributes[name] == null ||
    element.attributes[name].length === 0
  ) {
    return;
  }

  // url(...) in value
  const urlVal = matchUrl(element.attributes[name]);
  if (!urlVal) {
    return;
  }

  const idPrefixed = prefixId(urlVal);
  if (!idPrefixed) {
    return;
  }

  element.attributes[name] = 'url(' + idPrefixed + ')';
};

// prefixes begin/end attribute value
const addPrefixToBeginEndAttr = (element, name) => {
  if (
    element.attributes[name] == null ||
    element.attributes[name].length === 0
  ) {
    return;
  }

  const parts = element.attributes[name].split('; ').map((val) => {
    val = val.trim();

    if (val.endsWith('.end') || val.endsWith('.start')) {
      const [id, postfix] = val.split('.');

      let idPrefixed = prefixId(`#${id}`);

      if (!idPrefixed) {
        return val;
      }

      idPrefixed = idPrefixed.slice(1);
      return `${idPrefixed}.${postfix}`;
    } else {
      return val;
    }
  });

  element.attributes[name] = parts.join('; ');
};

const getBasename = (path) => {
  // extract everything after latest slash or backslash
  const matched = path.match(/[/\\]([^/\\]+)$/);
  if (matched) {
    return matched[1];
  }
  return '';
};

/**
 * Prefixes identifiers
 *
 * @param {Object} node node
 * @param {Object} opts plugin params
 * @param {Object} extra plugin extra information
 *
 * @author strarsis <strarsis@gmail.com>
 */
prefixIds.fn = function (node, opts, extra) {
  // skip subsequent passes when multipass is used
  if (extra.multipassCount && extra.multipassCount > 0) {
    return;
  }

  // prefix, from file name or option
  var prefix = 'prefix';
  if (opts.prefix) {
    if (typeof opts.prefix === 'function') {
      prefix = opts.prefix(node, extra);
    } else {
      prefix = opts.prefix;
    }
  } else if (opts.prefix === false) {
    prefix = false;
  } else if (extra && extra.path && extra.path.length > 0) {
    var filename = getBasename(extra.path);
    prefix = filename;
  }

  // prefixes a normal value
  addPrefix = function (name) {
    if (prefix === false) {
      return escapeIdentifierName(name);
    }
    return escapeIdentifierName(prefix + opts.delim + name);
  };

  // <style/> property values

  if (node.type === 'element' && node.name === 'style') {
    if (node.children.length === 0) {
      // skip empty <style/>s
      return;
    }

    var cssStr = '';
    if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {
      cssStr = node.children[0].value;
    }

    var cssAst = {};
    try {
      cssAst = csstree.parse(cssStr, {
        parseValue: true,
        parseCustomProperty: false,
      });
    } catch (parseError) {
      console.warn(
        'Warning: Parse error of styles of <style/> element, skipped. Error details: ' +
          parseError
      );
      return;
    }

    var idPrefixed = '';
    csstree.walk(cssAst, function (node) {
      // #ID, .class
      if (
        ((opts.prefixIds && node.type === 'IdSelector') ||
          (opts.prefixClassNames && node.type === 'ClassSelector')) &&
        node.name
      ) {
        node.name = addPrefix(node.name);
        return;
      }

      // url(...) in value
      if (
        node.type === 'Url' &&
        node.value.value &&
        node.value.value.length > 0
      ) {
        idPrefixed = prefixId(unquote(node.value.value));
        if (!idPrefixed) {
          return;
        }
        node.value.value = idPrefixed;
      }
    });

    // update <style>s
    node.children[0].value = csstree.generate(cssAst);
    return;
  }

  // element attributes

  if (node.type !== 'element') {
    return;
  }

  // Nodes

  if (opts.prefixIds) {
    // ID
    addPrefixToIdAttr(node, 'id');
  }

  if (opts.prefixClassNames) {
    // Class
    addPrefixToClassAttr(node, 'class');
  }

  // References

  // href
  addPrefixToHrefAttr(node, 'href');

  // (xlink:)href (deprecated, must be still supported)
  addPrefixToHrefAttr(node, 'xlink:href');

  // (referenceable) properties
  for (var referencesProp of referencesProps) {
    addPrefixToUrlAttr(node, referencesProp);
  }

  addPrefixToBeginEndAttr(node, 'begin');
  addPrefixToBeginEndAttr(node, 'end');
};

var removeAttributesBySelector = {};

removeAttributesBySelector.type = 'perItem';

removeAttributesBySelector.active = false;

removeAttributesBySelector.description =
  'removes attributes of elements that match a css selector';

/**
 * Removes attributes of elements that match a css selector.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @example
 * <caption>A selector removing a single attribute</caption>
 * plugins:
 *   - removeAttributesBySelector:
 *       selector: "[fill='#00ff00']"
 *       attributes: "fill"
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   ↓
 * <rect x="0" y="0" width="100" height="100" stroke="#00ff00"/>
 *
 * <caption>A selector removing multiple attributes</caption>
 * plugins:
 *   - removeAttributesBySelector:
 *       selector: "[fill='#00ff00']"
 *       attributes:
 *         - fill
 *         - stroke
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   ↓
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * <caption>Multiple selectors removing attributes</caption>
 * plugins:
 *   - removeAttributesBySelector:
 *       selectors:
 *         - selector: "[fill='#00ff00']"
 *           attributes: "fill"
 *
 *         - selector: "#remove"
 *           attributes:
 *             - stroke
 *             - id
 *
 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
 *   ↓
 * <rect x="0" y="0" width="100" height="100"/>
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|MDN CSS Selectors}
 *
 * @author Bradley Mease
 */
removeAttributesBySelector.fn = function (item, params) {
  var selectors = Array.isArray(params.selectors) ? params.selectors : [params];

  selectors.map(({ selector, attributes }) => {
    if (item.matches(selector)) {
      if (Array.isArray(attributes)) {
        for (const name of attributes) {
          delete item.attributes[name];
        }
      } else {
        delete item.attributes[attributes];
      }
    }
  });
};

var removeAttrs = {};

var DEFAULT_SEPARATOR = ':';

removeAttrs.type = 'perItem';

removeAttrs.active = false;

removeAttrs.description = 'removes specified attributes';

removeAttrs.params = {
  elemSeparator: DEFAULT_SEPARATOR,
  preserveCurrentColor: false,
  attrs: [],
};

/**
 * Remove attributes
 *
 * @param elemSeparator
 *   format: string
 *
 * @param preserveCurrentColor
 *   format: boolean
 *
 * @param attrs:
 *
 *   format: [ element* : attribute* : value* ]
 *
 *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)
 *   attribute : regexp (wrapped into ^...$)
 *   value     : regexp (wrapped into ^...$), single * or omitted > all values
 *
 *   examples:
 *
 *     > basic: remove fill attribute
 *     ---
 *     removeAttrs:
 *       attrs: 'fill'
 *
 *     > remove fill attribute on path element
 *     ---
 *       attrs: 'path:fill'
 *
 *     > remove fill attribute on path element where value is none
 *     ---
 *       attrs: 'path:fill:none'
 *
 *
 *     > remove all fill and stroke attribute
 *     ---
 *       attrs:
 *         - 'fill'
 *         - 'stroke'
 *
 *     [is same as]
 *
 *       attrs: '(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke)'
 *
 *     [is same as]
 *
 *       attrs: '.*:(fill|stroke):.*'
 *
 *
 *     > remove all stroke related attributes
 *     ----
 *     attrs: 'stroke.*'
 *
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Benny Schudel
 */
removeAttrs.fn = function (item, params) {
  // wrap into an array if params is not
  if (!Array.isArray(params.attrs)) {
    params.attrs = [params.attrs];
  }

  if (item.type === 'element') {
    var elemSeparator =
      typeof params.elemSeparator == 'string'
        ? params.elemSeparator
        : DEFAULT_SEPARATOR;
    var preserveCurrentColor =
      typeof params.preserveCurrentColor == 'boolean'
        ? params.preserveCurrentColor
        : false;

    // prepare patterns
    var patterns = params.attrs.map(function (pattern) {
      // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*
      if (pattern.indexOf(elemSeparator) === -1) {
        pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join('');

        // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value
      } else if (pattern.split(elemSeparator).length < 3) {
        pattern = [pattern, elemSeparator, '.*'].join('');
      }

      // create regexps for element, attribute name, and attribute value
      return pattern.split(elemSeparator).map(function (value) {
        // adjust single * to match anything
        if (value === '*') {
          value = '.*';
        }

        return new RegExp(['^', value, '$'].join(''), 'i');
      });
    });

    // loop patterns
    patterns.forEach(function (pattern) {
      // matches element
      if (pattern[0].test(item.name)) {
        // loop attributes
        for (const [name, value] of Object.entries(item.attributes)) {
          var isFillCurrentColor =
            preserveCurrentColor && name == 'fill' && value == 'currentColor';
          var isStrokeCurrentColor =
            preserveCurrentColor && name == 'stroke' && value == 'currentColor';

          if (!(isFillCurrentColor || isStrokeCurrentColor)) {
            // matches attribute name
            if (pattern[1].test(name)) {
              // matches attribute value
              if (pattern[2].test(value)) {
                delete item.attributes[name];
              }
            }
          }
        }
      }
    });
  }
};

var removeComments = {};

removeComments.type = 'perItem';

removeComments.active = true;

removeComments.description = 'removes comments';

/**
 * Remove comments.
 *
 * @example
 * <!-- Generator: Adobe Illustrator 15.0.0, SVG Export
 * Plug-In . SVG Version: 6.00 Build 0)  -->
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeComments.fn = function (item) {
  if (item.type === 'comment' && item.value.charAt(0) !== '!') {
    return false;
  }
};

var removeDesc = {};

removeDesc.type = 'perItem';

removeDesc.active = true;

removeDesc.params = {
  removeAny: true,
};

removeDesc.description = 'removes <desc>';

var standardDescs = /^(Created with|Created using)/;

/**
 * Removes <desc>.
 * Removes only standard editors content or empty elements 'cause it can be used for accessibility.
 * Enable parameter 'removeAny' to remove any description.
 *
 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Daniel Wabyick
 */
removeDesc.fn = function (item, params) {
  return (
    !item.isElem('desc') ||
    !(
      params.removeAny ||
      item.children.length === 0 ||
      (item.children[0].type === 'text' &&
        standardDescs.test(item.children[0].value))
    )
  );
};

var removeDimensions = {};

removeDimensions.type = 'perItem';

removeDimensions.active = false;

removeDimensions.description =
  'removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)';

/**
 * Remove width/height attributes and add the viewBox attribute if it's missing
 *
 * @example
 * <svg width="100" height="50" />
 *   ↓
 * <svg viewBox="0 0 100 50" />
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if true, with and height will be filtered out
 *
 * @author Benny Schudel
 */
removeDimensions.fn = function (item) {
  if (item.type === 'element' && item.name === 'svg') {
    if (item.attributes.viewBox != null) {
      delete item.attributes.width;
      delete item.attributes.height;
    } else if (
      item.attributes.width != null &&
      item.attributes.height != null &&
      Number.isNaN(Number(item.attributes.width)) === false &&
      Number.isNaN(Number(item.attributes.height)) === false
    ) {
      const width = Number(item.attributes.width);
      const height = Number(item.attributes.height);
      item.attributes.viewBox = `0 0 ${width} ${height}`;
      delete item.attributes.width;
      delete item.attributes.height;
    }
  }
};

var removeDoctype = {};

removeDoctype.type = 'perItem';

removeDoctype.active = true;

removeDoctype.description = 'removes doctype declaration';

/**
 * Remove DOCTYPE declaration.
 *
 * "Unfortunately the SVG DTDs are a source of so many
 * issues that the SVG WG has decided not to write one
 * for the upcoming SVG 1.2 standard. In fact SVG WG
 * members are even telling people not to use a DOCTYPE
 * declaration in SVG 1.0 and 1.1 documents"
 * https://jwatt.org/svg/authoring/#doctype-declaration
 *
 * @example
 * <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 * q"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
 *
 * @example
 * <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 * "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" [
 *     <!-- an internal subset can be embedded here -->
 * ]>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeDoctype.fn = function (item) {
  if (item.type === 'doctype') {
    return false;
  }
};

var removeEditorsNSData = {};

const { parseName: parseName$3 } = tools;
const { editorNamespaces } = _collections;

removeEditorsNSData.type = 'perItem';

removeEditorsNSData.active = true;

removeEditorsNSData.description = 'removes editors namespaces, elements and attributes';

const prefixes = [];

removeEditorsNSData.params = {
  additionalNamespaces: [],
};

/**
 * Remove editors namespaces, elements and attributes.
 *
 * @example
 * <svg xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">
 * <sodipodi:namedview/>
 * <path sodipodi:nodetypes="cccc"/>
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeEditorsNSData.fn = function (item, params) {
  let namespaces = editorNamespaces;
  if (Array.isArray(params.additionalNamespaces)) {
    namespaces = [...editorNamespaces, ...params.additionalNamespaces];
  }

  if (item.type === 'element') {
    if (item.isElem('svg')) {
      for (const [name, value] of Object.entries(item.attributes)) {
        const { prefix, local } = parseName$3(name);
        if (prefix === 'xmlns' && namespaces.includes(value)) {
          prefixes.push(local);

          // <svg xmlns:sodipodi="">
          delete item.attributes[name];
        }
      }
    }

    // <* sodipodi:*="">
    for (const name of Object.keys(item.attributes)) {
      const { prefix } = parseName$3(name);
      if (prefixes.includes(prefix)) {
        delete item.attributes[name];
      }
    }

    // <sodipodi:*>
    const { prefix } = parseName$3(item.name);
    if (prefixes.includes(prefix)) {
      return false;
    }
  }
};

var removeElementsByAttr = {};

removeElementsByAttr.type = 'perItem';

removeElementsByAttr.active = false;

removeElementsByAttr.description =
  'removes arbitrary elements by ID or className (disabled by default)';

removeElementsByAttr.params = {
  id: [],
  class: [],
};

/**
 * Remove arbitrary SVG elements by ID or className.
 *
 * @param id
 *   examples:
 *
 *     > single: remove element with ID of `elementID`
 *     ---
 *     removeElementsByAttr:
 *       id: 'elementID'
 *
 *     > list: remove multiple elements by ID
 *     ---
 *     removeElementsByAttr:
 *       id:
 *         - 'elementID'
 *         - 'anotherID'
 *
 * @param class
 *   examples:
 *
 *     > single: remove all elements with class of `elementClass`
 *     ---
 *     removeElementsByAttr:
 *       class: 'elementClass'
 *
 *     > list: remove all elements with class of `elementClass` or `anotherClass`
 *     ---
 *     removeElementsByAttr:
 *       class:
 *         - 'elementClass'
 *         - 'anotherClass'
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Eli Dupuis (@elidupuis)
 */
removeElementsByAttr.fn = function (item, params) {
  // wrap params in an array if not already
  ['id', 'class'].forEach(function (key) {
    if (!Array.isArray(params[key])) {
      params[key] = [params[key]];
    }
  });

  // abort if current item is no an element
  if (item.type !== 'element') {
    return;
  }

  // remove element if it's `id` matches configured `id` params
  if (item.attributes.id != null && params.id.length !== 0) {
    return params.id.includes(item.attributes.id) === false;
  }

  // remove element if it's `class` contains any of the configured `class` params
  if (item.attributes.class && params.class.length !== 0) {
    const classList = item.attributes.class.split(' ');
    return params.class.some((item) => classList.includes(item)) === false;
  }
};

var removeEmptyAttrs = {};

const { attrsGroups: attrsGroups$2 } = _collections;

removeEmptyAttrs.type = 'perItem';

removeEmptyAttrs.active = true;

removeEmptyAttrs.description = 'removes empty attributes';

/**
 * Remove attributes with empty values.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeEmptyAttrs.fn = function (item) {
  if (item.type === 'element') {
    for (const [name, value] of Object.entries(item.attributes)) {
      if (
        value === '' &&
        // empty conditional processing attributes prevents elements from rendering
        attrsGroups$2.conditionalProcessing.includes(name) === false
      ) {
        delete item.attributes[name];
      }
    }
  }
};

var removeEmptyContainers = {};

const { elemsGroups: elemsGroups$2 } = _collections;

removeEmptyContainers.type = 'perItemReverse';

removeEmptyContainers.active = true;

removeEmptyContainers.description = 'removes empty container elements';

/**
 * Remove empty containers.
 *
 * @see https://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 *
 * @example
 * <defs/>
 *
 * @example
 * <g><marker><a/></marker></g>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeEmptyContainers.fn = function (item) {
  if (item.type === 'element') {
    return (
      item.children.length !== 0 ||
      elemsGroups$2.container.includes(item.name) === false ||
      item.name === 'svg' ||
      // empty patterns may contain reusable configuration
      (item.name === 'pattern' && Object.keys(item.attributes).length !== 0) ||
      // The 'g' may not have content, but the filter may cause a rectangle
      // to be created and filled with pattern.
      (item.name === 'g' && item.attributes.filter != null) ||
      // empty <mask> hides masked element
      (item.name === 'mask' && item.attributes.id != null)
    );
  }
  return true;
};

var removeEmptyText = {};

removeEmptyText.type = 'perItem';

removeEmptyText.active = true;

removeEmptyText.description = 'removes empty <text> elements';

removeEmptyText.params = {
  text: true,
  tspan: true,
  tref: true,
};

/**
 * Remove empty Text elements.
 *
 * @see https://www.w3.org/TR/SVG11/text.html
 *
 * @example
 * Remove empty text element:
 * <text/>
 *
 * Remove empty tspan element:
 * <tspan/>
 *
 * Remove tref with empty xlink:href attribute:
 * <tref xlink:href=""/>
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeEmptyText.fn = function (item, params) {
  if (item.type === 'element') {
    // Remove empty text element
    if (params.text && item.name === 'text' && item.children.length === 0) {
      return false;
    }

    // Remove empty tspan element
    if (params.tspan && item.name === 'tspan' && item.children.length === 0) {
      return false;
    }

    // Remove tref with empty xlink:href attribute
    if (
      params.tref &&
      item.name === 'tref' &&
      item.attributes['xlink:href'] == null
    ) {
      return false;
    }
  }
};

var removeHiddenElems = {};

const {
  querySelector,
  closestByName: closestByName$1,
  detachNodeFromParent,
} = xast;
const { computeStyle } = style;
const { parsePathData } = path;

removeHiddenElems.type = 'visitor';
removeHiddenElems.active = true;
removeHiddenElems.description =
  'removes hidden elements (zero sized, with absent attributes)';

/**
 * Remove hidden elements with disabled rendering:
 * - display="none"
 * - opacity="0"
 * - circle with zero radius
 * - ellipse with zero x-axis or y-axis radius
 * - rectangle with zero width or height
 * - pattern with zero width or height
 * - image with zero width or height
 * - path with empty data
 * - polyline with empty points
 * - polygon with empty points
 *
 * @param {Object} root
 * @param {Object} params
 *
 * @author Kir Belevich
 */
removeHiddenElems.fn = (root, params) => {
  const {
    isHidden = true,
    displayNone = true,
    opacity0 = true,
    circleR0 = true,
    ellipseRX0 = true,
    ellipseRY0 = true,
    rectWidth0 = true,
    rectHeight0 = true,
    patternWidth0 = true,
    patternHeight0 = true,
    imageWidth0 = true,
    imageHeight0 = true,
    pathEmptyD = true,
    polylineEmptyPoints = true,
    polygonEmptyPoints = true,
  } = params;
  return {
    element: {
      enter: (node) => {
        // Removes hidden elements
        // https://www.w3schools.com/cssref/pr_class_visibility.asp
        const computedStyle = computeStyle(node);
        if (
          isHidden &&
          computedStyle.visibility &&
          computedStyle.visibility.type === 'static' &&
          computedStyle.visibility.value === 'hidden' &&
          // keep if any descendant enables visibility
          querySelector(node, '[visibility=visible]') == null
        ) {
          detachNodeFromParent(node);
          return;
        }

        // display="none"
        //
        // https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
        // "A value of display: none indicates that the given element
        // and its children shall not be rendered directly"
        if (
          displayNone &&
          computedStyle.display &&
          computedStyle.display.type === 'static' &&
          computedStyle.display.value === 'none' &&
          // markers with display: none still rendered
          node.name !== 'marker'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // opacity="0"
        //
        // https://www.w3.org/TR/SVG11/masking.html#ObjectAndGroupOpacityProperties
        if (
          opacity0 &&
          computedStyle.opacity &&
          computedStyle.opacity.type === 'static' &&
          computedStyle.opacity.value === '0' &&
          // transparent element inside clipPath still affect clipped elements
          closestByName$1(node, 'clipPath') == null
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Circles with zero radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#CircleElementRAttribute
        // "A value of zero disables rendering of the element"
        //
        // <circle r="0">
        if (
          circleR0 &&
          node.name === 'circle' &&
          node.children.length === 0 &&
          node.attributes.r === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Ellipse with zero x-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRXAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse rx="0">
        if (
          ellipseRX0 &&
          node.name === 'ellipse' &&
          node.children.length === 0 &&
          node.attributes.rx === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Ellipse with zero y-axis radius
        //
        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRYAttribute
        // "A value of zero disables rendering of the element"
        //
        // <ellipse ry="0">
        if (
          ellipseRY0 &&
          node.name === 'ellipse' &&
          node.children.length === 0 &&
          node.attributes.ry === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Rectangle with zero width
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect width="0">
        if (
          rectWidth0 &&
          node.name === 'rect' &&
          node.children.length === 0 &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Rectangle with zero height
        //
        // https://www.w3.org/TR/SVG11/shapes.html#RectElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <rect height="0">
        if (
          rectHeight0 &&
          rectWidth0 &&
          node.name === 'rect' &&
          node.children.length === 0 &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Pattern with zero width
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementWidthAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern width="0">
        if (
          patternWidth0 &&
          node.name === 'pattern' &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Pattern with zero height
        //
        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementHeightAttribute
        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
        //
        // <pattern height="0">
        if (
          patternHeight0 &&
          node.name === 'pattern' &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Image with zero width
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementWidthAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image width="0">
        if (
          imageWidth0 &&
          node.name === 'image' &&
          node.attributes.width === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Image with zero height
        //
        // https://www.w3.org/TR/SVG11/struct.html#ImageElementHeightAttribute
        // "A value of zero disables rendering of the element"
        //
        // <image height="0">
        if (
          imageHeight0 &&
          node.name === 'image' &&
          node.attributes.height === '0'
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Path with empty data
        //
        // https://www.w3.org/TR/SVG11/paths.html#DAttribute
        //
        // <path d=""/>
        if (pathEmptyD && node.name === 'path') {
          if (node.attributes.d == null) {
            detachNodeFromParent(node);
            return;
          }
          const pathData = parsePathData(node.attributes.d);
          if (pathData.length === 0) {
            detachNodeFromParent(node);
            return;
          }
          // keep single point paths for markers
          if (
            pathData.length === 1 &&
            computedStyle['marker-start'] == null &&
            computedStyle['marker-end'] == null
          ) {
            detachNodeFromParent(node);
            return;
          }
          return;
        }

        // Polyline with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolylineElementPointsAttribute
        //
        // <polyline points="">
        if (
          polylineEmptyPoints &&
          node.name === 'polyline' &&
          node.attributes.points == null
        ) {
          detachNodeFromParent(node);
          return;
        }

        // Polygon with empty points
        //
        // https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
        //
        // <polygon points="">
        if (
          polygonEmptyPoints &&
          node.name === 'polygon' &&
          node.attributes.points == null
        ) {
          detachNodeFromParent(node);
          return;
        }
      },
    },
  };
};

var removeMetadata = {};

removeMetadata.type = 'perItem';

removeMetadata.active = true;

removeMetadata.description = 'removes <metadata>';

/**
 * Remove <metadata>.
 *
 * https://www.w3.org/TR/SVG11/metadata.html
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeMetadata.fn = function (item) {
  return !item.isElem('metadata');
};

var removeNonInheritableGroupAttrs = {};

removeNonInheritableGroupAttrs.type = 'perItem';

removeNonInheritableGroupAttrs.active = true;

removeNonInheritableGroupAttrs.description =
  'removes non-inheritable group’s presentational attributes';

const {
  inheritableAttrs,
  attrsGroups: attrsGroups$1,
  presentationNonInheritableGroupAttrs,
} = _collections;

/**
 * Remove non-inheritable group's "presentation" attributes.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeNonInheritableGroupAttrs.fn = function (item) {
  if (item.type === 'element' && item.name === 'g') {
    for (const name of Object.keys(item.attributes)) {
      if (
        attrsGroups$1.presentation.includes(name) === true &&
        inheritableAttrs.includes(name) === false &&
        presentationNonInheritableGroupAttrs.includes(name) === false
      ) {
        delete item.attributes[name];
      }
    }
  }
};

var removeOffCanvasPaths = {};

removeOffCanvasPaths.type = 'perItem';

removeOffCanvasPaths.active = false;

removeOffCanvasPaths.description =
  'removes elements that are drawn outside of the viewbox (disabled by default)';

const JSAPI$3 = jsAPI;

var _path = _path$1,
  intersects = _path.intersects,
  path2js = _path.path2js,
  viewBox,
  viewBoxJS;

/**
 * Remove elements that are drawn outside of the viewbox.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author JoshyPHP
 */
removeOffCanvasPaths.fn = function (item) {
  if (
    item.type === 'element' &&
    item.name === 'path' &&
    item.attributes.d != null &&
    typeof viewBox !== 'undefined'
  ) {
    // Consider that any item with a transform attribute or a M instruction
    // within the viewBox is visible
    if (hasTransform(item) || pathMovesWithinViewBox(item.attributes.d)) {
      return true;
    }

    var pathJS = path2js(item);
    if (pathJS.length === 2) {
      // Use a closed clone of the path if it's too short for intersects()
      pathJS = JSON.parse(JSON.stringify(pathJS));
      pathJS.push({ instruction: 'z' });
    }

    return intersects(viewBoxJS, pathJS);
  }
  if (item.type === 'element' && item.name === 'svg') {
    parseViewBox(item);
  }

  return true;
};

/**
 * Test whether given item or any of its ancestors has a transform attribute.
 *
 * @param {String} path
 * @return {Boolean}
 */
function hasTransform(item) {
  return (
    item.attributes.transform != null ||
    (item.parentNode &&
      item.parentNode.type === 'element' &&
      hasTransform(item.parentNode))
  );
}

/**
 * Parse the viewBox coordinates and compute the JS representation of its path.
 *
 * @param {Object} svg svg element item
 */
function parseViewBox(svg) {
  var viewBoxData = '';
  if (svg.attributes.viewBox != null) {
    // Remove commas and plus signs, normalize and trim whitespace
    viewBoxData = svg.attributes.viewBox;
  } else if (svg.attributes.height != null && svg.attributes.width != null) {
    viewBoxData = `0 0 ${svg.attributes.width} ${svg.attributes.height}`;
  }

  // Remove commas and plus signs, normalize and trim whitespace
  viewBoxData = viewBoxData
    .replace(/[,+]|px/g, ' ')
    .replace(/\s+/g, ' ')
    .replace(/^\s*|\s*$/g, '');

  // Ensure that the dimensions are 4 values separated by space
  var m = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
    viewBoxData
  );
  if (!m) {
    return;
  }

  // Store the viewBox boundaries
  viewBox = {
    left: parseFloat(m[1]),
    top: parseFloat(m[2]),
    right: parseFloat(m[1]) + parseFloat(m[3]),
    bottom: parseFloat(m[2]) + parseFloat(m[4]),
  };

  var path = new JSAPI$3({
    type: 'element',
    name: 'path',
    attributes: {
      d: 'M' + m[1] + ' ' + m[2] + 'h' + m[3] + 'v' + m[4] + 'H' + m[1] + 'z',
    },
    content: [],
  });

  viewBoxJS = path2js(path);
}

/**
 * Test whether given path has a M instruction with coordinates within the viewBox.
 *
 * @param {String} path
 * @return {Boolean}
 */
function pathMovesWithinViewBox(path) {
  var regexp = /M\s*(-?\d*\.?\d+)(?!\d)\s*(-?\d*\.?\d+)/g,
    m;
  while (null !== (m = regexp.exec(path))) {
    if (
      m[1] >= viewBox.left &&
      m[1] <= viewBox.right &&
      m[2] >= viewBox.top &&
      m[2] <= viewBox.bottom
    ) {
      return true;
    }
  }

  return false;
}

var removeRasterImages = {};

removeRasterImages.type = 'perItem';

removeRasterImages.active = false;

removeRasterImages.description = 'removes raster images (disabled by default)';

/**
 * Remove raster images references in <image>.
 *
 * @see https://bugs.webkit.org/show_bug.cgi?id=63548
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeRasterImages.fn = function (item) {
  if (
    item.type === 'element' &&
    item.name === 'image' &&
    item.attributes['xlink:href'] != null &&
    /(\.|image\/)(jpg|png|gif)/.test(item.attributes['xlink:href'])
  ) {
    return false;
  }
};

var removeScriptElement = {};

removeScriptElement.type = 'perItem';

removeScriptElement.active = false;

removeScriptElement.description = 'removes <script> elements (disabled by default)';

/**
 * Remove <script>.
 *
 * https://www.w3.org/TR/SVG11/script.html
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Patrick Klingemann
 */
removeScriptElement.fn = function (item) {
  return !item.isElem('script');
};

var removeStyleElement = {};

removeStyleElement.type = 'perItem';

removeStyleElement.active = false;

removeStyleElement.description = 'removes <style> element (disabled by default)';

/**
 * Remove <style>.
 *
 * https://www.w3.org/TR/SVG11/styling.html#StyleElement
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Betsy Dupuis
 */
removeStyleElement.fn = function (item) {
  return !item.isElem('style');
};

var removeTitle = {};

removeTitle.type = 'perItem';

removeTitle.active = true;

removeTitle.description = 'removes <title>';

/**
 * Remove <title>.
 *
 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Igor Kalashnikov
 */
removeTitle.fn = function (item) {
  return !item.isElem('title');
};

var removeUnknownsAndDefaults = {};

const { parseName: parseName$2 } = tools;

removeUnknownsAndDefaults.type = 'perItem';

removeUnknownsAndDefaults.active = true;

removeUnknownsAndDefaults.description =
  'removes unknown elements content and attributes, removes attrs with default values';

removeUnknownsAndDefaults.params = {
  unknownContent: true,
  unknownAttrs: true,
  defaultAttrs: true,
  uselessOverrides: true,
  keepDataAttrs: true,
  keepAriaAttrs: true,
  keepRoleAttr: false,
};

var collections = _collections,
  elems = collections.elems,
  attrsGroups = collections.attrsGroups,
  elemsGroups$1 = collections.elemsGroups,
  attrsGroupsDefaults = collections.attrsGroupsDefaults,
  attrsInheritable = collections.inheritableAttrs,
  applyGroups = collections.presentationNonInheritableGroupAttrs;

// collect and extend all references
for (const elem of Object.values(elems)) {
  if (elem.attrsGroups) {
    elem.attrs = elem.attrs || [];

    elem.attrsGroups.forEach(function (attrsGroupName) {
      elem.attrs = elem.attrs.concat(attrsGroups[attrsGroupName]);

      var groupDefaults = attrsGroupsDefaults[attrsGroupName];

      if (groupDefaults) {
        elem.defaults = elem.defaults || {};

        for (const [attrName, attr] of Object.entries(groupDefaults)) {
          elem.defaults[attrName] = attr;
        }
      }
    });
  }

  if (elem.contentGroups) {
    elem.content = elem.content || [];

    elem.contentGroups.forEach(function (contentGroupName) {
      elem.content = elem.content.concat(elemsGroups$1[contentGroupName]);
    });
  }
}

/**
 * Remove unknown elements content and attributes,
 * remove attributes with default values.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeUnknownsAndDefaults.fn = function (item, params) {
  // elems w/o namespace prefix
  if (item.type === 'element' && !parseName$2(item.name).prefix) {
    var elem = item.name;

    // remove unknown element's content
    if (
      params.unknownContent &&
      elems[elem] && // make sure we know of this element before checking its children
      elem !== 'foreignObject' // Don't check foreignObject
    ) {
      item.children.forEach(function (content, i) {
        if (
          content.type === 'element' &&
          !parseName$2(content.name).prefix &&
          ((elems[elem].content && // Do we have a record of its permitted content?
            elems[elem].content.indexOf(content.name) === -1) ||
            (!elems[elem].content && // we dont know about its permitted content
              !elems[content.name])) // check that we know about the element at all
        ) {
          item.children.splice(i, 1);
        }
      });
    }

    // remove element's unknown attrs and attrs with default values
    if (elems[elem] && elems[elem].attrs) {
      for (const [name, value] of Object.entries(item.attributes)) {
        const { prefix } = parseName$2(name);
        if (
          name !== 'xmlns' &&
          (prefix === 'xml' || !prefix) &&
          (!params.keepDataAttrs || name.indexOf('data-') != 0) &&
          (!params.keepAriaAttrs || name.indexOf('aria-') != 0) &&
          (!params.keepRoleAttr || name != 'role')
        ) {
          if (
            // unknown attrs
            (params.unknownAttrs && elems[elem].attrs.indexOf(name) === -1) ||
            // attrs with default values
            (params.defaultAttrs &&
              item.attributes.id == null &&
              elems[elem].defaults &&
              elems[elem].defaults[name] === value &&
              (attrsInheritable.includes(name) === false ||
                !item.parentNode.computedAttr(name))) ||
            // useless overrides
            (params.uselessOverrides &&
              item.attributes.id == null &&
              applyGroups.includes(name) === false &&
              attrsInheritable.includes(name) === true &&
              item.parentNode.computedAttr(name, value))
          ) {
            delete item.attributes[name];
          }
        }
      }
    }
  }
};

var removeUnusedNS = {};

const { traverse: traverse$1 } = xast;
const { parseName: parseName$1 } = tools;

removeUnusedNS.type = 'full';

removeUnusedNS.active = true;

removeUnusedNS.description = 'removes unused namespaces declaration';

/**
 * Remove unused namespaces declaration.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeUnusedNS.fn = function (root) {
  let svgElem;
  const xmlnsCollection = [];

  /**
   * Remove namespace from collection.
   *
   * @param {String} ns namescape name
   */
  function removeNSfromCollection(ns) {
    const pos = xmlnsCollection.indexOf(ns);

    // if found - remove ns from the namespaces collection
    if (pos > -1) {
      xmlnsCollection.splice(pos, 1);
    }
  }

  traverse$1(root, (node) => {
    if (node.type === 'element') {
      if (node.name === 'svg') {
        for (const name of Object.keys(node.attributes)) {
          const { prefix, local } = parseName$1(name);
          // collect namespaces
          if (prefix === 'xmlns' && local) {
            xmlnsCollection.push(local);
          }
        }

        // if svg element has ns-attr
        if (xmlnsCollection.length) {
          // save svg element
          svgElem = node;
        }
      }

      if (xmlnsCollection.length) {
        const { prefix } = parseName$1(node.name);
        // check node for the ns-attrs
        if (prefix) {
          removeNSfromCollection(prefix);
        }

        // check each attr for the ns-attrs
        for (const name of Object.keys(node.attributes)) {
          const { prefix } = parseName$1(name);
          removeNSfromCollection(prefix);
        }
      }
    }
  });

  // remove svg element ns-attributes if they are not used even once
  if (xmlnsCollection.length) {
    for (const name of xmlnsCollection) {
      delete svgElem.attributes['xmlns:' + name];
    }
  }

  return root;
};

var removeUselessDefs = {};

const { elemsGroups } = _collections;

removeUselessDefs.type = 'perItem';

removeUselessDefs.active = true;

removeUselessDefs.description = 'removes elements in <defs> without id';

/**
 * Removes content of defs and properties that aren't rendered directly without ids.
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Lev Solntsev
 */
removeUselessDefs.fn = function (item) {
  if (item.type === 'element') {
    if (item.name === 'defs') {
      item.children = getUsefulItems(item, []);
      if (item.children.length === 0) {
        return false;
      }
    } else if (
      elemsGroups.nonRendering.includes(item.name) &&
      item.attributes.id == null
    ) {
      return false;
    }
  }
};

function getUsefulItems(item, usefulItems) {
  for (const child of item.children) {
    if (child.type === 'element') {
      if (child.attributes.id != null || child.name === 'style') {
        usefulItems.push(child);
        child.parentNode = item;
      } else {
        child.children = getUsefulItems(child, usefulItems);
      }
    }
  }

  return usefulItems;
}

var removeUselessStrokeAndFill = {};

removeUselessStrokeAndFill.type = 'perItem';

removeUselessStrokeAndFill.active = true;

removeUselessStrokeAndFill.description = 'removes useless stroke and fill attributes';

removeUselessStrokeAndFill.params = {
  stroke: true,
  fill: true,
  removeNone: false,
  hasStyleOrScript: false,
};

var shape = _collections.elemsGroups.shape,
  regStrokeProps = /^stroke/,
  regFillProps = /^fill-/,
  styleOrScript = ['style', 'script'];

/**
 * Remove useless stroke and fill attrs.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeUselessStrokeAndFill.fn = function (item, params) {
  if (item.isElem(styleOrScript)) {
    params.hasStyleOrScript = true;
  }

  if (
    !params.hasStyleOrScript &&
    item.isElem(shape) &&
    !item.computedAttr('id')
  ) {
    var stroke = params.stroke && item.computedAttr('stroke'),
      fill = params.fill && !item.computedAttr('fill', 'none');

    // remove stroke*
    if (
      params.stroke &&
      (!stroke ||
        stroke == 'none' ||
        item.computedAttr('stroke-opacity', '0') ||
        item.computedAttr('stroke-width', '0'))
    ) {
      // stroke-width may affect the size of marker-end
      if (
        item.computedAttr('stroke-width', '0') === true ||
        item.computedAttr('marker-end') == null
      ) {
        var parentStroke = item.parentNode.computedAttr('stroke'),
          declineStroke = parentStroke && parentStroke != 'none';

        for (const name of Object.keys(item.attributes)) {
          if (regStrokeProps.test(name)) {
            delete item.attributes[name];
          }
        }

        if (declineStroke) {
          item.attributes.stroke = 'none';
        }
      }
    }

    // remove fill*
    if (params.fill && (!fill || item.computedAttr('fill-opacity', '0'))) {
      for (const name of Object.keys(item.attributes)) {
        if (regFillProps.test(name)) {
          delete item.attributes[name];
        }
      }

      if (fill) {
        item.attributes.fill = 'none';
      }
    }

    if (
      params.removeNone &&
      (!stroke || item.attributes.stroke == 'none') &&
      (!fill || item.attributes.fill == 'none')
    ) {
      return false;
    }
  }
};

var removeViewBox = {};

const { closestByName } = xast;

removeViewBox.type = 'perItem';

removeViewBox.active = true;

removeViewBox.description = 'removes viewBox attribute when possible';

const viewBoxElems = ['svg', 'pattern', 'symbol'];

/**
 * Remove viewBox attr which coincides with a width/height box.
 *
 * @see https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
 *
 * @example
 * <svg width="100" height="50" viewBox="0 0 100 50">
 *             ⬇
 * <svg width="100" height="50">
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeViewBox.fn = function (item) {
  if (
    item.type === 'element' &&
    viewBoxElems.includes(item.name) &&
    item.attributes.viewBox != null &&
    item.attributes.width != null &&
    item.attributes.height != null
  ) {
    // TODO remove width/height for such case instead
    if (item.name === 'svg' && closestByName(item.parentNode, 'svg')) {
      return;
    }

    const nums = item.attributes.viewBox.split(/[ ,]+/g);

    if (
      nums[0] === '0' &&
      nums[1] === '0' &&
      item.attributes.width.replace(/px$/, '') === nums[2] && // could use parseFloat too
      item.attributes.height.replace(/px$/, '') === nums[3]
    ) {
      delete item.attributes.viewBox;
    }
  }
};

var removeXMLNS = {};

removeXMLNS.type = 'perItem';

removeXMLNS.active = false;

removeXMLNS.description =
  'removes xmlns attribute (for inline svg, disabled by default)';

/**
 * Remove the xmlns attribute when present.
 *
 * @example
 * <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
 *   ↓
 * <svg viewBox="0 0 100 50">
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if true, xmlns will be filtered out
 *
 * @author Ricardo Tomasi
 */
removeXMLNS.fn = function (item) {
  if (item.type === 'element' && item.name === 'svg') {
    delete item.attributes.xmlns;
  }
};

var removeXMLProcInst = {};

removeXMLProcInst.type = 'perItem';

removeXMLProcInst.active = true;

removeXMLProcInst.description = 'removes XML processing instructions';

/**
 * Remove XML Processing Instruction.
 *
 * @example
 * <?xml version="1.0" encoding="utf-8"?>
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
removeXMLProcInst.fn = function (item) {
  if (item.type === 'instruction' && item.name === 'xml') {
    return false;
  }
  return true;
};

var reusePaths = {};

const { traverse } = xast;
const JSAPI$2 = jsAPI;

reusePaths.type = 'full';

reusePaths.active = false;

reusePaths.description =
  'Finds <path> elements with the same d, fill, and ' +
  'stroke, and converts them to <use> elements ' +
  'referencing a single <path> def.';

/**
 * Finds <path> elements with the same d, fill, and stroke, and converts them to
 * <use> elements referencing a single <path> def.
 *
 * @author Jacob Howcroft
 */
reusePaths.fn = function (root) {
  const seen = new Map();
  let count = 0;
  const defs = [];
  traverse(root, (node) => {
    if (
      node.type !== 'element' ||
      node.name !== 'path' ||
      node.attributes.d == null
    ) {
      return;
    }
    const d = node.attributes.d;
    const fill = node.attributes.fill || '';
    const stroke = node.attributes.stroke || '';
    const key = d + ';s:' + stroke + ';f:' + fill;
    const hasSeen = seen.get(key);
    if (!hasSeen) {
      seen.set(key, { elem: node, reused: false });
      return;
    }
    if (!hasSeen.reused) {
      hasSeen.reused = true;
      if (hasSeen.elem.attributes.id == null) {
        hasSeen.elem.attributes.id = 'reuse-' + count++;
      }
      defs.push(hasSeen.elem);
    }
    convertToUse(node, hasSeen.elem.attributes.id);
  });
  if (defs.length > 0) {
    const defsTag = new JSAPI$2(
      {
        type: 'element',
        name: 'defs',
        attributes: {},
        children: [],
      },
      root
    );
    root.children[0].spliceContent(0, 0, defsTag);
    for (let def of defs) {
      // Remove class and style before copying to avoid circular refs in
      // JSON.stringify. This is fine because we don't actually want class or
      // style information to be copied.
      const style = def.style;
      const defClass = def.class;
      delete def.style;
      delete def.class;
      const defClone = def.clone();
      def.style = style;
      def.class = defClass;
      delete defClone.attributes.transform;
      defsTag.spliceContent(0, 0, defClone);
      // Convert the original def to a use so the first usage isn't duplicated.
      def = convertToUse(def, defClone.attributes.id);
      delete def.attributes.id;
    }
  }
  return root;
};

/** */
function convertToUse(item, href) {
  item.renameElem('use');
  delete item.attributes.d;
  delete item.attributes.stroke;
  delete item.attributes.fill;
  item.attributes['xlink:href'] = '#' + href;
  delete item.pathJS;
  return item;
}

var sortAttrs = {};

const { parseName } = tools;

sortAttrs.type = 'perItem';

sortAttrs.active = false;

sortAttrs.description = 'sorts element attributes (disabled by default)';

sortAttrs.params = {
  order: [
    'id',
    'width',
    'height',
    'x',
    'x1',
    'x2',
    'y',
    'y1',
    'y2',
    'cx',
    'cy',
    'r',
    'fill',
    'stroke',
    'marker',
    'd',
    'points',
  ],
};

/**
 * Sort element attributes for epic readability.
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 *
 * @author Nikolay Frantsev
 */
sortAttrs.fn = function (item, params) {
  const orderlen = params.order.length + 1;
  const xmlnsOrder = params.xmlnsOrder || 'front';

  if (item.type === 'element') {
    const attrs = Object.entries(item.attributes);

    attrs.sort(([aName], [bName]) => {
      const { prefix: aPrefix } = parseName(aName);
      const { prefix: bPrefix } = parseName(bName);
      if (aPrefix != bPrefix) {
        // xmlns attributes implicitly have the prefix xmlns
        if (xmlnsOrder == 'front') {
          if (aPrefix === 'xmlns') return -1;
          if (bPrefix === 'xmlns') return 1;
        }
        return aPrefix < bPrefix ? -1 : 1;
      }

      let aindex = orderlen;
      let bindex = orderlen;

      for (let i = 0; i < params.order.length; i++) {
        if (aName == params.order[i]) {
          aindex = i;
        } else if (aName.indexOf(params.order[i] + '-') === 0) {
          aindex = i + 0.5;
        }
        if (bName == params.order[i]) {
          bindex = i;
        } else if (bName.indexOf(params.order[i] + '-') === 0) {
          bindex = i + 0.5;
        }
      }

      if (aindex != bindex) {
        return aindex - bindex;
      }
      return aName < bName ? -1 : 1;
    });

    const sorted = {};
    for (const [name, value] of attrs) {
      sorted[name] = value;
    }
    item.attributes = sorted;
  }
};

var sortDefsChildren = {};

sortDefsChildren.type = 'perItem';

sortDefsChildren.active = true;

sortDefsChildren.description = 'Sorts children of <defs> to improve compression';

/**
 * Sorts children of defs in order to improve compression.
 * Sorted first by frequency then by element name length then by element name (to ensure grouping).
 *
 * @param {Object} item current iteration item
 * @return {Boolean} if false, item will be filtered out
 *
 * @author David Leston
 */
sortDefsChildren.fn = function (item) {
  if (item.isElem('defs')) {
    var frequency = item.children.reduce(function (frequency, child) {
      if (child.name in frequency) {
        frequency[child.name]++;
      } else {
        frequency[child.name] = 1;
      }
      return frequency;
    }, {});
    item.children.sort(function (a, b) {
      var frequencyComparison = frequency[b.name] - frequency[a.name];
      if (frequencyComparison !== 0) {
        return frequencyComparison;
      }
      var lengthComparison = b.name.length - a.name.length;
      if (lengthComparison !== 0) {
        return lengthComparison;
      }
      return a.name != b.name ? (a.name > b.name ? -1 : 1) : 0;
    });
    return true;
  }
};

plugins$1.addAttributesToSVGElement = addAttributesToSVGElement;
plugins$1.addClassesToSVGElement = addClassesToSVGElement;
plugins$1.cleanupAttrs = cleanupAttrs;
plugins$1.cleanupEnableBackground = cleanupEnableBackground;
plugins$1.cleanupIDs = cleanupIDs;
plugins$1.cleanupListOfValues = cleanupListOfValues;
plugins$1.cleanupNumericValues = cleanupNumericValues;
plugins$1.collapseGroups = collapseGroups;
plugins$1.convertColors = convertColors;
plugins$1.convertEllipseToCircle = convertEllipseToCircle;
plugins$1.convertPathData = convertPathData;
plugins$1.convertShapeToPath = convertShapeToPath;
plugins$1.convertStyleToAttrs = convertStyleToAttrs;
plugins$1.convertTransform = convertTransform$1;
plugins$1.mergeStyles = mergeStyles;
plugins$1.inlineStyles = inlineStyles;
plugins$1.mergePaths = mergePaths;
plugins$1.minifyStyles = minifyStyles;
plugins$1.moveElemsAttrsToGroup = moveElemsAttrsToGroup;
plugins$1.moveGroupAttrsToElems = moveGroupAttrsToElems;
plugins$1.prefixIds = prefixIds;
plugins$1.removeAttributesBySelector = removeAttributesBySelector;
plugins$1.removeAttrs = removeAttrs;
plugins$1.removeComments = removeComments;
plugins$1.removeDesc = removeDesc;
plugins$1.removeDimensions = removeDimensions;
plugins$1.removeDoctype = removeDoctype;
plugins$1.removeEditorsNSData = removeEditorsNSData;
plugins$1.removeElementsByAttr = removeElementsByAttr;
plugins$1.removeEmptyAttrs = removeEmptyAttrs;
plugins$1.removeEmptyContainers = removeEmptyContainers;
plugins$1.removeEmptyText = removeEmptyText;
plugins$1.removeHiddenElems = removeHiddenElems;
plugins$1.removeMetadata = removeMetadata;
plugins$1.removeNonInheritableGroupAttrs = removeNonInheritableGroupAttrs;
plugins$1.removeOffCanvasPaths = removeOffCanvasPaths;
plugins$1.removeRasterImages = removeRasterImages;
plugins$1.removeScriptElement = removeScriptElement;
plugins$1.removeStyleElement = removeStyleElement;
plugins$1.removeTitle = removeTitle;
plugins$1.removeUnknownsAndDefaults = removeUnknownsAndDefaults;
plugins$1.removeUnusedNS = removeUnusedNS;
plugins$1.removeUselessDefs = removeUselessDefs;
plugins$1.removeUselessStrokeAndFill = removeUselessStrokeAndFill;
plugins$1.removeViewBox = removeViewBox;
plugins$1.removeXMLNS = removeXMLNS;
plugins$1.removeXMLProcInst = removeXMLProcInst;
plugins$1.reusePaths = reusePaths;
plugins$1.sortAttrs = sortAttrs;
plugins$1.sortDefsChildren = sortDefsChildren;

const pluginsMap = plugins$1;

const pluginsOrder = [
  'removeDoctype',
  'removeXMLProcInst',
  'removeComments',
  'removeMetadata',
  'removeXMLNS',
  'removeEditorsNSData',
  'cleanupAttrs',
  'mergeStyles',
  'inlineStyles',
  'minifyStyles',
  'convertStyleToAttrs',
  'cleanupIDs',
  'prefixIds',
  'removeRasterImages',
  'removeUselessDefs',
  'cleanupNumericValues',
  'cleanupListOfValues',
  'convertColors',
  'removeUnknownsAndDefaults',
  'removeNonInheritableGroupAttrs',
  'removeUselessStrokeAndFill',
  'removeViewBox',
  'cleanupEnableBackground',
  'removeHiddenElems',
  'removeEmptyText',
  'convertShapeToPath',
  'convertEllipseToCircle',
  'moveElemsAttrsToGroup',
  'moveGroupAttrsToElems',
  'collapseGroups',
  'convertPathData',
  'convertTransform',
  'removeEmptyAttrs',
  'removeEmptyContainers',
  'mergePaths',
  'removeUnusedNS',
  'sortAttrs',
  'sortDefsChildren',
  'removeTitle',
  'removeDesc',
  'removeDimensions',
  'removeAttrs',
  'removeAttributesBySelector',
  'removeElementsByAttr',
  'addClassesToSVGElement',
  'removeStyleElement',
  'removeScriptElement',
  'addAttributesToSVGElement',
  'removeOffCanvasPaths',
  'reusePaths',
];
const defaultPlugins$1 = pluginsOrder.filter((name) => pluginsMap[name].active);
var defaultPlugins_1 = config$1.defaultPlugins = defaultPlugins$1;

const extendDefaultPlugins$2 = (plugins) => {
  const extendedPlugins = pluginsOrder.map((name) => ({
    name,
    active: pluginsMap[name].active,
  }));
  for (const plugin of plugins) {
    const resolvedPlugin = resolvePluginConfig$1(plugin, {});
    const index = pluginsOrder.indexOf(resolvedPlugin.name);
    if (index === -1) {
      extendedPlugins.push(plugin);
    } else {
      extendedPlugins[index] = plugin;
    }
  }
  return extendedPlugins;
};
var extendDefaultPlugins_1 = config$1.extendDefaultPlugins = extendDefaultPlugins$2;

const resolvePluginConfig$1 = (plugin, config) => {
  let configParams = {};
  if ('floatPrecision' in config) {
    configParams.floatPrecision = config.floatPrecision;
  }
  if (typeof plugin === 'string') {
    // resolve builtin plugin specified as string
    const pluginConfig = pluginsMap[plugin];
    if (pluginConfig == null) {
      throw Error(`Unknown builtin plugin "${plugin}" specified.`);
    }
    return {
      ...pluginConfig,
      name: plugin,
      active: true,
      params: { ...pluginConfig.params, ...configParams },
    };
  }
  if (typeof plugin === 'object' && plugin != null) {
    if (plugin.name == null) {
      throw Error(`Plugin name should be specified`);
    }
    if (plugin.fn) {
      // resolve custom plugin with implementation
      return {
        active: true,
        ...plugin,
        params: { ...configParams, ...plugin.params },
      };
    } else {
      // resolve builtin plugin specified as object without implementation
      const pluginConfig = pluginsMap[plugin.name];
      if (pluginConfig == null) {
        throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
      }
      return {
        ...pluginConfig,
        active: true,
        ...plugin,
        params: { ...pluginConfig.params, ...configParams, ...plugin.params },
      };
    }
  }
  return null;
};
config$1.resolvePluginConfig = resolvePluginConfig$1;

var sax = {};

(function (exports) {
(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) };
  sax.SAXParser = SAXParser;

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024;

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ];

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ];

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
    parser.attribList = [];

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS);
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }
    emit(parser, 'onready');
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o;
      var newf = new F();
      return newf
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = [];
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
      return a
    };
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers (parser) {
    closeText(parser);
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function () { end(this); },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this); }
  };

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  };

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  }

  // shorthand
  S = sax.STATE;

  function emit (parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text
  }

  function error (parser, er) {
    closeText(parser);
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c;
    }
    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end');
    }
    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = { name: parser.tagName, attributes: {} };

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }
    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname (name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? [ '', name ] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1];

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }
          tag.ns[local] = parser.attribValue;
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag;

      // add namespace info to tag
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        };

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }
      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing;

    // process the tag
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }
      parser.tag = null;
      parser.tagName = '';
    }
    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return
      }
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }
    var closeTo = tagName;
    while (t--) {
      var close = parser.tags[t];
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return
    }
    parser.tagName = tagName;
    var s = parser.tags.length;
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);

      var x = {};
      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
        });
      }
    }
    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity (parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC;
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, '');
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt (chunk, i) {
    var result = '';
    if (i < chunk.length) {
      result = chunk.charAt(i);
    }
    return result
  }

  function write (chunk) {
    var parser = this;
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString();
    }
    var i = 0;
    var c = '';
    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++;
        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c);
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1);
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <');
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }
            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration');
            }
            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }
          parser.sgmlDecl += c;
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }
            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment');
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }
            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);
            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }
              parser.state = S.ATTRIB;
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';
            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }
            continue
          }
          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }
            continue
          }
          attrib(parser);
          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break
          }

          if (c === ';') {
            var parsedEntity = parseEntity(parser);

            // Custom entities can contain tags, so we potentially need to parse the result
            if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== '&' + parser.entity + ';') {
              chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
            } else {
              parser[buffer] += parsedEntity;
            }

            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }
    return parser
  }
})(exports);
}(sax));

const SAX = sax;
const JSAPI$1 = jsAPI;
const { textElems: textElems$1 } = _collections;

const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;

const config = {
  strict: true,
  trim: false,
  normalize: false,
  lowercase: true,
  xmlns: true,
  position: true,
};

/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @param {String} data input data
 */
var svg2js$1 = function (data) {
  const sax = SAX.parser(config.strict, config);
  const root = new JSAPI$1({ type: 'root', children: [] });
  let current = root;
  let stack = [root];

  function pushToContent(node) {
    const wrapped = new JSAPI$1(node, current);
    current.children.push(wrapped);
    return wrapped;
  }

  sax.ondoctype = function (doctype) {
    pushToContent({
      type: 'doctype',
      // TODO parse doctype for name, public and system to match xast
      name: 'svg',
      data: {
        doctype,
      },
    });

    const subsetStart = doctype.indexOf('[');
    let entityMatch;

    if (subsetStart >= 0) {
      entityDeclaration.lastIndex = subsetStart;

      while ((entityMatch = entityDeclaration.exec(data)) != null) {
        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
      }
    }
  };

  sax.onprocessinginstruction = function (data) {
    pushToContent({
      type: 'instruction',
      name: data.name,
      value: data.body,
    });
  };

  sax.oncomment = function (comment) {
    pushToContent({
      type: 'comment',
      value: comment.trim(),
    });
  };

  sax.oncdata = function (cdata) {
    pushToContent({
      type: 'cdata',
      value: cdata,
    });
  };

  sax.onopentag = function (data) {
    var element = {
      type: 'element',
      name: data.name,
      attributes: {},
      children: [],
    };

    for (const [name, attr] of Object.entries(data.attributes)) {
      element.attributes[name] = attr.value;
    }

    element = pushToContent(element);
    current = element;

    stack.push(element);
  };

  sax.ontext = function (text) {
    // prevent trimming of meaningful whitespace inside textual tags
    if (textElems$1.includes(current.name) && !data.prefix) {
      pushToContent({
        type: 'text',
        value: text,
      });
    } else if (/\S/.test(text)) {
      pushToContent({
        type: 'text',
        value: text.trim(),
      });
    }
  };

  sax.onclosetag = function () {
    stack.pop();
    current = stack[stack.length - 1];
  };

  sax.onerror = function (e) {
    e.message = 'Error in parsing SVG: ' + e.message;
    if (e.message.indexOf('Unexpected end') < 0) {
      throw e;
    }
  };

  try {
    sax.write(data).close();
    return root;
  } catch (e) {
    return { error: e.message };
  }
};

var EOL = require$$1$3.EOL,
  textElems = _collections.textElems;

var defaults = {
  doctypeStart: '<!DOCTYPE',
  doctypeEnd: '>',
  procInstStart: '<?',
  procInstEnd: '?>',
  tagOpenStart: '<',
  tagOpenEnd: '>',
  tagCloseStart: '</',
  tagCloseEnd: '>',
  tagShortStart: '<',
  tagShortEnd: '/>',
  attrStart: '="',
  attrEnd: '"',
  commentStart: '<!--',
  commentEnd: '-->',
  cdataStart: '<![CDATA[',
  cdataEnd: ']]>',
  textStart: '',
  textEnd: '',
  indent: 4,
  regEntities: /[&'"<>]/g,
  regValEntities: /[&"<>]/g,
  encodeEntity: encodeEntity,
  pretty: false,
  useShortTags: true,
};

var entities = {
  '&': '&amp;',
  "'": '&apos;',
  '"': '&quot;',
  '>': '&gt;',
  '<': '&lt;',
};

/**
 * Convert SVG-as-JS object to SVG (XML) string.
 *
 * @param {Object} data input data
 * @param {Object} config config
 *
 * @return {Object} output data
 */
var js2svg$1 = function (data, config) {
  return new JS2SVG(config).convert(data);
};

function JS2SVG(config) {
  if (config) {
    this.config = Object.assign({}, defaults, config);
  } else {
    this.config = Object.assign({}, defaults);
  }

  var indent = this.config.indent;
  if (typeof indent == 'number' && !isNaN(indent)) {
    this.config.indent = indent < 0 ? '\t' : ' '.repeat(indent);
  } else if (typeof indent != 'string') {
    this.config.indent = '    ';
  }

  if (this.config.pretty) {
    this.config.doctypeEnd += EOL;
    this.config.procInstEnd += EOL;
    this.config.commentEnd += EOL;
    this.config.cdataEnd += EOL;
    this.config.tagShortEnd += EOL;
    this.config.tagOpenEnd += EOL;
    this.config.tagCloseEnd += EOL;
    this.config.textEnd += EOL;
  }

  this.indentLevel = 0;
  this.textContext = null;
}

function encodeEntity(char) {
  return entities[char];
}

/**
 * Start conversion.
 *
 * @param {Object} data input data
 *
 * @return {String}
 */
JS2SVG.prototype.convert = function (data) {
  var svg = '';

  this.indentLevel++;

  for (const item of data.children) {
    if (item.type === 'element') {
      svg += this.createElem(item);
    }
    if (item.type === 'text') {
      svg += this.createText(item);
    }
    if (item.type === 'doctype') {
      svg += this.createDoctype(item);
    }
    if (item.type === 'instruction') {
      svg += this.createProcInst(item);
    }
    if (item.type === 'comment') {
      svg += this.createComment(item);
    }
    if (item.type === 'cdata') {
      svg += this.createCDATA(item);
    }
  }

  this.indentLevel--;

  return {
    data: svg,
    info: {
      width: this.width,
      height: this.height,
    },
  };
};

/**
 * Create indent string in accordance with the current node level.
 *
 * @return {String}
 */
JS2SVG.prototype.createIndent = function () {
  var indent = '';

  if (this.config.pretty && !this.textContext) {
    indent = this.config.indent.repeat(this.indentLevel - 1);
  }

  return indent;
};

/**
 * Create doctype tag.
 *
 * @param {String} doctype doctype body string
 *
 * @return {String}
 */
JS2SVG.prototype.createDoctype = function (node) {
  const { doctype } = node.data;
  return this.config.doctypeStart + doctype + this.config.doctypeEnd;
};

/**
 * Create XML Processing Instruction tag.
 *
 * @param {Object} instruction instruction object
 *
 * @return {String}
 */
JS2SVG.prototype.createProcInst = function (node) {
  const { name, value } = node;
  return (
    this.config.procInstStart + name + ' ' + value + this.config.procInstEnd
  );
};

/**
 * Create comment tag.
 *
 * @param {String} comment comment body
 *
 * @return {String}
 */
JS2SVG.prototype.createComment = function (node) {
  const { value } = node;
  return this.config.commentStart + value + this.config.commentEnd;
};

/**
 * Create CDATA section.
 *
 * @param {String} cdata CDATA body
 *
 * @return {String}
 */
JS2SVG.prototype.createCDATA = function (node) {
  const { value } = node;
  return (
    this.createIndent() + this.config.cdataStart + value + this.config.cdataEnd
  );
};

/**
 * Create element tag.
 *
 * @param {Object} data element object
 *
 * @return {String}
 */
JS2SVG.prototype.createElem = function (data) {
  // beautiful injection for obtaining SVG information :)
  if (
    data.name === 'svg' &&
    data.attributes.width != null &&
    data.attributes.height != null
  ) {
    this.width = data.attributes.width;
    this.height = data.attributes.height;
  }

  // empty element and short tag
  if (data.children.length === 0) {
    if (this.config.useShortTags) {
      return (
        this.createIndent() +
        this.config.tagShortStart +
        data.name +
        this.createAttrs(data) +
        this.config.tagShortEnd
      );
    } else {
      return (
        this.createIndent() +
        this.config.tagShortStart +
        data.name +
        this.createAttrs(data) +
        this.config.tagOpenEnd +
        this.config.tagCloseStart +
        data.name +
        this.config.tagCloseEnd
      );
    }
    // non-empty element
  } else {
    var tagOpenStart = this.config.tagOpenStart,
      tagOpenEnd = this.config.tagOpenEnd,
      tagCloseStart = this.config.tagCloseStart,
      tagCloseEnd = this.config.tagCloseEnd,
      openIndent = this.createIndent(),
      closeIndent = this.createIndent(),
      processedData = '',
      dataEnd = '';

    if (this.textContext) {
      tagOpenStart = defaults.tagOpenStart;
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      tagCloseEnd = defaults.tagCloseEnd;
      openIndent = '';
    } else if (data.isElem(textElems)) {
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      closeIndent = '';
      this.textContext = data;
    }

    processedData += this.convert(data).data;

    if (this.textContext == data) {
      this.textContext = null;
    }

    return (
      openIndent +
      tagOpenStart +
      data.name +
      this.createAttrs(data) +
      tagOpenEnd +
      processedData +
      dataEnd +
      closeIndent +
      tagCloseStart +
      data.name +
      tagCloseEnd
    );
  }
};

/**
 * Create element attributes.
 *
 * @param {Object} elem attributes object
 *
 * @return {String}
 */
JS2SVG.prototype.createAttrs = function (element) {
  let attrs = '';
  for (const [name, value] of Object.entries(element.attributes)) {
    if (value !== undefined) {
      const encodedValue = value
        .toString()
        .replace(this.config.regValEntities, this.config.encodeEntity);
      attrs +=
        ' ' + name + this.config.attrStart + encodedValue + this.config.attrEnd;
    } else {
      attrs += ' ' + name;
    }
  }
  return attrs;
};

/**
 * Create text node.
 *
 * @param {String} text text
 *
 * @return {String}
 */
JS2SVG.prototype.createText = function (node) {
  const { value } = node;
  return (
    this.createIndent() +
    this.config.textStart +
    value.replace(this.config.regEntities, this.config.encodeEntity) +
    (this.textContext ? '' : this.config.textEnd)
  );
};

const { visit } = xast;

/**
 * Plugins engine.
 *
 * @module plugins
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins object from config
 * @return {Object} output data
 */
var plugins = function (data, info, plugins) {
  // Try to group sequential elements of plugins array
  // to optimize ast traversing
  const groups = [];
  let prev;
  for (const plugin of plugins) {
    if (prev && plugin.type == prev[0].type) {
      prev.push(plugin);
    } else {
      prev = [plugin];
      groups.push(prev);
    }
  }
  for (const group of groups) {
    switch (group[0].type) {
      case 'perItem':
        data = perItem(data, info, group);
        break;
      case 'perItemReverse':
        data = perItem(data, info, group, true);
        break;
      case 'full':
        data = full(data, info, group);
        break;
      case 'visitor':
        for (const plugin of group) {
          if (plugin.active) {
            const visitor = plugin.fn(data, plugin.params, info);
            visit(data, visitor);
          }
        }
        break;
    }
  }
  return data;
};

/**
 * Direct or reverse per-item loop.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @param {boolean} [reverse] reverse pass?
 * @return {Object} output data
 */
function perItem(data, info, plugins, reverse) {
  function monkeys(items) {
    items.children = items.children.filter(function (item) {
      // reverse pass
      if (reverse && item.children) {
        monkeys(item);
      }

      // main filter
      var filter = true;

      for (var i = 0; filter && i < plugins.length; i++) {
        var plugin = plugins[i];

        if (plugin.active && plugin.fn(item, plugin.params, info) === false) {
          filter = false;
        }
      }

      // direct pass
      if (!reverse && item.children) {
        monkeys(item);
      }

      return filter;
    });

    return items;
  }

  return monkeys(data);
}

/**
 * "Full" plugins.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @return {Object} output data
 */
function full(data, info, plugins) {
  plugins.forEach(function (plugin) {
    if (plugin.active) {
      data = plugin.fn(data, plugin.params, info);
    }
  });

  return data;
}

const {
  defaultPlugins,
  resolvePluginConfig,
  extendDefaultPlugins: extendDefaultPlugins$1,
} = config$1;
const svg2js = svg2js$1;
const js2svg = js2svg$1;
const invokePlugins = plugins;
const JSAPI = jsAPI;
const { encodeSVGDatauri } = tools;

svgo.extendDefaultPlugins = extendDefaultPlugins$1;

const optimize$1 = (input, config) => {
  if (config == null) {
    config = {};
  }
  if (typeof config !== 'object') {
    throw Error('Config should be an object');
  }
  const maxPassCount = config.multipass ? 10 : 1;
  let prevResultSize = Number.POSITIVE_INFINITY;
  let svgjs = null;
  const info = {};
  if (config.path != null) {
    info.path = config.path;
  }
  for (let i = 0; i < maxPassCount; i += 1) {
    info.multipassCount = i;
    svgjs = svg2js(input);
    if (svgjs.error != null) {
      if (config.path != null) {
        svgjs.path = config.path;
      }
      return svgjs;
    }
    const plugins = config.plugins || defaultPlugins;
    if (Array.isArray(plugins) === false) {
      throw Error(
        "Invalid plugins list. Provided 'plugins' in config should be an array."
      );
    }
    const resolvedPlugins = plugins.map((plugin) =>
      resolvePluginConfig(plugin, config)
    );
    svgjs = invokePlugins(svgjs, info, resolvedPlugins);
    svgjs = js2svg(svgjs, config.js2svg);
    if (svgjs.error) {
      throw Error(svgjs.error);
    }
    if (svgjs.data.length < prevResultSize) {
      input = svgjs.data;
      prevResultSize = svgjs.data.length;
    } else {
      if (config.datauri) {
        svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
      }
      if (config.path != null) {
        svgjs.path = config.path;
      }
      return svgjs;
    }
  }
  return svgjs;
};
svgo.optimize = optimize$1;

/**
 * The factory that creates a content item with the helper methods.
 *
 * @param {Object} data which is passed to jsAPI constructor
 * @returns {JSAPI} content item
 */
const createContentItem$1 = (data) => {
  return new JSAPI(data);
};
svgo.createContentItem = createContentItem$1;

const {
  extendDefaultPlugins,
  optimize,
  createContentItem,
} = svgo;
var optimize_1 = optimize;

export { defaultPlugins_1 as defaultPlugins, extendDefaultPlugins_1 as extendDefaultPlugins, optimize_1 as optimize, plugins$1 as plugins };
